var es = Object.defineProperty;
var ts = (e, t, r) => t in e ? es(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var jt = (e, t, r) => (ts(e, typeof t != "symbol" ? t + "" : t, r), r);
import { SUI_TYPE_ARG as rs, Coin as on, JsonRpcProvider as ns, Connection as is, getSuiObjectData as os, getMoveObject as Jn, bytesEqual as ss } from "@mysten/sui.js";
class fs {
  constructor(t, r) {
    jt(this, "provider");
    jt(this, "address");
    this.provider = t, this.address = r;
  }
  async get(t = rs) {
    return (await this.getAllCoins()).find((s) => s.typeArg === t)?.balance || BigInt(0);
  }
  async getAllCoins() {
    const t = await this.provider.query.getOwnedCoins(this.address), r = /* @__PURE__ */ new Map();
    for (const i of t)
      r.has(i.typeArg) ? r.set(i.typeArg, r.get(i.typeArg) + i.balance) : r.set(i.typeArg, i.balance);
    return Array.from(r.entries()).map((i) => ({
      typeArg: i[0],
      balance: i[1]
    }));
  }
}
class d0 {
  constructor(t, r) {
    jt(this, "balance");
    this.balance = new fs(t, r);
  }
}
const Qn = "0x2::coin::Coin";
class gn {
  constructor(t, r, i) {
    jt(this, "_objectId");
    jt(this, "_typeArg");
    jt(this, "_balance");
    jt(this, "_symbol");
    this._objectId = t, this._balance = i, this._typeArg = r, this._symbol = pr.getCoinSymbol(r);
  }
  get objectId() {
    return this._objectId;
  }
  get typeArg() {
    return this._typeArg;
  }
  get balance() {
    return this._balance;
  }
  get symbol() {
    return this._symbol;
  }
  static fromDto(t) {
    return new gn(t.objectId, t.typeArg, t.balance);
  }
  toDto() {
    return {
      objectId: this._objectId,
      balance: this._balance,
      typeArg: this._typeArg,
      symbol: this._symbol
    };
  }
  toString() {
    return JSON.stringify(this.toDto());
  }
}
class pr {
  static isCoin(t) {
    return t.type.startsWith(Qn);
  }
  static isSUI(t) {
    const r = pr.getCoinTypeArg(t);
    return r ? pr.getCoinSymbol(r) === "SUI" : !1;
  }
  static getCoinObject(t) {
    const r = on.getCoinTypeArg(t);
    if (!r)
      throw new Error("coin typeArg cannot be null");
    return new gn(
      t.fields.id.id,
      r,
      BigInt(t.fields.balance)
    );
  }
  static getBalance(t) {
    return BigInt(t.fields.balance);
  }
  static getCoinTypeArg(t) {
    return on.getCoinTypeArg(t);
  }
  static getCoinSymbol(t) {
    return t.substring(t.lastIndexOf(":") + 1);
  }
  static getCoinTypeFromArg(t) {
    return `${Qn}<${t}>`;
  }
}
class ei {
  static isNft(t) {
    return !!(t.fields.name && t.fields.description && t.fields.url);
  }
  static getNftObject(t, r) {
    return {
      objectId: t.fields.id.id,
      name: t.fields.name,
      description: t.fields.description,
      url: t.fields.url,
      previousTransaction: r,
      objectType: t.type
    };
  }
}
const b0 = "0x0000000000000000000000000000000000000005";
class y0 {
  constructor(t) {
    jt(this, "query");
    this.query = new as(t);
  }
}
class as {
  constructor(t) {
    jt(this, "provider");
    this.provider = new ns(new is({ fullnode: t }));
  }
  async getOwnedObjects(t) {
    let r = !0, i = null, s = [];
    for (; r; ) {
      const h = await this.provider.getOwnedObjects({
        owner: t,
        cursor: i,
        options: {
          showType: !0,
          showDisplay: !0,
          showContent: !0,
          showOwner: !0
        }
      });
      h.data?.forEach((b) => {
        const l = os(b);
        l && s.push(l);
      }), r = h.hasNextPage, i = h.nextCursor;
    }
    return s;
  }
  async getOwnedCoins(t) {
    return (await this.getOwnedObjects(t)).map((s) => ({
      id: s.objectId,
      object: Jn(s)
    })).filter((s) => s.object && on.isCoin(s.object)).map((s) => pr.getCoinObject(s.object));
  }
  async getOwnedNfts(t) {
    return (await this.getOwnedObjects(t)).map((s) => ({
      id: s.objectId,
      object: Jn(s),
      previousTransaction: s.previousTransaction
    })).filter((s) => s.object && ei.isNft(s.object)).map((s) => {
      const h = s.object;
      return ei.getNftObject(h, s.previousTransaction ?? null);
    });
  }
}
const ti = 1e6, zr = 1e9, Yr = 1e12;
function p0(e, t) {
  return mi(
    e,
    Object.assign(
      {
        decimals: 9
      },
      t
    )
  );
}
function mi(e, t) {
  const { decimals: r = 0, withAbbr: i = !0 } = t ?? {};
  if (typeof e == "bigint" && !us(e))
    return Si(BigInt(e), {
      decimals: r,
      withAbbr: i
    });
  if (Number(e) === 0)
    return "0";
  if (Number(e) < 0)
    return "-" + mi(-Number(e), t);
  const s = Number(e) / 10 ** r;
  return s > 0 && s < 1 ? cs(s) : Ei(s, i);
}
function Ei(e, t) {
  if (t) {
    if (e >= ti && e < zr)
      return Wr(e, ti, "M");
    if (e >= zr && e < Yr)
      return Wr(e, zr, "B");
    if (e >= Yr)
      return Wr(e, Yr, "T");
  }
  return Intl.NumberFormat("en-US").format(e);
}
function Wr(e, t, r) {
  let i;
  typeof e == "bigint" ? i = String(e / (BigInt(t) / 1000n)) : i = String(Math.floor(e / (t / 1e3)));
  const s = i.padEnd(4, "0");
  return Intl.NumberFormat("en-US").format(Number(s)).replace(",", ".") + r;
}
function cs(e) {
  if (e <= 0)
    return "0";
  const t = Math.ceil(-Math.log10(e));
  return Number(e) % Math.pow(10, 10 - (t + 2)) === 0 && Number(e) % Math.pow(10, 10 - (t + 1)) === 0 ? Zr(e, t) : Number(e) % Math.pow(10, 10 - (t + 2)) === 0 && Number(e) % Math.pow(10, 10 - (t + 1)) !== 0 ? Zr(e, t + 1) : Zr(e, t + 2);
}
function Zr(e, t) {
  function r(i) {
    if (isNaN(i))
      return i.toString();
    const s = "" + i;
    return /e/i.test(s) ? i.toFixed(18).replace(/\.?0+$/, "") : i.toString();
  }
  return t = t || 0, t = Math.pow(10, t), r(Math.floor(e * t) / t);
}
function Si(e, t) {
  if (e === 0n)
    return "0";
  if (e < 0n)
    return "-" + Si(-e, t);
  const { decimals: r = 9, withAbbr: i = !0 } = t ?? {}, s = e / 10n ** BigInt(r);
  return Ei(s, i);
}
function us(e) {
  const t = Number.MIN_SAFE_INTEGER, r = Number.MAX_SAFE_INTEGER;
  return e >= BigInt(t) && e <= BigInt(r);
}
function g0(e) {
  return typeof e != "string" ? "" : !e || !e.startsWith("0x") ? e : e.slice(0, 7) + "...." + e.slice(-4, e.length);
}
function ls(e) {
  var t = e.default;
  if (typeof t == "function") {
    var r = function() {
      return t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var s = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(r, i, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), r;
}
var Bi = { exports: {} };
function hs(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i), h = s.charCodeAt(0);
    if (t[h] !== 255)
      throw new TypeError(s + " is ambiguous");
    t[h] = i;
  }
  var u = e.length, b = e.charAt(0), l = Math.log(u) / Math.log(256), p = Math.log(256) / Math.log(u);
  function B(U) {
    if (U instanceof Uint8Array || (ArrayBuffer.isView(U) ? U = new Uint8Array(U.buffer, U.byteOffset, U.byteLength) : Array.isArray(U) && (U = Uint8Array.from(U))), !(U instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (U.length === 0)
      return "";
    for (var $ = 0, D = 0, Z = 0, pe = U.length; Z !== pe && U[Z] === 0; )
      Z++, $++;
    for (var v = (pe - Z) * p + 1 >>> 0, m = new Uint8Array(v); Z !== pe; ) {
      for (var d = U[Z], V = 0, S = v - 1; (d !== 0 || V < D) && S !== -1; S--, V++)
        d += 256 * m[S] >>> 0, m[S] = d % u >>> 0, d = d / u >>> 0;
      if (d !== 0)
        throw new Error("Non-zero carry");
      D = V, Z++;
    }
    for (var j = v - D; j !== v && m[j] === 0; )
      j++;
    for (var W = b.repeat($); j < v; ++j)
      W += e.charAt(m[j]);
    return W;
  }
  function w(U) {
    if (typeof U != "string")
      throw new TypeError("Expected String");
    if (U.length === 0)
      return new Uint8Array();
    for (var $ = 0, D = 0, Z = 0; U[$] === b; )
      D++, $++;
    for (var pe = (U.length - $) * l + 1 >>> 0, v = new Uint8Array(pe); U[$]; ) {
      var m = t[U.charCodeAt($)];
      if (m === 255)
        return;
      for (var d = 0, V = pe - 1; (m !== 0 || d < Z) && V !== -1; V--, d++)
        m += u * v[V] >>> 0, v[V] = m % 256 >>> 0, m = m / 256 >>> 0;
      if (m !== 0)
        throw new Error("Non-zero carry");
      Z = d, $++;
    }
    for (var S = pe - Z; S !== pe && v[S] === 0; )
      S++;
    for (var j = new Uint8Array(D + (pe - S)), W = D; S !== pe; )
      j[W++] = v[S++];
    return j;
  }
  function O(U) {
    var $ = w(U);
    if ($)
      return $;
    throw new Error("Non-base" + u + " character");
  }
  return {
    encode: B,
    decodeUnsafe: w,
    decode: O
  };
}
var ds = hs;
const bs = ds, ys = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var ps = bs(ys), gs = Object.create, Pr = Object.defineProperty, xs = Object.getOwnPropertyDescriptor, ws = Object.getOwnPropertyNames, _s = Object.getPrototypeOf, vs = Object.prototype.hasOwnProperty, ms = (e, t) => {
  for (var r in t)
    Pr(e, r, { get: t[r], enumerable: !0 });
}, Ai = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of ws(t))
      !vs.call(e, s) && s !== r && Pr(e, s, { get: () => t[s], enumerable: !(i = xs(t, s)) || i.enumerable });
  return e;
}, Es = (e, t, r) => (r = e != null ? gs(_s(e)) : {}, Ai(
  t || !e || !e.__esModule ? Pr(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), Ss = (e) => Ai(Pr({}, "__esModule", { value: !0 }), e), Ti = {};
ms(Ti, {
  BCS: () => ze,
  BcsReader: () => Ii,
  BcsWriter: () => Ui,
  decodeStr: () => Ni,
  encodeStr: () => ji,
  fromB58: () => wn,
  fromB64: () => Ir,
  fromHEX: () => jr,
  getRustConfig: () => Os,
  getSuiMoveConfig: () => Ps,
  registerPrimitives: () => $i,
  splitGenericParameters: () => Ci,
  toB58: () => xn,
  toB64: () => Ur,
  toHEX: () => Nr
});
var Bt = Ss(Ti);
function Bs(e) {
  return e > 64 && e < 91 ? e - 65 : e > 96 && e < 123 ? e - 71 : e > 47 && e < 58 ? e + 4 : e === 43 ? 62 : e === 47 ? 63 : 0;
}
function Ir(e, t) {
  for (var r = e.replace(/[^A-Za-z0-9+/]/g, ""), i = r.length, s = t ? Math.ceil((i * 3 + 1 >> 2) / t) * t : i * 3 + 1 >> 2, h = new Uint8Array(s), u, b, l = 0, p = 0, B = 0; B < i; B++)
    if (b = B & 3, l |= Bs(r.charCodeAt(B)) << 6 * (3 - b), b === 3 || i - B === 1) {
      for (u = 0; u < 3 && p < s; u++, p++)
        h[p] = l >>> (16 >>> u & 24) & 255;
      l = 0;
    }
  return h;
}
function mr(e) {
  return e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : e === 62 ? 43 : e === 63 ? 47 : 65;
}
function Ur(e) {
  for (var t = 2, r = "", i = e.length, s = 0, h = 0; h < i; h++)
    t = h % 3, s |= e[h] << (16 >>> t & 24), (t === 2 || e.length - h === 1) && (r += String.fromCodePoint(
      mr(s >>> 18 & 63),
      mr(s >>> 12 & 63),
      mr(s >>> 6 & 63),
      mr(s & 63)
    ), s = 0);
  return r.slice(0, r.length - 2 + t) + (t === 2 ? "" : t === 1 ? "=" : "==");
}
function jr(e) {
  let t = e.replace("0x", "").match(/.{1,2}/g).map((r) => parseInt(r, 16));
  if (t === null)
    throw new Error(`Unable to parse HEX: ${e}`);
  return Uint8Array.from(t);
}
function Nr(e) {
  return e.reduce((t, r) => t + r.toString(16).padStart(2, "0"), "");
}
var Oi = Es(ps), Pi = 32;
function Fr(e, t) {
  let r = new Uint8Array(t), i = 0;
  for (; e > 0; )
    r[i] = Number(e % BigInt(256)), e = e / BigInt(256), i += 1;
  return r;
}
var xn = (e) => Oi.default.encode(e), wn = (e) => Oi.default.decode(e), Ii = class {
  constructor(e) {
    this.bytePosition = 0, this.dataView = new DataView(e.buffer);
  }
  shift(e) {
    return this.bytePosition += e, this;
  }
  read8() {
    let e = this.dataView.getUint8(this.bytePosition);
    return this.shift(1), e;
  }
  read16() {
    let e = this.dataView.getUint16(this.bytePosition, !0);
    return this.shift(2), e;
  }
  read32() {
    let e = this.dataView.getUint32(this.bytePosition, !0);
    return this.shift(4), e;
  }
  read64() {
    let e = this.read32(), r = this.read32().toString(16) + e.toString(16).padStart(8, "0");
    return BigInt("0x" + r).toString(10);
  }
  read128() {
    let e = BigInt(this.read64()), r = BigInt(this.read64()).toString(16) + e.toString(16).padStart(16, "0");
    return BigInt("0x" + r).toString(10);
  }
  read256() {
    let e = BigInt(this.read128()), r = BigInt(this.read128()).toString(16) + e.toString(16).padStart(32, "0");
    return BigInt("0x" + r).toString(10);
  }
  readBytes(e) {
    let t = this.bytePosition + this.dataView.byteOffset, r = new Uint8Array(this.dataView.buffer, t, e);
    return this.shift(e), r;
  }
  readULEB() {
    let e = this.bytePosition + this.dataView.byteOffset, t = new Uint8Array(this.dataView.buffer, e), { value: r, length: i } = Ts(t);
    return this.shift(i), r;
  }
  readVec(e) {
    let t = this.readULEB(), r = [];
    for (let i = 0; i < t; i++)
      r.push(e(this, i, t));
    return r;
  }
}, Ui = class {
  constructor({ size: e = 1024, maxSize: t, allocateSize: r = 1024 } = {}) {
    this.bytePosition = 0, this.size = e, this.maxSize = t || e, this.allocateSize = r, this.dataView = new DataView(new ArrayBuffer(e));
  }
  ensureSizeOrGrow(e) {
    const t = this.bytePosition + e;
    if (t > this.size) {
      const r = Math.min(this.maxSize, this.size + this.allocateSize);
      if (t > r)
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`
        );
      this.size = r;
      const i = new ArrayBuffer(this.size);
      new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)), this.dataView = new DataView(i);
    }
  }
  shift(e) {
    return this.bytePosition += e, this;
  }
  write8(e) {
    return this.ensureSizeOrGrow(1), this.dataView.setUint8(this.bytePosition, Number(e)), this.shift(1);
  }
  write16(e) {
    return this.ensureSizeOrGrow(2), this.dataView.setUint16(this.bytePosition, Number(e), !0), this.shift(2);
  }
  write32(e) {
    return this.ensureSizeOrGrow(4), this.dataView.setUint32(this.bytePosition, Number(e), !0), this.shift(4);
  }
  write64(e) {
    return Fr(BigInt(e), 8).forEach((t) => this.write8(t)), this;
  }
  write128(e) {
    return Fr(BigInt(e), 16).forEach((t) => this.write8(t)), this;
  }
  write256(e) {
    return Fr(BigInt(e), 32).forEach((t) => this.write8(t)), this;
  }
  writeULEB(e) {
    return As(e).forEach((t) => this.write8(t)), this;
  }
  writeVec(e, t) {
    return this.writeULEB(e.length), Array.from(e).forEach((r, i) => t(this, r, i, e.length)), this;
  }
  *[Symbol.iterator]() {
    for (let e = 0; e < this.bytePosition; e++)
      yield this.dataView.getUint8(e);
    return this.toBytes();
  }
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  toString(e) {
    return ji(this.toBytes(), e);
  }
};
function As(e) {
  let t = [], r = 0;
  if (e === 0)
    return [0];
  for (; e > 0; )
    t[r] = e & 127, (e >>= 7) && (t[r] |= 128), r += 1;
  return t;
}
function Ts(e) {
  let t = 0, r = 0, i = 0;
  for (; ; ) {
    let s = e[i];
    if (i += 1, t |= (s & 127) << r, (s & 128) === 0)
      break;
    r += 7;
  }
  return {
    value: t,
    length: i
  };
}
var yr = class {
  constructor(e) {
    if (this.types = /* @__PURE__ */ new Map(), this.counter = 0, e instanceof yr) {
      this.schema = e.schema, this.types = new Map(e.types);
      return;
    }
    if (this.schema = e, this.registerAddressType(yr.ADDRESS, e.addressLength, e.addressEncoding), this.registerVectorType(e.vectorType), e.types && e.types.structs)
      for (let t of Object.keys(e.types.structs))
        this.registerStructType(t, e.types.structs[t]);
    if (e.types && e.types.enums)
      for (let t of Object.keys(e.types.enums))
        this.registerEnumType(t, e.types.enums[t]);
    if (e.types && e.types.aliases)
      for (let t of Object.keys(e.types.aliases))
        this.registerAlias(t, e.types.aliases[t]);
    e.withPrimitives !== !1 && $i(this);
  }
  tempKey() {
    return `bcs-struct-${++this.counter}`;
  }
  ser(e, t, r) {
    if (typeof e == "string" || Array.isArray(e)) {
      const { name: i, params: s } = this.parseTypeName(e);
      return this.getTypeInterface(i).encode(this, t, r, s);
    }
    if (typeof e == "object") {
      const i = this.tempKey();
      return new yr(this).registerStructType(i, e).ser(i, t, r);
    }
    throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(e)}`);
  }
  de(e, t, r) {
    if (typeof t == "string")
      if (r)
        t = Ni(t, r);
      else
        throw new Error("To pass a string to `bcs.de`, specify encoding");
    if (typeof e == "string" || Array.isArray(e)) {
      const { name: i, params: s } = this.parseTypeName(e);
      return this.getTypeInterface(i).decode(this, t, s);
    }
    if (typeof e == "object") {
      const i = new yr(this), s = this.tempKey();
      return i.registerStructType(s, e).de(s, t, r);
    }
    throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(e)}`);
  }
  hasType(e) {
    return this.types.has(e);
  }
  registerAlias(e, t) {
    return this.types.set(e, t), this;
  }
  registerType(e, t, r, i = () => !0) {
    const { name: s, params: h } = this.parseTypeName(e);
    return this.types.set(s, {
      encode(u, b, l, p) {
        const B = h.reduce((w, O, U) => Object.assign(w, { [O]: p[U] }), {});
        return this._encodeRaw.call(u, new Ui(l), b, p, B);
      },
      decode(u, b, l) {
        const p = h.reduce((B, w, O) => Object.assign(B, { [w]: l[O] }), {});
        return this._decodeRaw.call(u, new Ii(b), l, p);
      },
      _encodeRaw(u, b, l, p) {
        if (i(b))
          return t.call(this, u, b, l, p);
        throw new Error(`Validation failed for type ${s}, data: ${b}`);
      },
      _decodeRaw(u, b, l) {
        return r.call(this, u, b, l);
      }
    }), this;
  }
  registerAddressType(e, t, r = "hex") {
    switch (r) {
      case "base64":
        return this.registerType(
          e,
          function(s, h) {
            return Ir(h).reduce((u, b) => u.write8(b), s);
          },
          function(s) {
            return Ur(s.readBytes(t));
          }
        );
      case "hex":
        return this.registerType(
          e,
          function(s, h) {
            return jr(h).reduce((u, b) => u.write8(b), s);
          },
          function(s) {
            return Nr(s.readBytes(t));
          }
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  registerVectorType(e) {
    let { name: t, params: r } = this.parseTypeName(e);
    if (r.length > 1)
      throw new Error("Vector can have only one type parameter; got " + t);
    return this.registerType(
      e,
      function(s, h, u, b) {
        return s.writeVec(h, (l, p) => {
          let B = u[0];
          if (!B)
            throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);
          let { name: w, params: O } = this.parseTypeName(B);
          if (this.hasType(w))
            return this.getTypeInterface(w)._encodeRaw.call(this, l, p, O, b);
          if (!(w in b))
            throw new Error(
              `Unable to find a matching type definition for ${w} in vector; make sure you passed a generic`
            );
          let { name: U, params: $ } = this.parseTypeName(b[w]);
          return this.getTypeInterface(U)._encodeRaw.call(
            this,
            l,
            p,
            $,
            b
          );
        });
      },
      function(s, h, u) {
        return s.readVec((b) => {
          let l = h[0];
          if (!l)
            throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);
          let { name: p, params: B } = this.parseTypeName(l);
          if (this.hasType(p))
            return this.getTypeInterface(p)._decodeRaw.call(this, b, B, u);
          if (!(p in u))
            throw new Error(
              `Unable to find a matching type definition for ${p} in vector; make sure you passed a generic`
            );
          let { name: w, params: O } = this.parseTypeName(u[p]);
          return this.getTypeInterface(w)._decodeRaw.call(
            this,
            b,
            O,
            u
          );
        });
      }
    );
  }
  registerStructType(e, t) {
    for (let u in t) {
      let b = this.tempKey(), l = t[u];
      !Array.isArray(l) && typeof l != "string" && (t[u] = b, this.registerStructType(b, l));
    }
    let r = Object.freeze(t), i = Object.keys(r), { name: s, params: h } = this.parseTypeName(e);
    return this.registerType(
      e,
      function(b, l, p, B) {
        if (!l || l.constructor !== Object)
          throw new Error(`Expected ${s} to be an Object, got: ${l}`);
        if (p.length !== h.length)
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${h.length}, got: ${p.length}`
          );
        for (let w of i) {
          if (!(w in l))
            throw new Error(`Struct ${s} requires field ${w}:${r[w]}`);
          const { name: O, params: U } = this.parseTypeName(
            r[w]
          );
          if (!h.includes(O))
            this.getTypeInterface(O)._encodeRaw.call(
              this,
              b,
              l[w],
              U,
              B
            );
          else {
            const $ = h.indexOf(O);
            let { name: D, params: Z } = this.parseTypeName(p[$]);
            if (this.hasType(D)) {
              this.getTypeInterface(D)._encodeRaw.call(
                this,
                b,
                l[w],
                Z,
                B
              );
              continue;
            }
            if (!(D in B))
              throw new Error(
                `Unable to find a matching type definition for ${D} in ${s}; make sure you passed a generic`
              );
            let { name: pe, params: v } = this.parseTypeName(B[D]);
            this.getTypeInterface(pe)._encodeRaw.call(
              this,
              b,
              l[w],
              v,
              B
            );
          }
        }
        return b;
      },
      function(b, l, p) {
        if (l.length !== h.length)
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${h.length}, got: ${l.length}`
          );
        let B = {};
        for (let w of i) {
          const { name: O, params: U } = this.parseTypeName(
            r[w]
          );
          if (!h.includes(O))
            B[w] = this.getTypeInterface(O)._decodeRaw.call(
              this,
              b,
              U,
              p
            );
          else {
            const $ = h.indexOf(O);
            let { name: D, params: Z } = this.parseTypeName(l[$]);
            if (this.hasType(D)) {
              B[w] = this.getTypeInterface(D)._decodeRaw.call(
                this,
                b,
                Z,
                p
              );
              continue;
            }
            if (!(D in p))
              throw new Error(
                `Unable to find a matching type definition for ${D} in ${s}; make sure you passed a generic`
              );
            let { name: pe, params: v } = this.parseTypeName(p[D]);
            B[w] = this.getTypeInterface(pe)._decodeRaw.call(
              this,
              b,
              v,
              p
            );
          }
        }
        return B;
      }
    );
  }
  registerEnumType(e, t) {
    for (let u in t) {
      let b = this.tempKey(), l = t[u];
      l !== null && !Array.isArray(l) && typeof l != "string" && (t[u] = b, this.registerStructType(b, l));
    }
    let r = Object.freeze(t), i = Object.keys(r), { name: s, params: h } = this.parseTypeName(e);
    return this.registerType(
      e,
      function(b, l, p, B) {
        if (!l)
          throw new Error(`Unable to write enum "${s}", missing data.
Received: "${l}"`);
        if (typeof l != "object")
          throw new Error(
            `Incorrect data passed into enum "${s}", expected object with properties: "${i.join(
              " | "
            )}".
Received: "${JSON.stringify(l)}"`
          );
        let w = Object.keys(l)[0];
        if (w === void 0)
          throw new Error(`Empty object passed as invariant of the enum "${s}"`);
        let O = i.indexOf(w);
        if (O === -1)
          throw new Error(
            `Unknown invariant of the enum "${s}", allowed values: "${i.join(
              " | "
            )}"; received "${w}"`
          );
        let U = i[O], $ = r[U];
        if (b.write8(O), $ === null)
          return b;
        let D = h.indexOf($), Z = D === -1 ? $ : p[D];
        {
          let { name: pe, params: v } = this.parseTypeName(Z);
          return this.getTypeInterface(pe)._encodeRaw.call(
            this,
            b,
            l[w],
            v,
            B
          );
        }
      },
      function(b, l, p) {
        let B = b.readULEB(), w = i[B], O = r[w];
        if (B === -1)
          throw new Error(
            `Decoding type mismatch, expected enum "${s}" invariant index, received "${B}"`
          );
        if (O === null)
          return { [w]: !0 };
        let U = h.indexOf(O), $ = U === -1 ? O : l[U];
        {
          let { name: D, params: Z } = this.parseTypeName($);
          return {
            [w]: this.getTypeInterface(D)._decodeRaw.call(this, b, Z, p)
          };
        }
      }
    );
  }
  getTypeInterface(e) {
    let t = this.types.get(e);
    if (typeof t == "string") {
      let r = [];
      for (; typeof t == "string"; ) {
        if (r.includes(t))
          throw new Error(`Recursive definition found: ${r.join(" -> ")} -> ${t}`);
        r.push(t), t = this.types.get(t);
      }
    }
    if (t === void 0)
      throw new Error(`Type ${e} is not registered`);
    return t;
  }
  parseTypeName(e) {
    if (Array.isArray(e)) {
      let [b, ...l] = e;
      return { name: b, params: l };
    }
    if (typeof e != "string")
      throw new Error(`Illegal type passed as a name of the type: ${e}`);
    let [t, r] = this.schema.genericSeparators || ["<", ">"], i = e.indexOf(t), s = Array.from(e).reverse().indexOf(r);
    if (i === -1 && s === -1)
      return { name: e, params: [] };
    if (i === -1 || s === -1)
      throw new Error(`Unclosed generic in name '${e}'`);
    let h = e.slice(0, i), u = Ci(
      e.slice(i + 1, e.length - s - 1),
      this.schema.genericSeparators
    );
    return { name: h, params: u };
  }
}, ze = yr;
ze.U8 = "u8";
ze.U16 = "u16";
ze.U32 = "u32";
ze.U64 = "u64";
ze.U128 = "u128";
ze.U256 = "u256";
ze.BOOL = "bool";
ze.VECTOR = "vector";
ze.ADDRESS = "address";
ze.STRING = "string";
ze.HEX = "hex-string";
ze.BASE58 = "base58-string";
ze.BASE64 = "base64-string";
function ji(e, t) {
  switch (t) {
    case "base58":
      return xn(e);
    case "base64":
      return Ur(e);
    case "hex":
      return Nr(e);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function Ni(e, t) {
  switch (t) {
    case "base58":
      return wn(e);
    case "base64":
      return Ir(e);
    case "hex":
      return jr(e);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function $i(e) {
  e.registerType(
    ze.U8,
    function(t, r) {
      return t.write8(r);
    },
    function(t) {
      return t.read8();
    },
    (t) => t < 256
  ), e.registerType(
    ze.U16,
    function(t, r) {
      return t.write16(r);
    },
    function(t) {
      return t.read16();
    },
    (t) => t < 65536
  ), e.registerType(
    ze.U32,
    function(t, r) {
      return t.write32(r);
    },
    function(t) {
      return t.read32();
    },
    (t) => t <= 4294967296n
  ), e.registerType(
    ze.U64,
    function(t, r) {
      return t.write64(r);
    },
    function(t) {
      return t.read64();
    }
  ), e.registerType(
    ze.U128,
    function(t, r) {
      return t.write128(r);
    },
    function(t) {
      return t.read128();
    }
  ), e.registerType(
    ze.U256,
    function(t, r) {
      return t.write256(r);
    },
    function(t) {
      return t.read256();
    }
  ), e.registerType(
    ze.BOOL,
    function(t, r) {
      return t.write8(r);
    },
    function(t) {
      return t.read8().toString(10) === "1";
    }
  ), e.registerType(
    ze.STRING,
    function(t, r) {
      return t.writeVec(Array.from(r), (i, s) => i.write8(s.charCodeAt(0)));
    },
    function(t) {
      return t.readVec((r) => r.read8()).map((r) => String.fromCharCode(Number(r))).join("");
    },
    (t) => !0
  ), e.registerType(
    ze.HEX,
    function(t, r) {
      return t.writeVec(Array.from(jr(r)), (i, s) => i.write8(s));
    },
    function(t) {
      let r = t.readVec((i) => i.read8());
      return Nr(new Uint8Array(r));
    }
  ), e.registerType(
    ze.BASE58,
    function(t, r) {
      return t.writeVec(Array.from(wn(r)), (i, s) => i.write8(s));
    },
    function(t) {
      let r = t.readVec((i) => i.read8());
      return xn(new Uint8Array(r));
    }
  ), e.registerType(
    ze.BASE64,
    function(t, r) {
      return t.writeVec(Array.from(Ir(r)), (i, s) => i.write8(s));
    },
    function(t) {
      let r = t.readVec((i) => i.read8());
      return Ur(new Uint8Array(r));
    }
  );
}
function Os() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "Vec",
    addressLength: Pi,
    addressEncoding: "hex"
  };
}
function Ps() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: Pi,
    addressEncoding: "hex"
  };
}
function Ci(e, t = ["<", ">"]) {
  const [r, i] = t, s = [];
  let h = "", u = 0;
  for (let b = 0; b < e.length; b++) {
    const l = e[b];
    if (l === r && u++, l === i && u--, u === 0 && l === ",") {
      s.push(h.trim()), h = "";
      continue;
    }
    h += l;
  }
  return s.push(h.trim()), s;
}
var _n = Object.defineProperty, Is = Object.getOwnPropertyDescriptor, Us = Object.getOwnPropertyNames, js = Object.prototype.hasOwnProperty, Ns = (e, t) => {
  for (var r in t)
    _n(e, r, { get: t[r], enumerable: !0 });
}, $s = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of Us(t))
      !js.call(e, s) && s !== r && _n(e, s, { get: () => t[s], enumerable: !(i = Is(t, s)) || i.enumerable });
  return e;
}, Cs = (e) => $s(_n({}, "__esModule", { value: !0 }), e), Ri = {};
Ns(Ri, {
  bcs: () => mn,
  isPureArg: () => Rs
});
var vn = Cs(Ri), at = Bt;
function Rs(e) {
  return e.Pure !== void 0;
}
const tr = "vector", Ls = {
  kind: "TransactionKind",
  sender: at.BCS.ADDRESS,
  gasData: "GasData",
  expiration: "TransactionExpiration"
}, Ms = {
  enums: {
    "Option<T>": {
      None: null,
      Some: "T"
    },
    ObjectArg: {
      ImmOrOwned: "SuiObjectRef",
      Shared: "SharedObjectRef"
    },
    CallArg: {
      Pure: [tr, at.BCS.U8],
      Object: "ObjectArg",
      ObjVec: [tr, "ObjectArg"]
    },
    TypeTag: {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: "TypeTag",
      struct: "StructTag",
      u16: null,
      u32: null,
      u256: null
    },
    TransactionKind: {
      ProgrammableTransaction: "ProgrammableTransaction",
      ChangeEpoch: null,
      Genesis: null,
      ConsensusCommitPrologue: null
    },
    TransactionExpiration: {
      None: null,
      Epoch: "unsafe_u64"
    },
    TransactionData: {
      V1: "TransactionDataV1"
    }
  },
  structs: {
    SuiObjectRef: {
      objectId: at.BCS.ADDRESS,
      version: at.BCS.U64,
      digest: "ObjectDigest"
    },
    SharedObjectRef: {
      objectId: at.BCS.ADDRESS,
      initialSharedVersion: at.BCS.U64,
      mutable: at.BCS.BOOL
    },
    StructTag: {
      address: at.BCS.ADDRESS,
      module: at.BCS.STRING,
      name: at.BCS.STRING,
      typeParams: [tr, "TypeTag"]
    },
    GasData: {
      payment: [tr, "SuiObjectRef"],
      owner: at.BCS.ADDRESS,
      price: at.BCS.U64,
      budget: at.BCS.U64
    },
    SenderSignedData: {
      data: "TransactionData",
      txSignatures: [tr, [tr, at.BCS.U8]]
    },
    TransactionDataV1: Ls
  },
  aliases: {
    ObjectDigest: at.BCS.BASE58
  }
}, mn = new at.BCS({ ...(0, at.getSuiMoveConfig)(), types: Ms });
mn.registerType(
  "utf8string",
  (e, t) => {
    const r = Array.from(new TextEncoder().encode(t));
    return e.writeVec(r, (i, s) => i.write8(s));
  },
  (e) => {
    let t = e.readVec((r) => r.read8());
    return new TextDecoder().decode(new Uint8Array(t));
  }
);
mn.registerType(
  "unsafe_u64",
  (e, t) => e.write64(t),
  (e) => Number.parseInt(e.read64(), 10)
);
var En = Object.defineProperty, ks = Object.getOwnPropertyDescriptor, Ds = Object.getOwnPropertyNames, Hs = Object.prototype.hasOwnProperty, Ks = (e, t) => {
  for (var r in t)
    En(e, r, { get: t[r], enumerable: !0 });
}, Gs = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of Ds(t))
      !Hs.call(e, s) && s !== r && En(e, s, { get: () => t[s], enumerable: !(i = ks(t, s)) || i.enumerable });
  return e;
}, Vs = (e) => Gs(En({}, "__esModule", { value: !0 }), e), Li = {};
Ks(Li, {
  SUI_ADDRESS_LENGTH: () => Sn,
  isValidSuiAddress: () => ki,
  isValidSuiObjectId: () => Ys,
  isValidTransactionDigest: () => zs,
  normalizeStructTag: () => Di,
  normalizeSuiAddress: () => An,
  normalizeSuiObjectId: () => Zs,
  parseStructTag: () => Bn
});
var $r = Vs(Li), Mi = Bt;
const qs = 32;
function zs(e) {
  try {
    return (0, Mi.fromB58)(e).length === qs;
  } catch {
    return !1;
  }
}
const Sn = 32;
function ki(e) {
  return Fs(e) && Xs(e) === Sn;
}
function Ys(e) {
  return ki(e);
}
function Ws(e) {
  return e.includes("::") ? Bn(e) : e;
}
function Bn(e) {
  const [t, r] = e.split("::"), i = e.slice(t.length + r.length + 4), s = i.includes("<") ? i.slice(0, i.indexOf("<")) : i, h = i.includes("<") ? (0, Mi.splitGenericParameters)(i.slice(i.indexOf("<") + 1, i.lastIndexOf(">"))).map(
    (u) => Ws(u.trim())
  ) : [];
  return {
    address: An(t),
    module: r,
    name: s,
    typeParams: h
  };
}
function Di(e) {
  const { address: t, module: r, name: i, typeParams: s } = typeof e == "string" ? Bn(e) : e, h = s.length > 0 ? `<${s.map(
    (u) => typeof u == "string" ? u : Di(u)
  ).join(",")}>` : "";
  return `${t}::${r}::${i}${h}`;
}
function An(e, t = !1) {
  let r = e.toLowerCase();
  return !t && r.startsWith("0x") && (r = r.slice(2)), `0x${r.padStart(Sn * 2, "0")}`;
}
function Zs(e, t = !1) {
  return An(e, t);
}
function Fs(e) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e) && e.length % 2 === 0;
}
function Xs(e) {
  return /^(0x|0X)/.test(e) ? (e.length - 2) / 2 : e.length / 2;
}
var Tn = Object.defineProperty, Js = Object.getOwnPropertyDescriptor, Qs = Object.getOwnPropertyNames, ef = Object.prototype.hasOwnProperty, tf = (e, t) => {
  for (var r in t)
    Tn(e, r, { get: t[r], enumerable: !0 });
}, rf = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of Qs(t))
      !ef.call(e, s) && s !== r && Tn(e, s, { get: () => t[s], enumerable: !(i = Js(t, s)) || i.enumerable });
  return e;
}, nf = (e) => rf(Tn({}, "__esModule", { value: !0 }), e), Hi = {};
tf(Hi, {
  TypeTagSerializer: () => Xt
});
var of = nf(Hi), sf = Bt, ff = $r;
const af = /^vector<(.+)>$/, cf = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
class Xt {
  static parseFromStr(t, r = !1) {
    if (t === "address")
      return { address: null };
    if (t === "bool")
      return { bool: null };
    if (t === "u8")
      return { u8: null };
    if (t === "u16")
      return { u16: null };
    if (t === "u32")
      return { u32: null };
    if (t === "u64")
      return { u64: null };
    if (t === "u128")
      return { u128: null };
    if (t === "u256")
      return { u256: null };
    if (t === "signer")
      return { signer: null };
    const i = t.match(af);
    if (i)
      return {
        vector: Xt.parseFromStr(i[1], r)
      };
    const s = t.match(cf);
    if (s)
      return {
        struct: {
          address: r ? (0, ff.normalizeSuiAddress)(s[1]) : s[1],
          module: s[2],
          name: s[3],
          typeParams: s[5] === void 0 ? [] : Xt.parseStructTypeArgs(s[5], r)
        }
      };
    throw new Error(`Encountered unexpected token when parsing type args for ${t}`);
  }
  static parseStructTypeArgs(t, r = !1) {
    return (0, sf.splitGenericParameters)(t).map(
      (i) => Xt.parseFromStr(i, r)
    );
  }
  static tagToString(t) {
    if ("bool" in t)
      return "bool";
    if ("u8" in t)
      return "u8";
    if ("u16" in t)
      return "u16";
    if ("u32" in t)
      return "u32";
    if ("u64" in t)
      return "u64";
    if ("u128" in t)
      return "u128";
    if ("u256" in t)
      return "u256";
    if ("address" in t)
      return "address";
    if ("signer" in t)
      return "signer";
    if ("vector" in t)
      return `vector<${Xt.tagToString(t.vector)}>`;
    if ("struct" in t) {
      const r = t.struct, i = r.typeParams.map(Xt.tagToString).join(", ");
      return `${r.address}::${r.module}::${r.name}${i ? `<${i}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
}
var On = Object.defineProperty, uf = Object.getOwnPropertyDescriptor, lf = Object.getOwnPropertyNames, hf = Object.prototype.hasOwnProperty, df = (e, t) => {
  for (var r in t)
    On(e, r, { get: t[r], enumerable: !0 });
}, bf = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of lf(t))
      !hf.call(e, s) && s !== r && On(e, s, { get: () => t[s], enumerable: !(i = uf(t, s)) || i.enumerable });
  return e;
}, yf = (e) => bf(On({}, "__esModule", { value: !0 }), e), Ki = {};
df(Ki, {
  ARGUMENT: () => Nt,
  ARGUMENT_INNER: () => Pn,
  CALL_ARG: () => qi,
  COMPRESSED_SIGNATURE: () => fn,
  ENUM_KIND: () => Cr,
  MULTISIG: () => Yi,
  MULTISIG_PK_MAP: () => un,
  MULTISIG_PUBLIC_KEY: () => cn,
  OBJECT_ARG: () => xf,
  OPTION: () => Vi,
  PROGRAMMABLE_CALL: () => Un,
  PROGRAMMABLE_CALL_INNER: () => Ar,
  PROGRAMMABLE_TX_BLOCK: () => zi,
  PUBLIC_KEY: () => an,
  TRANSACTION: () => Wi,
  TRANSACTION_INNER: () => In,
  TYPE_TAG: () => sn,
  VECTOR: () => ft,
  builder: () => Wt
});
var Gi = yf(Ki), ht = Bt, pf = vn, ri = of, gf = $r;
const Pn = "Argument", ft = "vector", Vi = "Option", qi = "CallArg", sn = "TypeTag", xf = "ObjectArg", zi = "ProgrammableTransaction", Ar = "ProgrammableMoveCall", In = "Transaction", fn = "CompressedSignature", an = "PublicKey", cn = "MultiSigPublicKey", un = "MultiSigPkMap", Yi = "MultiSig", Cr = "EnumKind", Wi = [Cr, In], Nt = [Cr, Pn], Un = "SimpleProgrammableMoveCall", Wt = new ht.BCS(pf.bcs);
jn(Wt, "FixedArray[64]", 64);
jn(Wt, "FixedArray[33]", 33);
jn(Wt, "FixedArray[32]", 32);
Wt.registerStructType(zi, {
  inputs: [ft, qi],
  transactions: [ft, Wi]
}).registerEnumType(Pn, {
  GasCoin: null,
  Input: { index: ht.BCS.U16 },
  Result: { index: ht.BCS.U16 },
  NestedResult: { index: ht.BCS.U16, resultIndex: ht.BCS.U16 }
}).registerStructType(Ar, {
  package: ht.BCS.ADDRESS,
  module: ht.BCS.STRING,
  function: ht.BCS.STRING,
  type_arguments: [ft, sn],
  arguments: [ft, Nt]
}).registerEnumType(In, {
  MoveCall: Un,
  TransferObjects: {
    objects: [ft, Nt],
    address: Nt
  },
  SplitCoins: { coin: Nt, amounts: [ft, Nt] },
  MergeCoins: { destination: Nt, sources: [ft, Nt] },
  Publish: {
    modules: [ft, [ft, ht.BCS.U8]],
    dependencies: [ft, ht.BCS.ADDRESS]
  },
  MakeMoveVec: {
    type: [Vi, sn],
    objects: [ft, Nt]
  },
  Upgrade: {
    modules: [ft, [ft, ht.BCS.U8]],
    dependencies: [ft, ht.BCS.ADDRESS],
    packageId: ht.BCS.ADDRESS,
    ticket: Nt
  }
}).registerEnumType(fn, {
  ED25519: ["FixedArray[64]", "u8"],
  Secp256k1: ["FixedArray[64]", "u8"],
  Secp256r1: ["FixedArray[64]", "u8"]
}).registerEnumType(an, {
  ED25519: ["FixedArray[32]", "u8"],
  Secp256k1: ["FixedArray[33]", "u8"],
  Secp256r1: ["FixedArray[33]", "u8"]
}).registerStructType(un, {
  pubKey: an,
  weight: ht.BCS.U8
}).registerStructType(cn, {
  pk_map: [ft, un],
  threshold: ht.BCS.U16
}).registerStructType(Yi, {
  sigs: [ft, fn],
  bitmap: ht.BCS.U16,
  multisig_pk: cn
});
Wt.registerType(
  [Cr, "T"],
  function(t, r, i, s) {
    const u = { [r.kind]: r }, [b] = i;
    return this.getTypeInterface(b)._encodeRaw.call(
      this,
      t,
      u,
      i,
      s
    );
  },
  function(t, r, i) {
    const [s] = r, h = this.getTypeInterface(s)._decodeRaw.call(
      this,
      t,
      r,
      i
    ), u = Object.keys(h)[0];
    return { kind: u, ...h[u] };
  },
  (e) => {
    if (typeof e != "object" && !("kind" in e))
      throw new Error(`EnumKind: Missing property "kind" in the input ${JSON.stringify(e)}`);
    return !0;
  }
);
Wt.registerType(
  Un,
  function(t, r, i, s) {
    const [h, u, b] = r.target.split("::"), l = r.typeArguments.map(
      (p) => ri.TypeTagSerializer.parseFromStr(p, !0)
    );
    return this.getTypeInterface(Ar)._encodeRaw.call(
      this,
      t,
      {
        package: (0, gf.normalizeSuiAddress)(h),
        module: u,
        function: b,
        type_arguments: l,
        arguments: r.arguments
      },
      i,
      s
    );
  },
  function(t, r, i) {
    let s = Wt.getTypeInterface(Ar)._decodeRaw.call(this, t, r, i);
    return {
      target: [s.package, s.module, s.function].join("::"),
      arguments: s.arguments,
      typeArguments: s.type_arguments.map(ri.TypeTagSerializer.tagToString)
    };
  },
  (e) => e.target.split("::").length === 3
);
function jn(e, t, r) {
  e.registerType(
    t,
    function(s, h, u, b) {
      if (h.length !== r)
        throw new Error(`Expected fixed array of length ${r}, got ${h.length}`);
      if (u.length !== 1)
        throw new Error(`Expected one type parameter in a fixed array, got ${u.length}`);
      let [l] = typeof u[0] == "string" ? [u[0], []] : u[0];
      for (let p of h)
        this.getTypeInterface(l)._encodeRaw.call(this, s, p, u, b);
      return s;
    },
    function(s, h, u) {
      if (h.length !== 1)
        throw new Error(`Expected one type parameter in a fixed array, got ${h.length}`);
      let b = [], [l] = typeof h[0] == "string" ? [h[0], []] : h[0];
      for (let p = 0; p < r; p++)
        b.push(this.getTypeInterface(l)._decodeRaw.call(this, s, h, u));
      return b;
    }
  );
}
var Nn = Object.defineProperty, wf = Object.getOwnPropertyDescriptor, _f = Object.getOwnPropertyNames, vf = Object.prototype.hasOwnProperty, mf = (e, t) => {
  for (var r in t)
    Nn(e, r, { get: t[r], enumerable: !0 });
}, Ef = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of _f(t))
      !vf.call(e, s) && s !== r && Nn(e, s, { get: () => t[s], enumerable: !(i = wf(t, s)) || i.enumerable });
  return e;
}, Sf = (e) => Ef(Nn({}, "__esModule", { value: !0 }), e), Zi = {};
mf(Zi, {
  SIGNATURE_FLAG_TO_SCHEME: () => Ji,
  SIGNATURE_SCHEME_TO_FLAG: () => Xi,
  SIGNATURE_SCHEME_TO_SIZE: () => ln,
  parseSerializedSignature: () => Tf,
  toSerializedSignature: () => Af
});
var ar = Sf(Zi), Fi = Bt, Bf = Gi;
const Xi = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  Zk: 5
}, ln = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
}, Ji = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "Zk"
};
function Af({
  signature: e,
  signatureScheme: t,
  pubKey: r,
  publicKey: i = r
}) {
  if (!i)
    throw new Error("`publicKey` is required");
  const s = i.toBytes(), h = new Uint8Array(1 + e.length + s.length);
  return h.set([Xi[t]]), h.set(e, 1), h.set(s, 1 + e.length), (0, Fi.toB64)(h);
}
function Tf(e) {
  const t = (0, Fi.fromB64)(e), r = Ji[t[0]];
  if (r === "MultiSig") {
    const u = Bf.builder.de("MultiSig", t.slice(1));
    return {
      serializedSignature: e,
      signatureScheme: r,
      multisig: u,
      bytes: t
    };
  }
  if (r === "Zk")
    throw new Error("Unable to parse a zk signature. (not implemented yet)");
  if (!(r in ln))
    throw new Error("Unsupported signature scheme");
  const i = ln[r], s = t.slice(1, t.length - i), h = t.slice(1 + s.length);
  return {
    serializedSignature: e,
    signatureScheme: r,
    signature: s,
    publicKey: h,
    bytes: t
  };
}
var yt = {}, ot = {};
Object.defineProperty(ot, "__esModule", { value: !0 });
ot.output = ot.exists = ot.hash = ot.bytes = ot.bool = ot.number = void 0;
function Tr(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
ot.number = Tr;
function Qi(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
ot.bool = Qi;
function $n(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
ot.bytes = $n;
function eo(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Tr(e.outputLen), Tr(e.blockLen);
}
ot.hash = eo;
function to(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
ot.exists = to;
function ro(e, t) {
  $n(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
ot.output = ro;
const Of = {
  number: Tr,
  bool: Qi,
  bytes: $n,
  hash: eo,
  exists: to,
  output: ro
};
ot.default = Of;
var or = {}, Cn = {}, xt = {}, Rr = {};
Object.defineProperty(Rr, "__esModule", { value: !0 });
Rr.crypto = void 0;
Rr.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
  const t = Rr, r = (S) => S instanceof Uint8Array, i = (S) => new Uint8Array(S.buffer, S.byteOffset, S.byteLength);
  e.u8 = i;
  const s = (S) => new Uint32Array(S.buffer, S.byteOffset, Math.floor(S.byteLength / 4));
  e.u32 = s;
  const h = (S) => new DataView(S.buffer, S.byteOffset, S.byteLength);
  e.createView = h;
  const u = (S, j) => S << 32 - j | S >>> j;
  if (e.rotr = u, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !e.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const b = Array.from({ length: 256 }, (S, j) => j.toString(16).padStart(2, "0"));
  function l(S) {
    if (!r(S))
      throw new Error("Uint8Array expected");
    let j = "";
    for (let W = 0; W < S.length; W++)
      j += b[S[W]];
    return j;
  }
  e.bytesToHex = l;
  function p(S) {
    if (typeof S != "string")
      throw new Error("hex string expected, got " + typeof S);
    const j = S.length;
    if (j % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + j);
    const W = new Uint8Array(j / 2);
    for (let X = 0; X < W.length; X++) {
      const H = X * 2, g = S.slice(H, H + 2), x = Number.parseInt(g, 16);
      if (Number.isNaN(x) || x < 0)
        throw new Error("Invalid byte sequence");
      W[X] = x;
    }
    return W;
  }
  e.hexToBytes = p;
  const B = async () => {
  };
  e.nextTick = B;
  async function w(S, j, W) {
    let X = Date.now();
    for (let H = 0; H < S; H++) {
      W(H);
      const g = Date.now() - X;
      g >= 0 && g < j || (await (0, e.nextTick)(), X += g);
    }
  }
  e.asyncLoop = w;
  function O(S) {
    if (typeof S != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof S}`);
    return new Uint8Array(new TextEncoder().encode(S));
  }
  e.utf8ToBytes = O;
  function U(S) {
    if (typeof S == "string" && (S = O(S)), !r(S))
      throw new Error(`expected Uint8Array, got ${typeof S}`);
    return S;
  }
  e.toBytes = U;
  function $(...S) {
    const j = new Uint8Array(S.reduce((X, H) => X + H.length, 0));
    let W = 0;
    return S.forEach((X) => {
      if (!r(X))
        throw new Error("Uint8Array expected");
      j.set(X, W), W += X.length;
    }), j;
  }
  e.concatBytes = $;
  class D {
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = D;
  const Z = (S) => Object.prototype.toString.call(S) === "[object Object]" && S.constructor === Object;
  function pe(S, j) {
    if (j !== void 0 && (typeof j != "object" || !Z(j)))
      throw new Error("Options should be object or undefined");
    return Object.assign(S, j);
  }
  e.checkOpts = pe;
  function v(S) {
    const j = (X) => S().update(U(X)).digest(), W = S();
    return j.outputLen = W.outputLen, j.blockLen = W.blockLen, j.create = () => S(), j;
  }
  e.wrapConstructor = v;
  function m(S) {
    const j = (X, H) => S(H).update(U(X)).digest(), W = S({});
    return j.outputLen = W.outputLen, j.blockLen = W.blockLen, j.create = (X) => S(X), j;
  }
  e.wrapConstructorWithOpts = m;
  function d(S) {
    const j = (X, H) => S(H).update(U(X)).digest(), W = S({});
    return j.outputLen = W.outputLen, j.blockLen = W.blockLen, j.create = (X) => S(X), j;
  }
  e.wrapXOFConstructorWithOpts = d;
  function V(S = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(S));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = V;
})(xt);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = ot, r = xt;
  class i extends r.Hash {
    constructor(u, b) {
      super(), this.finished = !1, this.destroyed = !1, t.default.hash(u);
      const l = (0, r.toBytes)(b);
      if (this.iHash = u.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const p = this.blockLen, B = new Uint8Array(p);
      B.set(l.length > p ? u.create().update(l).digest() : l);
      for (let w = 0; w < B.length; w++)
        B[w] ^= 54;
      this.iHash.update(B), this.oHash = u.create();
      for (let w = 0; w < B.length; w++)
        B[w] ^= 106;
      this.oHash.update(B), B.fill(0);
    }
    update(u) {
      return t.default.exists(this), this.iHash.update(u), this;
    }
    digestInto(u) {
      t.default.exists(this), t.default.bytes(u, this.outputLen), this.finished = !0, this.iHash.digestInto(u), this.oHash.update(u), this.oHash.digestInto(u), this.destroy();
    }
    digest() {
      const u = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(u), u;
    }
    _cloneInto(u) {
      u || (u = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: b, iHash: l, finished: p, destroyed: B, blockLen: w, outputLen: O } = this;
      return u = u, u.finished = p, u.destroyed = B, u.blockLen = w, u.outputLen = O, u.oHash = b._cloneInto(u.oHash), u.iHash = l._cloneInto(u.iHash), u;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = i;
  const s = (h, u, b) => new i(h, u).update(b).digest();
  e.hmac = s, e.hmac.create = (h, u) => new i(h, u);
})(Cn);
Object.defineProperty(or, "__esModule", { value: !0 });
or.pbkdf2Async = or.pbkdf2 = void 0;
const Er = ot, Pf = Cn, ir = xt;
function no(e, t, r, i) {
  Er.default.hash(e);
  const s = (0, ir.checkOpts)({ dkLen: 32, asyncTick: 10 }, i), { c: h, dkLen: u, asyncTick: b } = s;
  if (Er.default.number(h), Er.default.number(u), Er.default.number(b), h < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const l = (0, ir.toBytes)(t), p = (0, ir.toBytes)(r), B = new Uint8Array(u), w = Pf.hmac.create(e, l), O = w._cloneInto().update(p);
  return { c: h, dkLen: u, asyncTick: b, DK: B, PRF: w, PRFSalt: O };
}
function io(e, t, r, i, s) {
  return e.destroy(), t.destroy(), i && i.destroy(), s.fill(0), r;
}
function If(e, t, r, i) {
  const { c: s, dkLen: h, DK: u, PRF: b, PRFSalt: l } = no(e, t, r, i);
  let p;
  const B = new Uint8Array(4), w = (0, ir.createView)(B), O = new Uint8Array(b.outputLen);
  for (let U = 1, $ = 0; $ < h; U++, $ += b.outputLen) {
    const D = u.subarray($, $ + b.outputLen);
    w.setInt32(0, U, !1), (p = l._cloneInto(p)).update(B).digestInto(O), D.set(O.subarray(0, D.length));
    for (let Z = 1; Z < s; Z++) {
      b._cloneInto(p).update(O).digestInto(O);
      for (let pe = 0; pe < D.length; pe++)
        D[pe] ^= O[pe];
    }
  }
  return io(b, l, u, p, O);
}
or.pbkdf2 = If;
async function Uf(e, t, r, i) {
  const { c: s, dkLen: h, asyncTick: u, DK: b, PRF: l, PRFSalt: p } = no(e, t, r, i);
  let B;
  const w = new Uint8Array(4), O = (0, ir.createView)(w), U = new Uint8Array(l.outputLen);
  for (let $ = 1, D = 0; D < h; $++, D += l.outputLen) {
    const Z = b.subarray(D, D + l.outputLen);
    O.setInt32(0, $, !1), (B = p._cloneInto(B)).update(w).digestInto(U), Z.set(U.subarray(0, Z.length)), await (0, ir.asyncLoop)(s - 1, u, (pe) => {
      l._cloneInto(B).update(U).digestInto(U);
      for (let v = 0; v < Z.length; v++)
        Z[v] ^= U[v];
    });
  }
  return io(l, p, b, B, U);
}
or.pbkdf2Async = Uf;
var $t = {}, xr = {};
Object.defineProperty(xr, "__esModule", { value: !0 });
xr.SHA2 = void 0;
const Xr = ot, br = xt;
function jf(e, t, r, i) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, i);
  const s = BigInt(32), h = BigInt(4294967295), u = Number(r >> s & h), b = Number(r & h), l = i ? 4 : 0, p = i ? 0 : 4;
  e.setUint32(t + l, u, i), e.setUint32(t + p, b, i);
}
class Nf extends br.Hash {
  constructor(t, r, i, s) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = i, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, br.createView)(this.buffer);
  }
  update(t) {
    Xr.default.exists(this);
    const { view: r, buffer: i, blockLen: s } = this;
    t = (0, br.toBytes)(t);
    const h = t.length;
    for (let u = 0; u < h; ) {
      const b = Math.min(s - this.pos, h - u);
      if (b === s) {
        const l = (0, br.createView)(t);
        for (; s <= h - u; u += s)
          this.process(l, u);
        continue;
      }
      i.set(t.subarray(u, u + b), this.pos), this.pos += b, u += b, this.pos === s && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Xr.default.exists(this), Xr.default.output(t, this), this.finished = !0;
    const { buffer: r, view: i, blockLen: s, isLE: h } = this;
    let { pos: u } = this;
    r[u++] = 128, this.buffer.subarray(u).fill(0), this.padOffset > s - u && (this.process(i, 0), u = 0);
    for (let w = u; w < s; w++)
      r[w] = 0;
    jf(i, s - 8, BigInt(this.length * 8), h), this.process(i, 0);
    const b = (0, br.createView)(t), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const p = l / 4, B = this.get();
    if (p > B.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < p; w++)
      b.setUint32(4 * w, B[w], h);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const i = t.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: i, length: s, finished: h, destroyed: u, pos: b } = this;
    return t.length = s, t.pos = b, t.finished = h, t.destroyed = u, s % r && t.buffer.set(i), t;
  }
}
xr.SHA2 = Nf;
Object.defineProperty($t, "__esModule", { value: !0 });
$t.sha224 = $t.sha256 = void 0;
const $f = xr, mt = xt, Cf = (e, t, r) => e & t ^ ~e & r, Rf = (e, t, r) => e & t ^ e & r ^ t & r, Lf = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Dt = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Ht = new Uint32Array(64);
class oo extends $f.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = Dt[0] | 0, this.B = Dt[1] | 0, this.C = Dt[2] | 0, this.D = Dt[3] | 0, this.E = Dt[4] | 0, this.F = Dt[5] | 0, this.G = Dt[6] | 0, this.H = Dt[7] | 0;
  }
  get() {
    const { A: t, B: r, C: i, D: s, E: h, F: u, G: b, H: l } = this;
    return [t, r, i, s, h, u, b, l];
  }
  set(t, r, i, s, h, u, b, l) {
    this.A = t | 0, this.B = r | 0, this.C = i | 0, this.D = s | 0, this.E = h | 0, this.F = u | 0, this.G = b | 0, this.H = l | 0;
  }
  process(t, r) {
    for (let w = 0; w < 16; w++, r += 4)
      Ht[w] = t.getUint32(r, !1);
    for (let w = 16; w < 64; w++) {
      const O = Ht[w - 15], U = Ht[w - 2], $ = (0, mt.rotr)(O, 7) ^ (0, mt.rotr)(O, 18) ^ O >>> 3, D = (0, mt.rotr)(U, 17) ^ (0, mt.rotr)(U, 19) ^ U >>> 10;
      Ht[w] = D + Ht[w - 7] + $ + Ht[w - 16] | 0;
    }
    let { A: i, B: s, C: h, D: u, E: b, F: l, G: p, H: B } = this;
    for (let w = 0; w < 64; w++) {
      const O = (0, mt.rotr)(b, 6) ^ (0, mt.rotr)(b, 11) ^ (0, mt.rotr)(b, 25), U = B + O + Cf(b, l, p) + Lf[w] + Ht[w] | 0, D = ((0, mt.rotr)(i, 2) ^ (0, mt.rotr)(i, 13) ^ (0, mt.rotr)(i, 22)) + Rf(i, s, h) | 0;
      B = p, p = l, l = b, b = u + U | 0, u = h, h = s, s = i, i = U + D | 0;
    }
    i = i + this.A | 0, s = s + this.B | 0, h = h + this.C | 0, u = u + this.D | 0, b = b + this.E | 0, l = l + this.F | 0, p = p + this.G | 0, B = B + this.H | 0, this.set(i, s, h, u, b, l, p, B);
  }
  roundClean() {
    Ht.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class Mf extends oo {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
$t.sha256 = (0, mt.wrapConstructor)(() => new oo());
$t.sha224 = (0, mt.wrapConstructor)(() => new Mf());
var St = {}, Rn = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.add = e.toBig = e.split = e.fromBig = void 0;
  const t = BigInt(2 ** 32 - 1), r = BigInt(32);
  function i(H, g = !1) {
    return g ? { h: Number(H & t), l: Number(H >> r & t) } : { h: Number(H >> r & t) | 0, l: Number(H & t) | 0 };
  }
  e.fromBig = i;
  function s(H, g = !1) {
    let x = new Uint32Array(H.length), A = new Uint32Array(H.length);
    for (let Q = 0; Q < H.length; Q++) {
      const { h: J, l: K } = i(H[Q], g);
      [x[Q], A[Q]] = [J, K];
    }
    return [x, A];
  }
  e.split = s;
  const h = (H, g) => BigInt(H >>> 0) << r | BigInt(g >>> 0);
  e.toBig = h;
  const u = (H, g, x) => H >>> x, b = (H, g, x) => H << 32 - x | g >>> x, l = (H, g, x) => H >>> x | g << 32 - x, p = (H, g, x) => H << 32 - x | g >>> x, B = (H, g, x) => H << 64 - x | g >>> x - 32, w = (H, g, x) => H >>> x - 32 | g << 64 - x, O = (H, g) => g, U = (H, g) => H, $ = (H, g, x) => H << x | g >>> 32 - x, D = (H, g, x) => g << x | H >>> 32 - x, Z = (H, g, x) => g << x - 32 | H >>> 64 - x, pe = (H, g, x) => H << x - 32 | g >>> 64 - x;
  function v(H, g, x, A) {
    const Q = (g >>> 0) + (A >>> 0);
    return { h: H + x + (Q / 2 ** 32 | 0) | 0, l: Q | 0 };
  }
  e.add = v;
  const m = (H, g, x) => (H >>> 0) + (g >>> 0) + (x >>> 0), d = (H, g, x, A) => g + x + A + (H / 2 ** 32 | 0) | 0, V = (H, g, x, A) => (H >>> 0) + (g >>> 0) + (x >>> 0) + (A >>> 0), S = (H, g, x, A, Q) => g + x + A + Q + (H / 2 ** 32 | 0) | 0, j = (H, g, x, A, Q) => (H >>> 0) + (g >>> 0) + (x >>> 0) + (A >>> 0) + (Q >>> 0), W = (H, g, x, A, Q, J) => g + x + A + Q + J + (H / 2 ** 32 | 0) | 0, X = {
    fromBig: i,
    split: s,
    toBig: e.toBig,
    shrSH: u,
    shrSL: b,
    rotrSH: l,
    rotrSL: p,
    rotrBH: B,
    rotrBL: w,
    rotr32H: O,
    rotr32L: U,
    rotlSH: $,
    rotlSL: D,
    rotlBH: Z,
    rotlBL: pe,
    add: v,
    add3L: m,
    add3H: d,
    add4L: V,
    add4H: S,
    add5H: W,
    add5L: j
  };
  e.default = X;
})(Rn);
Object.defineProperty(St, "__esModule", { value: !0 });
St.sha384 = St.sha512_256 = St.sha512_224 = St.sha512 = St.SHA512 = void 0;
const kf = xr, Ne = Rn, Lr = xt, [Df, Hf] = Ne.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), Kt = new Uint32Array(80), Gt = new Uint32Array(80);
class wr extends kf.SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: t, Al: r, Bh: i, Bl: s, Ch: h, Cl: u, Dh: b, Dl: l, Eh: p, El: B, Fh: w, Fl: O, Gh: U, Gl: $, Hh: D, Hl: Z } = this;
    return [t, r, i, s, h, u, b, l, p, B, w, O, U, $, D, Z];
  }
  set(t, r, i, s, h, u, b, l, p, B, w, O, U, $, D, Z) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = i | 0, this.Bl = s | 0, this.Ch = h | 0, this.Cl = u | 0, this.Dh = b | 0, this.Dl = l | 0, this.Eh = p | 0, this.El = B | 0, this.Fh = w | 0, this.Fl = O | 0, this.Gh = U | 0, this.Gl = $ | 0, this.Hh = D | 0, this.Hl = Z | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4)
      Kt[m] = t.getUint32(r), Gt[m] = t.getUint32(r += 4);
    for (let m = 16; m < 80; m++) {
      const d = Kt[m - 15] | 0, V = Gt[m - 15] | 0, S = Ne.default.rotrSH(d, V, 1) ^ Ne.default.rotrSH(d, V, 8) ^ Ne.default.shrSH(d, V, 7), j = Ne.default.rotrSL(d, V, 1) ^ Ne.default.rotrSL(d, V, 8) ^ Ne.default.shrSL(d, V, 7), W = Kt[m - 2] | 0, X = Gt[m - 2] | 0, H = Ne.default.rotrSH(W, X, 19) ^ Ne.default.rotrBH(W, X, 61) ^ Ne.default.shrSH(W, X, 6), g = Ne.default.rotrSL(W, X, 19) ^ Ne.default.rotrBL(W, X, 61) ^ Ne.default.shrSL(W, X, 6), x = Ne.default.add4L(j, g, Gt[m - 7], Gt[m - 16]), A = Ne.default.add4H(x, S, H, Kt[m - 7], Kt[m - 16]);
      Kt[m] = A | 0, Gt[m] = x | 0;
    }
    let { Ah: i, Al: s, Bh: h, Bl: u, Ch: b, Cl: l, Dh: p, Dl: B, Eh: w, El: O, Fh: U, Fl: $, Gh: D, Gl: Z, Hh: pe, Hl: v } = this;
    for (let m = 0; m < 80; m++) {
      const d = Ne.default.rotrSH(w, O, 14) ^ Ne.default.rotrSH(w, O, 18) ^ Ne.default.rotrBH(w, O, 41), V = Ne.default.rotrSL(w, O, 14) ^ Ne.default.rotrSL(w, O, 18) ^ Ne.default.rotrBL(w, O, 41), S = w & U ^ ~w & D, j = O & $ ^ ~O & Z, W = Ne.default.add5L(v, V, j, Hf[m], Gt[m]), X = Ne.default.add5H(W, pe, d, S, Df[m], Kt[m]), H = W | 0, g = Ne.default.rotrSH(i, s, 28) ^ Ne.default.rotrBH(i, s, 34) ^ Ne.default.rotrBH(i, s, 39), x = Ne.default.rotrSL(i, s, 28) ^ Ne.default.rotrBL(i, s, 34) ^ Ne.default.rotrBL(i, s, 39), A = i & h ^ i & b ^ h & b, Q = s & u ^ s & l ^ u & l;
      pe = D | 0, v = Z | 0, D = U | 0, Z = $ | 0, U = w | 0, $ = O | 0, { h: w, l: O } = Ne.default.add(p | 0, B | 0, X | 0, H | 0), p = b | 0, B = l | 0, b = h | 0, l = u | 0, h = i | 0, u = s | 0;
      const J = Ne.default.add3L(H, x, Q);
      i = Ne.default.add3H(J, X, g, A), s = J | 0;
    }
    ({ h: i, l: s } = Ne.default.add(this.Ah | 0, this.Al | 0, i | 0, s | 0)), { h, l: u } = Ne.default.add(this.Bh | 0, this.Bl | 0, h | 0, u | 0), { h: b, l } = Ne.default.add(this.Ch | 0, this.Cl | 0, b | 0, l | 0), { h: p, l: B } = Ne.default.add(this.Dh | 0, this.Dl | 0, p | 0, B | 0), { h: w, l: O } = Ne.default.add(this.Eh | 0, this.El | 0, w | 0, O | 0), { h: U, l: $ } = Ne.default.add(this.Fh | 0, this.Fl | 0, U | 0, $ | 0), { h: D, l: Z } = Ne.default.add(this.Gh | 0, this.Gl | 0, D | 0, Z | 0), { h: pe, l: v } = Ne.default.add(this.Hh | 0, this.Hl | 0, pe | 0, v | 0), this.set(i, s, h, u, b, l, p, B, w, O, U, $, D, Z, pe, v);
  }
  roundClean() {
    Kt.fill(0), Gt.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
St.SHA512 = wr;
class Kf extends wr {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
class Gf extends wr {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class Vf extends wr {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
St.sha512 = (0, Lr.wrapConstructor)(() => new wr());
St.sha512_224 = (0, Lr.wrapConstructor)(() => new Kf());
St.sha512_256 = (0, Lr.wrapConstructor)(() => new Gf());
St.sha384 = (0, Lr.wrapConstructor)(() => new Vf());
var so = {};
(function(e) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64url = e.base64 = e.base32crockford = e.base32hex = e.base32 = e.base16 = e.utils = e.assertNumber = void 0;
  function t(g) {
    if (!Number.isSafeInteger(g))
      throw new Error(`Wrong integer: ${g}`);
  }
  e.assertNumber = t;
  function r(...g) {
    const x = (J, K) => (N) => J(K(N)), A = Array.from(g).reverse().reduce((J, K) => J ? x(J, K.encode) : K.encode, void 0), Q = g.reduce((J, K) => J ? x(J, K.decode) : K.decode, void 0);
    return { encode: A, decode: Q };
  }
  function i(g) {
    return {
      encode: (x) => {
        if (!Array.isArray(x) || x.length && typeof x[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return x.map((A) => {
          if (t(A), A < 0 || A >= g.length)
            throw new Error(`Digit index outside alphabet: ${A} (alphabet: ${g.length})`);
          return g[A];
        });
      },
      decode: (x) => {
        if (!Array.isArray(x) || x.length && typeof x[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return x.map((A) => {
          if (typeof A != "string")
            throw new Error(`alphabet.decode: not string element=${A}`);
          const Q = g.indexOf(A);
          if (Q === -1)
            throw new Error(`Unknown letter: "${A}". Allowed: ${g}`);
          return Q;
        });
      }
    };
  }
  function s(g = "") {
    if (typeof g != "string")
      throw new Error("join separator should be string");
    return {
      encode: (x) => {
        if (!Array.isArray(x) || x.length && typeof x[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let A of x)
          if (typeof A != "string")
            throw new Error(`join.encode: non-string input=${A}`);
        return x.join(g);
      },
      decode: (x) => {
        if (typeof x != "string")
          throw new Error("join.decode input should be string");
        return x.split(g);
      }
    };
  }
  function h(g, x = "=") {
    if (t(g), typeof x != "string")
      throw new Error("padding chr should be string");
    return {
      encode(A) {
        if (!Array.isArray(A) || A.length && typeof A[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let Q of A)
          if (typeof Q != "string")
            throw new Error(`padding.encode: non-string input=${Q}`);
        for (; A.length * g % 8; )
          A.push(x);
        return A;
      },
      decode(A) {
        if (!Array.isArray(A) || A.length && typeof A[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let J of A)
          if (typeof J != "string")
            throw new Error(`padding.decode: non-string input=${J}`);
        let Q = A.length;
        if (Q * g % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; Q > 0 && A[Q - 1] === x; Q--)
          if (!((Q - 1) * g % 8))
            throw new Error("Invalid padding: string has too much padding");
        return A.slice(0, Q);
      }
    };
  }
  function u(g) {
    if (typeof g != "function")
      throw new Error("normalize fn should be function");
    return { encode: (x) => x, decode: (x) => g(x) };
  }
  function b(g, x, A) {
    if (x < 2)
      throw new Error(`convertRadix: wrong from=${x}, base cannot be less than 2`);
    if (A < 2)
      throw new Error(`convertRadix: wrong to=${A}, base cannot be less than 2`);
    if (!Array.isArray(g))
      throw new Error("convertRadix: data should be array");
    if (!g.length)
      return [];
    let Q = 0;
    const J = [], K = Array.from(g);
    for (K.forEach((N) => {
      if (t(N), N < 0 || N >= x)
        throw new Error(`Wrong integer: ${N}`);
    }); ; ) {
      let N = 0, F = !0;
      for (let T = Q; T < K.length; T++) {
        const C = K[T], k = x * N + C;
        if (!Number.isSafeInteger(k) || x * N / x !== N || k - C !== x * N)
          throw new Error("convertRadix: carry overflow");
        if (N = k % A, K[T] = Math.floor(k / A), !Number.isSafeInteger(K[T]) || K[T] * A + N !== k)
          throw new Error("convertRadix: carry overflow");
        if (F)
          K[T] ? F = !1 : Q = T;
        else
          continue;
      }
      if (J.push(N), F)
        break;
    }
    for (let N = 0; N < g.length - 1 && g[N] === 0; N++)
      J.push(0);
    return J.reverse();
  }
  const l = (g, x) => x ? l(x, g % x) : g, p = (g, x) => g + (x - l(g, x));
  function B(g, x, A, Q) {
    if (!Array.isArray(g))
      throw new Error("convertRadix2: data should be array");
    if (x <= 0 || x > 32)
      throw new Error(`convertRadix2: wrong from=${x}`);
    if (A <= 0 || A > 32)
      throw new Error(`convertRadix2: wrong to=${A}`);
    if (p(x, A) > 32)
      throw new Error(`convertRadix2: carry overflow from=${x} to=${A} carryBits=${p(x, A)}`);
    let J = 0, K = 0;
    const N = 2 ** A - 1, F = [];
    for (const T of g) {
      if (t(T), T >= 2 ** x)
        throw new Error(`convertRadix2: invalid data word=${T} from=${x}`);
      if (J = J << x | T, K + x > 32)
        throw new Error(`convertRadix2: carry overflow pos=${K} from=${x}`);
      for (K += x; K >= A; K -= A)
        F.push((J >> K - A & N) >>> 0);
      J &= 2 ** K - 1;
    }
    if (J = J << A - K & N, !Q && K >= x)
      throw new Error("Excess padding");
    if (!Q && J)
      throw new Error(`Non-zero padding: ${J}`);
    return Q && K > 0 && F.push(J >>> 0), F;
  }
  function w(g) {
    return t(g), {
      encode: (x) => {
        if (!(x instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return b(Array.from(x), 2 ** 8, g);
      },
      decode: (x) => {
        if (!Array.isArray(x) || x.length && typeof x[0] != "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(b(x, g, 2 ** 8));
      }
    };
  }
  function O(g, x = !1) {
    if (t(g), g <= 0 || g > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (p(8, g) > 32 || p(g, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (A) => {
        if (!(A instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return B(Array.from(A), 8, g, !x);
      },
      decode: (A) => {
        if (!Array.isArray(A) || A.length && typeof A[0] != "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(B(A, g, 8, x));
      }
    };
  }
  function U(g) {
    if (typeof g != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...x) {
      try {
        return g.apply(null, x);
      } catch {
      }
    };
  }
  function $(g, x) {
    if (t(g), typeof x != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(A) {
        if (!(A instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const Q = x(A).slice(0, g), J = new Uint8Array(A.length + g);
        return J.set(A), J.set(Q, A.length), J;
      },
      decode(A) {
        if (!(A instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const Q = A.slice(0, -g), J = x(Q).slice(0, g), K = A.slice(-g);
        for (let N = 0; N < g; N++)
          if (J[N] !== K[N])
            throw new Error("Invalid checksum");
        return Q;
      }
    };
  }
  e.utils = { alphabet: i, chain: r, checksum: $, radix: w, radix2: O, join: s, padding: h }, e.base16 = r(O(4), i("0123456789ABCDEF"), s("")), e.base32 = r(O(5), i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), h(5), s("")), e.base32hex = r(O(5), i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), h(5), s("")), e.base32crockford = r(O(5), i("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), s(""), u((g) => g.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), e.base64 = r(O(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), h(6), s("")), e.base64url = r(O(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), h(6), s(""));
  const D = (g) => r(w(58), i(g), s(""));
  e.base58 = D("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = D("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = D("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const Z = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  e.base58xmr = {
    encode(g) {
      let x = "";
      for (let A = 0; A < g.length; A += 8) {
        const Q = g.subarray(A, A + 8);
        x += e.base58.encode(Q).padStart(Z[Q.length], "1");
      }
      return x;
    },
    decode(g) {
      let x = [];
      for (let A = 0; A < g.length; A += 11) {
        const Q = g.slice(A, A + 11), J = Z.indexOf(Q.length), K = e.base58.decode(Q);
        for (let N = 0; N < K.length - J; N++)
          if (K[N] !== 0)
            throw new Error("base58xmr: wrong padding");
        x = x.concat(Array.from(K.slice(K.length - J)));
      }
      return Uint8Array.from(x);
    }
  };
  const pe = (g) => r($(4, (x) => g(g(x))), e.base58);
  e.base58check = pe;
  const v = r(i("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), s("")), m = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function d(g) {
    const x = g >> 25;
    let A = (g & 33554431) << 5;
    for (let Q = 0; Q < m.length; Q++)
      (x >> Q & 1) === 1 && (A ^= m[Q]);
    return A;
  }
  function V(g, x, A = 1) {
    const Q = g.length;
    let J = 1;
    for (let K = 0; K < Q; K++) {
      const N = g.charCodeAt(K);
      if (N < 33 || N > 126)
        throw new Error(`Invalid prefix (${g})`);
      J = d(J) ^ N >> 5;
    }
    J = d(J);
    for (let K = 0; K < Q; K++)
      J = d(J) ^ g.charCodeAt(K) & 31;
    for (let K of x)
      J = d(J) ^ K;
    for (let K = 0; K < 6; K++)
      J = d(J);
    return J ^= A, v.encode(B([J % 2 ** 30], 30, 5, !1));
  }
  function S(g) {
    const x = g === "bech32" ? 1 : 734539939, A = O(5), Q = A.decode, J = A.encode, K = U(Q);
    function N(k, re, ne = 90) {
      if (typeof k != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof k}`);
      if (!Array.isArray(re) || re.length && typeof re[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof re}`);
      const ee = k.length + 7 + re.length;
      if (ne !== !1 && ee > ne)
        throw new TypeError(`Length ${ee} exceeds limit ${ne}`);
      return k = k.toLowerCase(), `${k}1${v.encode(re)}${V(k, re, x)}`;
    }
    function F(k, re = 90) {
      if (typeof k != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof k}`);
      if (k.length < 8 || re !== !1 && k.length > re)
        throw new TypeError(`Wrong string length: ${k.length} (${k}). Expected (8..${re})`);
      const ne = k.toLowerCase();
      if (k !== ne && k !== k.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      k = ne;
      const ee = k.lastIndexOf("1");
      if (ee === 0 || ee === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const q = k.slice(0, ee), fe = k.slice(ee + 1);
      if (fe.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const Ke = v.decode(fe).slice(0, -6), _e = V(q, Ke, x);
      if (!fe.endsWith(_e))
        throw new Error(`Invalid checksum in ${k}: expected "${_e}"`);
      return { prefix: q, words: Ke };
    }
    const T = U(F);
    function C(k) {
      const { prefix: re, words: ne } = F(k, !1);
      return { prefix: re, words: ne, bytes: Q(ne) };
    }
    return { encode: N, decode: F, decodeToBytes: C, decodeUnsafe: T, fromWords: Q, fromWordsUnsafe: K, toWords: J };
  }
  e.bech32 = S("bech32"), e.bech32m = S("bech32m"), e.utf8 = {
    encode: (g) => new TextDecoder().decode(g),
    decode: (g) => new TextEncoder().encode(g)
  }, e.hex = r(O(4), i("0123456789abcdef"), s(""), u((g) => {
    if (typeof g != "string" || g.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof g} with length ${g.length}`);
    return g.toLowerCase();
  }));
  const j = {
    utf8: e.utf8,
    hex: e.hex,
    base16: e.base16,
    base32: e.base32,
    base64: e.base64,
    base64url: e.base64url,
    base58: e.base58,
    base58xmr: e.base58xmr
  }, W = `Invalid encoding type. Available types: ${Object.keys(j).join(", ")}`, X = (g, x) => {
    if (typeof g != "string" || !j.hasOwnProperty(g))
      throw new TypeError(W);
    if (!(x instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return j[g].encode(x);
  };
  e.bytesToString = X, e.str = e.bytesToString;
  const H = (g, x) => {
    if (!j.hasOwnProperty(g))
      throw new TypeError(W);
    if (typeof x != "string")
      throw new TypeError("stringToBytes() expects string");
    return j[g].decode(x);
  };
  e.stringToBytes = H, e.bytes = e.stringToBytes;
})(so);
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.mnemonicToSeedSync = yt.mnemonicToSeed = yt.validateMnemonic = yt.entropyToMnemonic = yt.mnemonicToEntropy = yt.generateMnemonic = void 0;
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const fo = ot, ao = or, qf = $t, co = St, zf = xt, Sr = so, Yf = (e) => e[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
function uo(e) {
  if (typeof e != "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof e}`);
  return e.normalize("NFKD");
}
function Ln(e) {
  const t = uo(e), r = t.split(" ");
  if (![12, 15, 18, 21, 24].includes(r.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: t, words: r };
}
function lo(e) {
  fo.default.bytes(e, 16, 20, 24, 28, 32);
}
function Wf(e, t = 128) {
  if (fo.default.number(t), t % 32 !== 0 || t > 256)
    throw new TypeError("Invalid entropy");
  return yo((0, zf.randomBytes)(t / 8), e);
}
yt.generateMnemonic = Wf;
const Zf = (e) => {
  const t = 8 - e.length / 4;
  return new Uint8Array([(0, qf.sha256)(e)[0] >> t << t]);
};
function ho(e) {
  if (!Array.isArray(e) || e.length !== 2048 || typeof e[0] != "string")
    throw new Error("Worlist: expected array of 2048 strings");
  return e.forEach((t) => {
    if (typeof t != "string")
      throw new Error(`Wordlist: non-string element: ${t}`);
  }), Sr.utils.chain(Sr.utils.checksum(1, Zf), Sr.utils.radix2(11, !0), Sr.utils.alphabet(e));
}
function bo(e, t) {
  const { words: r } = Ln(e), i = ho(t).decode(r);
  return lo(i), i;
}
yt.mnemonicToEntropy = bo;
function yo(e, t) {
  return lo(e), ho(t).encode(e).join(Yf(t) ? "\u3000" : " ");
}
yt.entropyToMnemonic = yo;
function Ff(e, t) {
  try {
    bo(e, t);
  } catch {
    return !1;
  }
  return !0;
}
yt.validateMnemonic = Ff;
const po = (e) => uo(`mnemonic${e}`);
function Xf(e, t = "") {
  return (0, ao.pbkdf2Async)(co.sha512, Ln(e).nfkd, po(t), { c: 2048, dkLen: 64 });
}
yt.mnemonicToSeed = Xf;
function Jf(e, t = "") {
  return (0, ao.pbkdf2)(co.sha512, Ln(e).nfkd, po(t), { c: 2048, dkLen: 64 });
}
yt.mnemonicToSeedSync = Jf;
var Mn = Object.defineProperty, Qf = Object.getOwnPropertyDescriptor, ea = Object.getOwnPropertyNames, ta = Object.prototype.hasOwnProperty, ra = (e, t) => {
  for (var r in t)
    Mn(e, r, { get: t[r], enumerable: !0 });
}, na = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of ea(t))
      !ta.call(e, s) && s !== r && Mn(e, s, { get: () => t[s], enumerable: !(i = Qf(t, s)) || i.enumerable });
  return e;
}, ia = (e) => na(Mn({}, "__esModule", { value: !0 }), e), go = {};
ra(go, {
  isValidBIP32Path: () => ca,
  isValidHardenedPath: () => aa,
  mnemonicToSeed: () => xo,
  mnemonicToSeedHex: () => ua
});
var oa = ia(go), sa = Bt, fa = yt;
function aa(e) {
  return !!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(e);
}
function ca(e) {
  return !!new RegExp("^m\\/(54|74)'\\/784'\\/[0-9]+'\\/[0-9]+\\/[0-9]+$").test(e);
}
function xo(e) {
  return (0, fa.mnemonicToSeedSync)(e, "");
}
function ua(e) {
  return (0, sa.toHEX)(xo(e));
}
var kn = Object.defineProperty, la = Object.getOwnPropertyDescriptor, ha = Object.getOwnPropertyNames, da = Object.prototype.hasOwnProperty, ba = (e, t) => {
  for (var r in t)
    kn(e, r, { get: t[r], enumerable: !0 });
}, ya = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of ha(t))
      !da.call(e, s) && s !== r && kn(e, s, { get: () => t[s], enumerable: !(i = la(t, s)) || i.enumerable });
  return e;
}, pa = (e) => ya(kn({}, "__esModule", { value: !0 }), e), wo = {};
ba(wo, {
  AppId: () => _o,
  IntentScope: () => mo,
  IntentVersion: () => vo,
  messageWithIntent: () => xa
});
var Dn = pa(wo), _o = /* @__PURE__ */ ((e) => (e[e.Sui = 0] = "Sui", e))(_o || {}), vo = /* @__PURE__ */ ((e) => (e[e.V0 = 0] = "V0", e))(vo || {}), mo = /* @__PURE__ */ ((e) => (e[e.TransactionData = 0] = "TransactionData", e[e.TransactionEffects = 1] = "TransactionEffects", e[e.CheckpointSummary = 2] = "CheckpointSummary", e[e.PersonalMessage = 3] = "PersonalMessage", e))(mo || {});
function ga(e) {
  return [e, 0, 0];
}
function xa(e, t) {
  const r = ga(e), i = new Uint8Array(r.length + t.length);
  return i.set(r), i.set(t, r.length), i;
}
var cr = {}, sr = {};
Object.defineProperty(sr, "__esModule", { value: !0 });
sr.BLAKE2 = sr.SIGMA = void 0;
const rr = ot, Br = xt;
sr.SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
class wa extends Br.Hash {
  constructor(t, r, i = {}, s, h, u) {
    if (super(), this.blockLen = t, this.outputLen = r, this.length = 0, this.pos = 0, this.finished = !1, this.destroyed = !1, rr.default.number(t), rr.default.number(r), rr.default.number(s), r < 0 || r > s)
      throw new Error("outputLen bigger than keyLen");
    if (i.key !== void 0 && (i.key.length < 1 || i.key.length > s))
      throw new Error(`key must be up 1..${s} byte long or undefined`);
    if (i.salt !== void 0 && i.salt.length !== h)
      throw new Error(`salt must be ${h} byte long or undefined`);
    if (i.personalization !== void 0 && i.personalization.length !== u)
      throw new Error(`personalization must be ${u} byte long or undefined`);
    this.buffer32 = (0, Br.u32)(this.buffer = new Uint8Array(t));
  }
  update(t) {
    rr.default.exists(this);
    const { blockLen: r, buffer: i, buffer32: s } = this;
    t = (0, Br.toBytes)(t);
    const h = t.length, u = t.byteOffset, b = t.buffer;
    for (let l = 0; l < h; ) {
      this.pos === r && (this.compress(s, 0, !1), this.pos = 0);
      const p = Math.min(r - this.pos, h - l), B = u + l;
      if (p === r && !(B % 4) && l + p < h) {
        const w = new Uint32Array(b, B, Math.floor((h - l) / 4));
        for (let O = 0; l + r < h; O += s.length, l += r)
          this.length += r, this.compress(w, O, !1);
        continue;
      }
      i.set(t.subarray(l, l + p), this.pos), this.pos += p, this.length += p, l += p;
    }
    return this;
  }
  digestInto(t) {
    rr.default.exists(this), rr.default.output(t, this);
    const { pos: r, buffer32: i } = this;
    this.finished = !0, this.buffer.subarray(r).fill(0), this.compress(i, 0, !0);
    const s = (0, Br.u32)(t);
    this.get().forEach((h, u) => s[u] = h);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const i = t.slice(0, r);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    const { buffer: r, length: i, finished: s, destroyed: h, outputLen: u, pos: b } = this;
    return t || (t = new this.constructor({ dkLen: u })), t.set(...this.get()), t.length = i, t.finished = s, t.destroyed = h, t.outputLen = u, t.buffer.set(r), t.pos = b, t;
  }
}
sr.BLAKE2 = wa;
Object.defineProperty(cr, "__esModule", { value: !0 });
cr.blake2b = void 0;
const ni = sr, dt = Rn, nr = xt, it = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), oe = new Uint32Array(32);
function Vt(e, t, r, i, s, h) {
  const u = s[h], b = s[h + 1];
  let l = oe[2 * e], p = oe[2 * e + 1], B = oe[2 * t], w = oe[2 * t + 1], O = oe[2 * r], U = oe[2 * r + 1], $ = oe[2 * i], D = oe[2 * i + 1], Z = dt.default.add3L(l, B, u);
  p = dt.default.add3H(Z, p, w, b), l = Z | 0, { Dh: D, Dl: $ } = { Dh: D ^ p, Dl: $ ^ l }, { Dh: D, Dl: $ } = { Dh: dt.default.rotr32H(D, $), Dl: dt.default.rotr32L(D, $) }, { h: U, l: O } = dt.default.add(U, O, D, $), { Bh: w, Bl: B } = { Bh: w ^ U, Bl: B ^ O }, { Bh: w, Bl: B } = { Bh: dt.default.rotrSH(w, B, 24), Bl: dt.default.rotrSL(w, B, 24) }, oe[2 * e] = l, oe[2 * e + 1] = p, oe[2 * t] = B, oe[2 * t + 1] = w, oe[2 * r] = O, oe[2 * r + 1] = U, oe[2 * i] = $, oe[2 * i + 1] = D;
}
function qt(e, t, r, i, s, h) {
  const u = s[h], b = s[h + 1];
  let l = oe[2 * e], p = oe[2 * e + 1], B = oe[2 * t], w = oe[2 * t + 1], O = oe[2 * r], U = oe[2 * r + 1], $ = oe[2 * i], D = oe[2 * i + 1], Z = dt.default.add3L(l, B, u);
  p = dt.default.add3H(Z, p, w, b), l = Z | 0, { Dh: D, Dl: $ } = { Dh: D ^ p, Dl: $ ^ l }, { Dh: D, Dl: $ } = { Dh: dt.default.rotrSH(D, $, 16), Dl: dt.default.rotrSL(D, $, 16) }, { h: U, l: O } = dt.default.add(U, O, D, $), { Bh: w, Bl: B } = { Bh: w ^ U, Bl: B ^ O }, { Bh: w, Bl: B } = { Bh: dt.default.rotrBH(w, B, 63), Bl: dt.default.rotrBL(w, B, 63) }, oe[2 * e] = l, oe[2 * e + 1] = p, oe[2 * t] = B, oe[2 * t + 1] = w, oe[2 * r] = O, oe[2 * r + 1] = U, oe[2 * i] = $, oe[2 * i + 1] = D;
}
class _a extends ni.BLAKE2 {
  constructor(t = {}) {
    super(128, t.dkLen === void 0 ? 64 : t.dkLen, t, 64, 16, 16), this.v0l = it[0] | 0, this.v0h = it[1] | 0, this.v1l = it[2] | 0, this.v1h = it[3] | 0, this.v2l = it[4] | 0, this.v2h = it[5] | 0, this.v3l = it[6] | 0, this.v3h = it[7] | 0, this.v4l = it[8] | 0, this.v4h = it[9] | 0, this.v5l = it[10] | 0, this.v5h = it[11] | 0, this.v6l = it[12] | 0, this.v6h = it[13] | 0, this.v7l = it[14] | 0, this.v7h = it[15] | 0;
    const r = t.key ? t.key.length : 0;
    if (this.v0l ^= this.outputLen | r << 8 | 1 << 16 | 1 << 24, t.salt) {
      const i = (0, nr.u32)((0, nr.toBytes)(t.salt));
      this.v4l ^= i[0], this.v4h ^= i[1], this.v5l ^= i[2], this.v5h ^= i[3];
    }
    if (t.personalization) {
      const i = (0, nr.u32)((0, nr.toBytes)(t.personalization));
      this.v6l ^= i[0], this.v6h ^= i[1], this.v7l ^= i[2], this.v7h ^= i[3];
    }
    if (t.key) {
      const i = new Uint8Array(this.blockLen);
      i.set((0, nr.toBytes)(t.key)), this.update(i);
    }
  }
  get() {
    let { v0l: t, v0h: r, v1l: i, v1h: s, v2l: h, v2h: u, v3l: b, v3h: l, v4l: p, v4h: B, v5l: w, v5h: O, v6l: U, v6h: $, v7l: D, v7h: Z } = this;
    return [t, r, i, s, h, u, b, l, p, B, w, O, U, $, D, Z];
  }
  set(t, r, i, s, h, u, b, l, p, B, w, O, U, $, D, Z) {
    this.v0l = t | 0, this.v0h = r | 0, this.v1l = i | 0, this.v1h = s | 0, this.v2l = h | 0, this.v2h = u | 0, this.v3l = b | 0, this.v3h = l | 0, this.v4l = p | 0, this.v4h = B | 0, this.v5l = w | 0, this.v5h = O | 0, this.v6l = U | 0, this.v6h = $ | 0, this.v7l = D | 0, this.v7h = Z | 0;
  }
  compress(t, r, i) {
    this.get().forEach((l, p) => oe[p] = l), oe.set(it, 16);
    let { h: s, l: h } = dt.default.fromBig(BigInt(this.length));
    oe[24] = it[8] ^ h, oe[25] = it[9] ^ s, i && (oe[28] = ~oe[28], oe[29] = ~oe[29]);
    let u = 0;
    const b = ni.SIGMA;
    for (let l = 0; l < 12; l++)
      Vt(0, 4, 8, 12, t, r + 2 * b[u++]), qt(0, 4, 8, 12, t, r + 2 * b[u++]), Vt(1, 5, 9, 13, t, r + 2 * b[u++]), qt(1, 5, 9, 13, t, r + 2 * b[u++]), Vt(2, 6, 10, 14, t, r + 2 * b[u++]), qt(2, 6, 10, 14, t, r + 2 * b[u++]), Vt(3, 7, 11, 15, t, r + 2 * b[u++]), qt(3, 7, 11, 15, t, r + 2 * b[u++]), Vt(0, 5, 10, 15, t, r + 2 * b[u++]), qt(0, 5, 10, 15, t, r + 2 * b[u++]), Vt(1, 6, 11, 12, t, r + 2 * b[u++]), qt(1, 6, 11, 12, t, r + 2 * b[u++]), Vt(2, 7, 8, 13, t, r + 2 * b[u++]), qt(2, 7, 8, 13, t, r + 2 * b[u++]), Vt(3, 4, 9, 14, t, r + 2 * b[u++]), qt(3, 4, 9, 14, t, r + 2 * b[u++]);
    this.v0l ^= oe[0] ^ oe[16], this.v0h ^= oe[1] ^ oe[17], this.v1l ^= oe[2] ^ oe[18], this.v1h ^= oe[3] ^ oe[19], this.v2l ^= oe[4] ^ oe[20], this.v2h ^= oe[5] ^ oe[21], this.v3l ^= oe[6] ^ oe[22], this.v3h ^= oe[7] ^ oe[23], this.v4l ^= oe[8] ^ oe[24], this.v4h ^= oe[9] ^ oe[25], this.v5l ^= oe[10] ^ oe[26], this.v5h ^= oe[11] ^ oe[27], this.v6l ^= oe[12] ^ oe[28], this.v6h ^= oe[13] ^ oe[29], this.v7l ^= oe[14] ^ oe[30], this.v7h ^= oe[15] ^ oe[31], oe.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer32.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
cr.blake2b = (0, nr.wrapConstructorWithOpts)((e) => new _a(e));
var Hn = Object.defineProperty, va = Object.getOwnPropertyDescriptor, ma = Object.getOwnPropertyNames, Ea = Object.prototype.hasOwnProperty, Sa = (e, t) => {
  for (var r in t)
    Hn(e, r, { get: t[r], enumerable: !0 });
}, Ba = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of ma(t))
      !Ea.call(e, s) && s !== r && Hn(e, s, { get: () => t[s], enumerable: !(i = va(t, s)) || i.enumerable });
  return e;
}, Aa = (e) => Ba(Hn({}, "__esModule", { value: !0 }), e), Eo = {};
Sa(Eo, {
  PublicKey: () => Pa,
  bytesEqual: () => So
});
var _r = Aa(Eo), ii = Bt, Jr = Dn, oi = cr, Ta = vn, si = $r, Oa = xt;
function So(e, t) {
  if (e === t)
    return !0;
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
class Pa {
  equals(t) {
    return So(this.toRawBytes(), t.toRawBytes());
  }
  toBase64() {
    return (0, ii.toB64)(this.toRawBytes());
  }
  toString() {
    return this.toBase64();
  }
  toSuiPublicKey() {
    const t = this.toSuiBytes();
    return (0, ii.toB64)(t);
  }
  verifyWithIntent(t, r, i) {
    const s = (0, Jr.messageWithIntent)(i, t), h = (0, oi.blake2b)(s, { dkLen: 32 });
    return this.verify(h, r);
  }
  verifyPersonalMessage(t, r) {
    return this.verifyWithIntent(
      Ta.bcs.ser(["vector", "u8"], t).toBytes(),
      r,
      Jr.IntentScope.PersonalMessage
    );
  }
  verifyTransactionBlock(t, r) {
    return this.verifyWithIntent(t, r, Jr.IntentScope.TransactionData);
  }
  toSuiBytes() {
    const t = this.toRawBytes(), r = new Uint8Array(t.length + 1);
    return r.set([this.flag()]), r.set(t, 1), r;
  }
  toBytes() {
    return this.toRawBytes();
  }
  toSuiAddress() {
    return (0, si.normalizeSuiAddress)(
      (0, Oa.bytesToHex)((0, oi.blake2b)(this.toSuiBytes(), { dkLen: 32 })).slice(0, si.SUI_ADDRESS_LENGTH * 2)
    );
  }
}
var Kn = Object.defineProperty, Ia = Object.getOwnPropertyDescriptor, Ua = Object.getOwnPropertyNames, ja = Object.prototype.hasOwnProperty, Na = (e, t) => {
  for (var r in t)
    Kn(e, r, { get: t[r], enumerable: !0 });
}, $a = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of Ua(t))
      !ja.call(e, s) && s !== r && Kn(e, s, { get: () => t[s], enumerable: !(i = Ia(t, s)) || i.enumerable });
  return e;
}, Ca = (e) => $a(Kn({}, "__esModule", { value: !0 }), e), Bo = {};
Na(Bo, {
  BaseSigner: () => Ao,
  Keypair: () => Ga,
  LEGACY_PRIVATE_KEY_SIZE: () => Ka,
  PRIVATE_KEY_SIZE: () => Ha
});
var Ra = Ca(Bo), La = ar, Qr = Dn, Ma = cr, ka = vn, Da = Bt;
const Ha = 32, Ka = 64;
class Ao {
  async signWithIntent(t, r) {
    const i = (0, Qr.messageWithIntent)(r, t), s = (0, Ma.blake2b)(i, { dkLen: 32 });
    return {
      signature: (0, La.toSerializedSignature)({
        signature: await this.sign(s),
        signatureScheme: this.getKeyScheme(),
        pubKey: this.getPublicKey()
      }),
      bytes: (0, Da.toB64)(t)
    };
  }
  async signTransactionBlock(t) {
    return this.signWithIntent(t, Qr.IntentScope.TransactionData);
  }
  async signPersonalMessage(t) {
    return this.signWithIntent(
      ka.bcs.ser(["vector", "u8"], t).toBytes(),
      Qr.IntentScope.PersonalMessage
    );
  }
  async signMessage(t) {
    return this.signPersonalMessage(t);
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
}
class Ga extends Ao {
}
(function(e) {
  var t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, s = Object.prototype.hasOwnProperty, h = (O, U) => {
    for (var $ in U)
      t(O, $, { get: U[$], enumerable: !0 });
  }, u = (O, U, $, D) => {
    if (U && typeof U == "object" || typeof U == "function")
      for (let Z of i(U))
        !s.call(O, Z) && Z !== $ && t(O, Z, { get: () => U[Z], enumerable: !(D = r(U, Z)) || D.enumerable });
    return O;
  }, b = (O, U, $) => (u(O, U, "default"), $ && u($, U, "default")), l = (O) => u(t({}, "__esModule", { value: !0 }), O), p = {};
  h(p, {
    Keypair: () => w.Keypair,
    PublicKey: () => B.PublicKey,
    Signer: () => w.BaseSigner
  }), e.exports = l(p), b(p, ar, e.exports), b(p, oa, e.exports), b(p, Dn, e.exports);
  var B = _r, w = Ra;
})(Bi);
function Va(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var To = { exports: {} };
const qa = {}, za = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: qa
}, Symbol.toStringTag, { value: "Module" })), Ya = /* @__PURE__ */ ls(za);
(function(e) {
  (function(t) {
    var r = function(o) {
      var a, f = new Float64Array(16);
      if (o)
        for (a = 0; a < o.length; a++)
          f[a] = o[a];
      return f;
    }, i = function() {
      throw new Error("no PRNG");
    }, s = new Uint8Array(16), h = new Uint8Array(32);
    h[0] = 9;
    var u = r(), b = r([1]), l = r([56129, 1]), p = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), B = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), w = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), O = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), U = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function $(o, a, f, n) {
      o[a] = f >> 24 & 255, o[a + 1] = f >> 16 & 255, o[a + 2] = f >> 8 & 255, o[a + 3] = f & 255, o[a + 4] = n >> 24 & 255, o[a + 5] = n >> 16 & 255, o[a + 6] = n >> 8 & 255, o[a + 7] = n & 255;
    }
    function D(o, a, f, n, c) {
      var _, E = 0;
      for (_ = 0; _ < c; _++)
        E |= o[a + _] ^ f[n + _];
      return (1 & E - 1 >>> 8) - 1;
    }
    function Z(o, a, f, n) {
      return D(o, a, f, n, 16);
    }
    function pe(o, a, f, n) {
      return D(o, a, f, n, 32);
    }
    function v(o, a, f, n) {
      for (var c = n[0] & 255 | (n[1] & 255) << 8 | (n[2] & 255) << 16 | (n[3] & 255) << 24, _ = f[0] & 255 | (f[1] & 255) << 8 | (f[2] & 255) << 16 | (f[3] & 255) << 24, E = f[4] & 255 | (f[5] & 255) << 8 | (f[6] & 255) << 16 | (f[7] & 255) << 24, L = f[8] & 255 | (f[9] & 255) << 8 | (f[10] & 255) << 16 | (f[11] & 255) << 24, Y = f[12] & 255 | (f[13] & 255) << 8 | (f[14] & 255) << 16 | (f[15] & 255) << 24, be = n[4] & 255 | (n[5] & 255) << 8 | (n[6] & 255) << 16 | (n[7] & 255) << 24, se = a[0] & 255 | (a[1] & 255) << 8 | (a[2] & 255) << 16 | (a[3] & 255) << 24, Me = a[4] & 255 | (a[5] & 255) << 8 | (a[6] & 255) << 16 | (a[7] & 255) << 24, ue = a[8] & 255 | (a[9] & 255) << 8 | (a[10] & 255) << 16 | (a[11] & 255) << 24, we = a[12] & 255 | (a[13] & 255) << 8 | (a[14] & 255) << 16 | (a[15] & 255) << 24, ve = n[8] & 255 | (n[9] & 255) << 8 | (n[10] & 255) << 16 | (n[11] & 255) << 24, Oe = f[16] & 255 | (f[17] & 255) << 8 | (f[18] & 255) << 16 | (f[19] & 255) << 24, Ae = f[20] & 255 | (f[21] & 255) << 8 | (f[22] & 255) << 16 | (f[23] & 255) << 24, me = f[24] & 255 | (f[25] & 255) << 8 | (f[26] & 255) << 16 | (f[27] & 255) << 24, Se = f[28] & 255 | (f[29] & 255) << 8 | (f[30] & 255) << 16 | (f[31] & 255) << 24, Ee = n[12] & 255 | (n[13] & 255) << 8 | (n[14] & 255) << 16 | (n[15] & 255) << 24, le = c, ye = _, ae = E, he = L, de = Y, ie = be, P = se, I = Me, G = ue, R = we, M = ve, z = Oe, xe = Ae, Pe = me, Ue = Se, Ie = Ee, y, Ce = 0; Ce < 20; Ce += 2)
        y = le + xe | 0, de ^= y << 7 | y >>> 32 - 7, y = de + le | 0, G ^= y << 9 | y >>> 32 - 9, y = G + de | 0, xe ^= y << 13 | y >>> 32 - 13, y = xe + G | 0, le ^= y << 18 | y >>> 32 - 18, y = ie + ye | 0, R ^= y << 7 | y >>> 32 - 7, y = R + ie | 0, Pe ^= y << 9 | y >>> 32 - 9, y = Pe + R | 0, ye ^= y << 13 | y >>> 32 - 13, y = ye + Pe | 0, ie ^= y << 18 | y >>> 32 - 18, y = M + P | 0, Ue ^= y << 7 | y >>> 32 - 7, y = Ue + M | 0, ae ^= y << 9 | y >>> 32 - 9, y = ae + Ue | 0, P ^= y << 13 | y >>> 32 - 13, y = P + ae | 0, M ^= y << 18 | y >>> 32 - 18, y = Ie + z | 0, he ^= y << 7 | y >>> 32 - 7, y = he + Ie | 0, I ^= y << 9 | y >>> 32 - 9, y = I + he | 0, z ^= y << 13 | y >>> 32 - 13, y = z + I | 0, Ie ^= y << 18 | y >>> 32 - 18, y = le + he | 0, ye ^= y << 7 | y >>> 32 - 7, y = ye + le | 0, ae ^= y << 9 | y >>> 32 - 9, y = ae + ye | 0, he ^= y << 13 | y >>> 32 - 13, y = he + ae | 0, le ^= y << 18 | y >>> 32 - 18, y = ie + de | 0, P ^= y << 7 | y >>> 32 - 7, y = P + ie | 0, I ^= y << 9 | y >>> 32 - 9, y = I + P | 0, de ^= y << 13 | y >>> 32 - 13, y = de + I | 0, ie ^= y << 18 | y >>> 32 - 18, y = M + R | 0, z ^= y << 7 | y >>> 32 - 7, y = z + M | 0, G ^= y << 9 | y >>> 32 - 9, y = G + z | 0, R ^= y << 13 | y >>> 32 - 13, y = R + G | 0, M ^= y << 18 | y >>> 32 - 18, y = Ie + Ue | 0, xe ^= y << 7 | y >>> 32 - 7, y = xe + Ie | 0, Pe ^= y << 9 | y >>> 32 - 9, y = Pe + xe | 0, Ue ^= y << 13 | y >>> 32 - 13, y = Ue + Pe | 0, Ie ^= y << 18 | y >>> 32 - 18;
      le = le + c | 0, ye = ye + _ | 0, ae = ae + E | 0, he = he + L | 0, de = de + Y | 0, ie = ie + be | 0, P = P + se | 0, I = I + Me | 0, G = G + ue | 0, R = R + we | 0, M = M + ve | 0, z = z + Oe | 0, xe = xe + Ae | 0, Pe = Pe + me | 0, Ue = Ue + Se | 0, Ie = Ie + Ee | 0, o[0] = le >>> 0 & 255, o[1] = le >>> 8 & 255, o[2] = le >>> 16 & 255, o[3] = le >>> 24 & 255, o[4] = ye >>> 0 & 255, o[5] = ye >>> 8 & 255, o[6] = ye >>> 16 & 255, o[7] = ye >>> 24 & 255, o[8] = ae >>> 0 & 255, o[9] = ae >>> 8 & 255, o[10] = ae >>> 16 & 255, o[11] = ae >>> 24 & 255, o[12] = he >>> 0 & 255, o[13] = he >>> 8 & 255, o[14] = he >>> 16 & 255, o[15] = he >>> 24 & 255, o[16] = de >>> 0 & 255, o[17] = de >>> 8 & 255, o[18] = de >>> 16 & 255, o[19] = de >>> 24 & 255, o[20] = ie >>> 0 & 255, o[21] = ie >>> 8 & 255, o[22] = ie >>> 16 & 255, o[23] = ie >>> 24 & 255, o[24] = P >>> 0 & 255, o[25] = P >>> 8 & 255, o[26] = P >>> 16 & 255, o[27] = P >>> 24 & 255, o[28] = I >>> 0 & 255, o[29] = I >>> 8 & 255, o[30] = I >>> 16 & 255, o[31] = I >>> 24 & 255, o[32] = G >>> 0 & 255, o[33] = G >>> 8 & 255, o[34] = G >>> 16 & 255, o[35] = G >>> 24 & 255, o[36] = R >>> 0 & 255, o[37] = R >>> 8 & 255, o[38] = R >>> 16 & 255, o[39] = R >>> 24 & 255, o[40] = M >>> 0 & 255, o[41] = M >>> 8 & 255, o[42] = M >>> 16 & 255, o[43] = M >>> 24 & 255, o[44] = z >>> 0 & 255, o[45] = z >>> 8 & 255, o[46] = z >>> 16 & 255, o[47] = z >>> 24 & 255, o[48] = xe >>> 0 & 255, o[49] = xe >>> 8 & 255, o[50] = xe >>> 16 & 255, o[51] = xe >>> 24 & 255, o[52] = Pe >>> 0 & 255, o[53] = Pe >>> 8 & 255, o[54] = Pe >>> 16 & 255, o[55] = Pe >>> 24 & 255, o[56] = Ue >>> 0 & 255, o[57] = Ue >>> 8 & 255, o[58] = Ue >>> 16 & 255, o[59] = Ue >>> 24 & 255, o[60] = Ie >>> 0 & 255, o[61] = Ie >>> 8 & 255, o[62] = Ie >>> 16 & 255, o[63] = Ie >>> 24 & 255;
    }
    function m(o, a, f, n) {
      for (var c = n[0] & 255 | (n[1] & 255) << 8 | (n[2] & 255) << 16 | (n[3] & 255) << 24, _ = f[0] & 255 | (f[1] & 255) << 8 | (f[2] & 255) << 16 | (f[3] & 255) << 24, E = f[4] & 255 | (f[5] & 255) << 8 | (f[6] & 255) << 16 | (f[7] & 255) << 24, L = f[8] & 255 | (f[9] & 255) << 8 | (f[10] & 255) << 16 | (f[11] & 255) << 24, Y = f[12] & 255 | (f[13] & 255) << 8 | (f[14] & 255) << 16 | (f[15] & 255) << 24, be = n[4] & 255 | (n[5] & 255) << 8 | (n[6] & 255) << 16 | (n[7] & 255) << 24, se = a[0] & 255 | (a[1] & 255) << 8 | (a[2] & 255) << 16 | (a[3] & 255) << 24, Me = a[4] & 255 | (a[5] & 255) << 8 | (a[6] & 255) << 16 | (a[7] & 255) << 24, ue = a[8] & 255 | (a[9] & 255) << 8 | (a[10] & 255) << 16 | (a[11] & 255) << 24, we = a[12] & 255 | (a[13] & 255) << 8 | (a[14] & 255) << 16 | (a[15] & 255) << 24, ve = n[8] & 255 | (n[9] & 255) << 8 | (n[10] & 255) << 16 | (n[11] & 255) << 24, Oe = f[16] & 255 | (f[17] & 255) << 8 | (f[18] & 255) << 16 | (f[19] & 255) << 24, Ae = f[20] & 255 | (f[21] & 255) << 8 | (f[22] & 255) << 16 | (f[23] & 255) << 24, me = f[24] & 255 | (f[25] & 255) << 8 | (f[26] & 255) << 16 | (f[27] & 255) << 24, Se = f[28] & 255 | (f[29] & 255) << 8 | (f[30] & 255) << 16 | (f[31] & 255) << 24, Ee = n[12] & 255 | (n[13] & 255) << 8 | (n[14] & 255) << 16 | (n[15] & 255) << 24, le = c, ye = _, ae = E, he = L, de = Y, ie = be, P = se, I = Me, G = ue, R = we, M = ve, z = Oe, xe = Ae, Pe = me, Ue = Se, Ie = Ee, y, Ce = 0; Ce < 20; Ce += 2)
        y = le + xe | 0, de ^= y << 7 | y >>> 32 - 7, y = de + le | 0, G ^= y << 9 | y >>> 32 - 9, y = G + de | 0, xe ^= y << 13 | y >>> 32 - 13, y = xe + G | 0, le ^= y << 18 | y >>> 32 - 18, y = ie + ye | 0, R ^= y << 7 | y >>> 32 - 7, y = R + ie | 0, Pe ^= y << 9 | y >>> 32 - 9, y = Pe + R | 0, ye ^= y << 13 | y >>> 32 - 13, y = ye + Pe | 0, ie ^= y << 18 | y >>> 32 - 18, y = M + P | 0, Ue ^= y << 7 | y >>> 32 - 7, y = Ue + M | 0, ae ^= y << 9 | y >>> 32 - 9, y = ae + Ue | 0, P ^= y << 13 | y >>> 32 - 13, y = P + ae | 0, M ^= y << 18 | y >>> 32 - 18, y = Ie + z | 0, he ^= y << 7 | y >>> 32 - 7, y = he + Ie | 0, I ^= y << 9 | y >>> 32 - 9, y = I + he | 0, z ^= y << 13 | y >>> 32 - 13, y = z + I | 0, Ie ^= y << 18 | y >>> 32 - 18, y = le + he | 0, ye ^= y << 7 | y >>> 32 - 7, y = ye + le | 0, ae ^= y << 9 | y >>> 32 - 9, y = ae + ye | 0, he ^= y << 13 | y >>> 32 - 13, y = he + ae | 0, le ^= y << 18 | y >>> 32 - 18, y = ie + de | 0, P ^= y << 7 | y >>> 32 - 7, y = P + ie | 0, I ^= y << 9 | y >>> 32 - 9, y = I + P | 0, de ^= y << 13 | y >>> 32 - 13, y = de + I | 0, ie ^= y << 18 | y >>> 32 - 18, y = M + R | 0, z ^= y << 7 | y >>> 32 - 7, y = z + M | 0, G ^= y << 9 | y >>> 32 - 9, y = G + z | 0, R ^= y << 13 | y >>> 32 - 13, y = R + G | 0, M ^= y << 18 | y >>> 32 - 18, y = Ie + Ue | 0, xe ^= y << 7 | y >>> 32 - 7, y = xe + Ie | 0, Pe ^= y << 9 | y >>> 32 - 9, y = Pe + xe | 0, Ue ^= y << 13 | y >>> 32 - 13, y = Ue + Pe | 0, Ie ^= y << 18 | y >>> 32 - 18;
      o[0] = le >>> 0 & 255, o[1] = le >>> 8 & 255, o[2] = le >>> 16 & 255, o[3] = le >>> 24 & 255, o[4] = ie >>> 0 & 255, o[5] = ie >>> 8 & 255, o[6] = ie >>> 16 & 255, o[7] = ie >>> 24 & 255, o[8] = M >>> 0 & 255, o[9] = M >>> 8 & 255, o[10] = M >>> 16 & 255, o[11] = M >>> 24 & 255, o[12] = Ie >>> 0 & 255, o[13] = Ie >>> 8 & 255, o[14] = Ie >>> 16 & 255, o[15] = Ie >>> 24 & 255, o[16] = P >>> 0 & 255, o[17] = P >>> 8 & 255, o[18] = P >>> 16 & 255, o[19] = P >>> 24 & 255, o[20] = I >>> 0 & 255, o[21] = I >>> 8 & 255, o[22] = I >>> 16 & 255, o[23] = I >>> 24 & 255, o[24] = G >>> 0 & 255, o[25] = G >>> 8 & 255, o[26] = G >>> 16 & 255, o[27] = G >>> 24 & 255, o[28] = R >>> 0 & 255, o[29] = R >>> 8 & 255, o[30] = R >>> 16 & 255, o[31] = R >>> 24 & 255;
    }
    function d(o, a, f, n) {
      v(o, a, f, n);
    }
    function V(o, a, f, n) {
      m(o, a, f, n);
    }
    var S = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function j(o, a, f, n, c, _, E) {
      var L = new Uint8Array(16), Y = new Uint8Array(64), be, se;
      for (se = 0; se < 16; se++)
        L[se] = 0;
      for (se = 0; se < 8; se++)
        L[se] = _[se];
      for (; c >= 64; ) {
        for (d(Y, L, E, S), se = 0; se < 64; se++)
          o[a + se] = f[n + se] ^ Y[se];
        for (be = 1, se = 8; se < 16; se++)
          be = be + (L[se] & 255) | 0, L[se] = be & 255, be >>>= 8;
        c -= 64, a += 64, n += 64;
      }
      if (c > 0)
        for (d(Y, L, E, S), se = 0; se < c; se++)
          o[a + se] = f[n + se] ^ Y[se];
      return 0;
    }
    function W(o, a, f, n, c) {
      var _ = new Uint8Array(16), E = new Uint8Array(64), L, Y;
      for (Y = 0; Y < 16; Y++)
        _[Y] = 0;
      for (Y = 0; Y < 8; Y++)
        _[Y] = n[Y];
      for (; f >= 64; ) {
        for (d(E, _, c, S), Y = 0; Y < 64; Y++)
          o[a + Y] = E[Y];
        for (L = 1, Y = 8; Y < 16; Y++)
          L = L + (_[Y] & 255) | 0, _[Y] = L & 255, L >>>= 8;
        f -= 64, a += 64;
      }
      if (f > 0)
        for (d(E, _, c, S), Y = 0; Y < f; Y++)
          o[a + Y] = E[Y];
      return 0;
    }
    function X(o, a, f, n, c) {
      var _ = new Uint8Array(32);
      V(_, n, c, S);
      for (var E = new Uint8Array(8), L = 0; L < 8; L++)
        E[L] = n[L + 16];
      return W(o, a, f, E, _);
    }
    function H(o, a, f, n, c, _, E) {
      var L = new Uint8Array(32);
      V(L, _, E, S);
      for (var Y = new Uint8Array(8), be = 0; be < 8; be++)
        Y[be] = _[be + 16];
      return j(o, a, f, n, c, Y, L);
    }
    var g = function(o) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var a, f, n, c, _, E, L, Y;
      a = o[0] & 255 | (o[1] & 255) << 8, this.r[0] = a & 8191, f = o[2] & 255 | (o[3] & 255) << 8, this.r[1] = (a >>> 13 | f << 3) & 8191, n = o[4] & 255 | (o[5] & 255) << 8, this.r[2] = (f >>> 10 | n << 6) & 7939, c = o[6] & 255 | (o[7] & 255) << 8, this.r[3] = (n >>> 7 | c << 9) & 8191, _ = o[8] & 255 | (o[9] & 255) << 8, this.r[4] = (c >>> 4 | _ << 12) & 255, this.r[5] = _ >>> 1 & 8190, E = o[10] & 255 | (o[11] & 255) << 8, this.r[6] = (_ >>> 14 | E << 2) & 8191, L = o[12] & 255 | (o[13] & 255) << 8, this.r[7] = (E >>> 11 | L << 5) & 8065, Y = o[14] & 255 | (o[15] & 255) << 8, this.r[8] = (L >>> 8 | Y << 8) & 8191, this.r[9] = Y >>> 5 & 127, this.pad[0] = o[16] & 255 | (o[17] & 255) << 8, this.pad[1] = o[18] & 255 | (o[19] & 255) << 8, this.pad[2] = o[20] & 255 | (o[21] & 255) << 8, this.pad[3] = o[22] & 255 | (o[23] & 255) << 8, this.pad[4] = o[24] & 255 | (o[25] & 255) << 8, this.pad[5] = o[26] & 255 | (o[27] & 255) << 8, this.pad[6] = o[28] & 255 | (o[29] & 255) << 8, this.pad[7] = o[30] & 255 | (o[31] & 255) << 8;
    };
    g.prototype.blocks = function(o, a, f) {
      for (var n = this.fin ? 0 : 2048, c, _, E, L, Y, be, se, Me, ue, we, ve, Oe, Ae, me, Se, Ee, le, ye, ae, he = this.h[0], de = this.h[1], ie = this.h[2], P = this.h[3], I = this.h[4], G = this.h[5], R = this.h[6], M = this.h[7], z = this.h[8], xe = this.h[9], Pe = this.r[0], Ue = this.r[1], Ie = this.r[2], y = this.r[3], Ce = this.r[4], ke = this.r[5], De = this.r[6], je = this.r[7], Re = this.r[8], Le = this.r[9]; f >= 16; )
        c = o[a + 0] & 255 | (o[a + 1] & 255) << 8, he += c & 8191, _ = o[a + 2] & 255 | (o[a + 3] & 255) << 8, de += (c >>> 13 | _ << 3) & 8191, E = o[a + 4] & 255 | (o[a + 5] & 255) << 8, ie += (_ >>> 10 | E << 6) & 8191, L = o[a + 6] & 255 | (o[a + 7] & 255) << 8, P += (E >>> 7 | L << 9) & 8191, Y = o[a + 8] & 255 | (o[a + 9] & 255) << 8, I += (L >>> 4 | Y << 12) & 8191, G += Y >>> 1 & 8191, be = o[a + 10] & 255 | (o[a + 11] & 255) << 8, R += (Y >>> 14 | be << 2) & 8191, se = o[a + 12] & 255 | (o[a + 13] & 255) << 8, M += (be >>> 11 | se << 5) & 8191, Me = o[a + 14] & 255 | (o[a + 15] & 255) << 8, z += (se >>> 8 | Me << 8) & 8191, xe += Me >>> 5 | n, ue = 0, we = ue, we += he * Pe, we += de * (5 * Le), we += ie * (5 * Re), we += P * (5 * je), we += I * (5 * De), ue = we >>> 13, we &= 8191, we += G * (5 * ke), we += R * (5 * Ce), we += M * (5 * y), we += z * (5 * Ie), we += xe * (5 * Ue), ue += we >>> 13, we &= 8191, ve = ue, ve += he * Ue, ve += de * Pe, ve += ie * (5 * Le), ve += P * (5 * Re), ve += I * (5 * je), ue = ve >>> 13, ve &= 8191, ve += G * (5 * De), ve += R * (5 * ke), ve += M * (5 * Ce), ve += z * (5 * y), ve += xe * (5 * Ie), ue += ve >>> 13, ve &= 8191, Oe = ue, Oe += he * Ie, Oe += de * Ue, Oe += ie * Pe, Oe += P * (5 * Le), Oe += I * (5 * Re), ue = Oe >>> 13, Oe &= 8191, Oe += G * (5 * je), Oe += R * (5 * De), Oe += M * (5 * ke), Oe += z * (5 * Ce), Oe += xe * (5 * y), ue += Oe >>> 13, Oe &= 8191, Ae = ue, Ae += he * y, Ae += de * Ie, Ae += ie * Ue, Ae += P * Pe, Ae += I * (5 * Le), ue = Ae >>> 13, Ae &= 8191, Ae += G * (5 * Re), Ae += R * (5 * je), Ae += M * (5 * De), Ae += z * (5 * ke), Ae += xe * (5 * Ce), ue += Ae >>> 13, Ae &= 8191, me = ue, me += he * Ce, me += de * y, me += ie * Ie, me += P * Ue, me += I * Pe, ue = me >>> 13, me &= 8191, me += G * (5 * Le), me += R * (5 * Re), me += M * (5 * je), me += z * (5 * De), me += xe * (5 * ke), ue += me >>> 13, me &= 8191, Se = ue, Se += he * ke, Se += de * Ce, Se += ie * y, Se += P * Ie, Se += I * Ue, ue = Se >>> 13, Se &= 8191, Se += G * Pe, Se += R * (5 * Le), Se += M * (5 * Re), Se += z * (5 * je), Se += xe * (5 * De), ue += Se >>> 13, Se &= 8191, Ee = ue, Ee += he * De, Ee += de * ke, Ee += ie * Ce, Ee += P * y, Ee += I * Ie, ue = Ee >>> 13, Ee &= 8191, Ee += G * Ue, Ee += R * Pe, Ee += M * (5 * Le), Ee += z * (5 * Re), Ee += xe * (5 * je), ue += Ee >>> 13, Ee &= 8191, le = ue, le += he * je, le += de * De, le += ie * ke, le += P * Ce, le += I * y, ue = le >>> 13, le &= 8191, le += G * Ie, le += R * Ue, le += M * Pe, le += z * (5 * Le), le += xe * (5 * Re), ue += le >>> 13, le &= 8191, ye = ue, ye += he * Re, ye += de * je, ye += ie * De, ye += P * ke, ye += I * Ce, ue = ye >>> 13, ye &= 8191, ye += G * y, ye += R * Ie, ye += M * Ue, ye += z * Pe, ye += xe * (5 * Le), ue += ye >>> 13, ye &= 8191, ae = ue, ae += he * Le, ae += de * Re, ae += ie * je, ae += P * De, ae += I * ke, ue = ae >>> 13, ae &= 8191, ae += G * Ce, ae += R * y, ae += M * Ie, ae += z * Ue, ae += xe * Pe, ue += ae >>> 13, ae &= 8191, ue = (ue << 2) + ue | 0, ue = ue + we | 0, we = ue & 8191, ue = ue >>> 13, ve += ue, he = we, de = ve, ie = Oe, P = Ae, I = me, G = Se, R = Ee, M = le, z = ye, xe = ae, a += 16, f -= 16;
      this.h[0] = he, this.h[1] = de, this.h[2] = ie, this.h[3] = P, this.h[4] = I, this.h[5] = G, this.h[6] = R, this.h[7] = M, this.h[8] = z, this.h[9] = xe;
    }, g.prototype.finish = function(o, a) {
      var f = new Uint16Array(10), n, c, _, E;
      if (this.leftover) {
        for (E = this.leftover, this.buffer[E++] = 1; E < 16; E++)
          this.buffer[E] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (n = this.h[1] >>> 13, this.h[1] &= 8191, E = 2; E < 10; E++)
        this.h[E] += n, n = this.h[E] >>> 13, this.h[E] &= 8191;
      for (this.h[0] += n * 5, n = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += n, n = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += n, f[0] = this.h[0] + 5, n = f[0] >>> 13, f[0] &= 8191, E = 1; E < 10; E++)
        f[E] = this.h[E] + n, n = f[E] >>> 13, f[E] &= 8191;
      for (f[9] -= 1 << 13, c = (n ^ 1) - 1, E = 0; E < 10; E++)
        f[E] &= c;
      for (c = ~c, E = 0; E < 10; E++)
        this.h[E] = this.h[E] & c | f[E];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, _ = this.h[0] + this.pad[0], this.h[0] = _ & 65535, E = 1; E < 8; E++)
        _ = (this.h[E] + this.pad[E] | 0) + (_ >>> 16) | 0, this.h[E] = _ & 65535;
      o[a + 0] = this.h[0] >>> 0 & 255, o[a + 1] = this.h[0] >>> 8 & 255, o[a + 2] = this.h[1] >>> 0 & 255, o[a + 3] = this.h[1] >>> 8 & 255, o[a + 4] = this.h[2] >>> 0 & 255, o[a + 5] = this.h[2] >>> 8 & 255, o[a + 6] = this.h[3] >>> 0 & 255, o[a + 7] = this.h[3] >>> 8 & 255, o[a + 8] = this.h[4] >>> 0 & 255, o[a + 9] = this.h[4] >>> 8 & 255, o[a + 10] = this.h[5] >>> 0 & 255, o[a + 11] = this.h[5] >>> 8 & 255, o[a + 12] = this.h[6] >>> 0 & 255, o[a + 13] = this.h[6] >>> 8 & 255, o[a + 14] = this.h[7] >>> 0 & 255, o[a + 15] = this.h[7] >>> 8 & 255;
    }, g.prototype.update = function(o, a, f) {
      var n, c;
      if (this.leftover) {
        for (c = 16 - this.leftover, c > f && (c = f), n = 0; n < c; n++)
          this.buffer[this.leftover + n] = o[a + n];
        if (f -= c, a += c, this.leftover += c, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (f >= 16 && (c = f - f % 16, this.blocks(o, a, c), a += c, f -= c), f) {
        for (n = 0; n < f; n++)
          this.buffer[this.leftover + n] = o[a + n];
        this.leftover += f;
      }
    };
    function x(o, a, f, n, c, _) {
      var E = new g(_);
      return E.update(f, n, c), E.finish(o, a), 0;
    }
    function A(o, a, f, n, c, _) {
      var E = new Uint8Array(16);
      return x(E, 0, f, n, c, _), Z(o, a, E, 0);
    }
    function Q(o, a, f, n, c) {
      var _;
      if (f < 32)
        return -1;
      for (H(o, 0, a, 0, f, n, c), x(o, 16, o, 32, f - 32, o), _ = 0; _ < 16; _++)
        o[_] = 0;
      return 0;
    }
    function J(o, a, f, n, c) {
      var _, E = new Uint8Array(32);
      if (f < 32 || (X(E, 0, 32, n, c), A(a, 16, a, 32, f - 32, E) !== 0))
        return -1;
      for (H(o, 0, a, 0, f, n, c), _ = 0; _ < 32; _++)
        o[_] = 0;
      return 0;
    }
    function K(o, a) {
      var f;
      for (f = 0; f < 16; f++)
        o[f] = a[f] | 0;
    }
    function N(o) {
      var a, f, n = 1;
      for (a = 0; a < 16; a++)
        f = o[a] + n + 65535, n = Math.floor(f / 65536), o[a] = f - n * 65536;
      o[0] += n - 1 + 37 * (n - 1);
    }
    function F(o, a, f) {
      for (var n, c = ~(f - 1), _ = 0; _ < 16; _++)
        n = c & (o[_] ^ a[_]), o[_] ^= n, a[_] ^= n;
    }
    function T(o, a) {
      var f, n, c, _ = r(), E = r();
      for (f = 0; f < 16; f++)
        E[f] = a[f];
      for (N(E), N(E), N(E), n = 0; n < 2; n++) {
        for (_[0] = E[0] - 65517, f = 1; f < 15; f++)
          _[f] = E[f] - 65535 - (_[f - 1] >> 16 & 1), _[f - 1] &= 65535;
        _[15] = E[15] - 32767 - (_[14] >> 16 & 1), c = _[15] >> 16 & 1, _[14] &= 65535, F(E, _, 1 - c);
      }
      for (f = 0; f < 16; f++)
        o[2 * f] = E[f] & 255, o[2 * f + 1] = E[f] >> 8;
    }
    function C(o, a) {
      var f = new Uint8Array(32), n = new Uint8Array(32);
      return T(f, o), T(n, a), pe(f, 0, n, 0);
    }
    function k(o) {
      var a = new Uint8Array(32);
      return T(a, o), a[0] & 1;
    }
    function re(o, a) {
      var f;
      for (f = 0; f < 16; f++)
        o[f] = a[2 * f] + (a[2 * f + 1] << 8);
      o[15] &= 32767;
    }
    function ne(o, a, f) {
      for (var n = 0; n < 16; n++)
        o[n] = a[n] + f[n];
    }
    function ee(o, a, f) {
      for (var n = 0; n < 16; n++)
        o[n] = a[n] - f[n];
    }
    function q(o, a, f) {
      var n, c, _ = 0, E = 0, L = 0, Y = 0, be = 0, se = 0, Me = 0, ue = 0, we = 0, ve = 0, Oe = 0, Ae = 0, me = 0, Se = 0, Ee = 0, le = 0, ye = 0, ae = 0, he = 0, de = 0, ie = 0, P = 0, I = 0, G = 0, R = 0, M = 0, z = 0, xe = 0, Pe = 0, Ue = 0, Ie = 0, y = f[0], Ce = f[1], ke = f[2], De = f[3], je = f[4], Re = f[5], Le = f[6], tt = f[7], Ve = f[8], Xe = f[9], Je = f[10], Qe = f[11], nt = f[12], ct = f[13], ut = f[14], lt = f[15];
      n = a[0], _ += n * y, E += n * Ce, L += n * ke, Y += n * De, be += n * je, se += n * Re, Me += n * Le, ue += n * tt, we += n * Ve, ve += n * Xe, Oe += n * Je, Ae += n * Qe, me += n * nt, Se += n * ct, Ee += n * ut, le += n * lt, n = a[1], E += n * y, L += n * Ce, Y += n * ke, be += n * De, se += n * je, Me += n * Re, ue += n * Le, we += n * tt, ve += n * Ve, Oe += n * Xe, Ae += n * Je, me += n * Qe, Se += n * nt, Ee += n * ct, le += n * ut, ye += n * lt, n = a[2], L += n * y, Y += n * Ce, be += n * ke, se += n * De, Me += n * je, ue += n * Re, we += n * Le, ve += n * tt, Oe += n * Ve, Ae += n * Xe, me += n * Je, Se += n * Qe, Ee += n * nt, le += n * ct, ye += n * ut, ae += n * lt, n = a[3], Y += n * y, be += n * Ce, se += n * ke, Me += n * De, ue += n * je, we += n * Re, ve += n * Le, Oe += n * tt, Ae += n * Ve, me += n * Xe, Se += n * Je, Ee += n * Qe, le += n * nt, ye += n * ct, ae += n * ut, he += n * lt, n = a[4], be += n * y, se += n * Ce, Me += n * ke, ue += n * De, we += n * je, ve += n * Re, Oe += n * Le, Ae += n * tt, me += n * Ve, Se += n * Xe, Ee += n * Je, le += n * Qe, ye += n * nt, ae += n * ct, he += n * ut, de += n * lt, n = a[5], se += n * y, Me += n * Ce, ue += n * ke, we += n * De, ve += n * je, Oe += n * Re, Ae += n * Le, me += n * tt, Se += n * Ve, Ee += n * Xe, le += n * Je, ye += n * Qe, ae += n * nt, he += n * ct, de += n * ut, ie += n * lt, n = a[6], Me += n * y, ue += n * Ce, we += n * ke, ve += n * De, Oe += n * je, Ae += n * Re, me += n * Le, Se += n * tt, Ee += n * Ve, le += n * Xe, ye += n * Je, ae += n * Qe, he += n * nt, de += n * ct, ie += n * ut, P += n * lt, n = a[7], ue += n * y, we += n * Ce, ve += n * ke, Oe += n * De, Ae += n * je, me += n * Re, Se += n * Le, Ee += n * tt, le += n * Ve, ye += n * Xe, ae += n * Je, he += n * Qe, de += n * nt, ie += n * ct, P += n * ut, I += n * lt, n = a[8], we += n * y, ve += n * Ce, Oe += n * ke, Ae += n * De, me += n * je, Se += n * Re, Ee += n * Le, le += n * tt, ye += n * Ve, ae += n * Xe, he += n * Je, de += n * Qe, ie += n * nt, P += n * ct, I += n * ut, G += n * lt, n = a[9], ve += n * y, Oe += n * Ce, Ae += n * ke, me += n * De, Se += n * je, Ee += n * Re, le += n * Le, ye += n * tt, ae += n * Ve, he += n * Xe, de += n * Je, ie += n * Qe, P += n * nt, I += n * ct, G += n * ut, R += n * lt, n = a[10], Oe += n * y, Ae += n * Ce, me += n * ke, Se += n * De, Ee += n * je, le += n * Re, ye += n * Le, ae += n * tt, he += n * Ve, de += n * Xe, ie += n * Je, P += n * Qe, I += n * nt, G += n * ct, R += n * ut, M += n * lt, n = a[11], Ae += n * y, me += n * Ce, Se += n * ke, Ee += n * De, le += n * je, ye += n * Re, ae += n * Le, he += n * tt, de += n * Ve, ie += n * Xe, P += n * Je, I += n * Qe, G += n * nt, R += n * ct, M += n * ut, z += n * lt, n = a[12], me += n * y, Se += n * Ce, Ee += n * ke, le += n * De, ye += n * je, ae += n * Re, he += n * Le, de += n * tt, ie += n * Ve, P += n * Xe, I += n * Je, G += n * Qe, R += n * nt, M += n * ct, z += n * ut, xe += n * lt, n = a[13], Se += n * y, Ee += n * Ce, le += n * ke, ye += n * De, ae += n * je, he += n * Re, de += n * Le, ie += n * tt, P += n * Ve, I += n * Xe, G += n * Je, R += n * Qe, M += n * nt, z += n * ct, xe += n * ut, Pe += n * lt, n = a[14], Ee += n * y, le += n * Ce, ye += n * ke, ae += n * De, he += n * je, de += n * Re, ie += n * Le, P += n * tt, I += n * Ve, G += n * Xe, R += n * Je, M += n * Qe, z += n * nt, xe += n * ct, Pe += n * ut, Ue += n * lt, n = a[15], le += n * y, ye += n * Ce, ae += n * ke, he += n * De, de += n * je, ie += n * Re, P += n * Le, I += n * tt, G += n * Ve, R += n * Xe, M += n * Je, z += n * Qe, xe += n * nt, Pe += n * ct, Ue += n * ut, Ie += n * lt, _ += 38 * ye, E += 38 * ae, L += 38 * he, Y += 38 * de, be += 38 * ie, se += 38 * P, Me += 38 * I, ue += 38 * G, we += 38 * R, ve += 38 * M, Oe += 38 * z, Ae += 38 * xe, me += 38 * Pe, Se += 38 * Ue, Ee += 38 * Ie, c = 1, n = _ + c + 65535, c = Math.floor(n / 65536), _ = n - c * 65536, n = E + c + 65535, c = Math.floor(n / 65536), E = n - c * 65536, n = L + c + 65535, c = Math.floor(n / 65536), L = n - c * 65536, n = Y + c + 65535, c = Math.floor(n / 65536), Y = n - c * 65536, n = be + c + 65535, c = Math.floor(n / 65536), be = n - c * 65536, n = se + c + 65535, c = Math.floor(n / 65536), se = n - c * 65536, n = Me + c + 65535, c = Math.floor(n / 65536), Me = n - c * 65536, n = ue + c + 65535, c = Math.floor(n / 65536), ue = n - c * 65536, n = we + c + 65535, c = Math.floor(n / 65536), we = n - c * 65536, n = ve + c + 65535, c = Math.floor(n / 65536), ve = n - c * 65536, n = Oe + c + 65535, c = Math.floor(n / 65536), Oe = n - c * 65536, n = Ae + c + 65535, c = Math.floor(n / 65536), Ae = n - c * 65536, n = me + c + 65535, c = Math.floor(n / 65536), me = n - c * 65536, n = Se + c + 65535, c = Math.floor(n / 65536), Se = n - c * 65536, n = Ee + c + 65535, c = Math.floor(n / 65536), Ee = n - c * 65536, n = le + c + 65535, c = Math.floor(n / 65536), le = n - c * 65536, _ += c - 1 + 37 * (c - 1), c = 1, n = _ + c + 65535, c = Math.floor(n / 65536), _ = n - c * 65536, n = E + c + 65535, c = Math.floor(n / 65536), E = n - c * 65536, n = L + c + 65535, c = Math.floor(n / 65536), L = n - c * 65536, n = Y + c + 65535, c = Math.floor(n / 65536), Y = n - c * 65536, n = be + c + 65535, c = Math.floor(n / 65536), be = n - c * 65536, n = se + c + 65535, c = Math.floor(n / 65536), se = n - c * 65536, n = Me + c + 65535, c = Math.floor(n / 65536), Me = n - c * 65536, n = ue + c + 65535, c = Math.floor(n / 65536), ue = n - c * 65536, n = we + c + 65535, c = Math.floor(n / 65536), we = n - c * 65536, n = ve + c + 65535, c = Math.floor(n / 65536), ve = n - c * 65536, n = Oe + c + 65535, c = Math.floor(n / 65536), Oe = n - c * 65536, n = Ae + c + 65535, c = Math.floor(n / 65536), Ae = n - c * 65536, n = me + c + 65535, c = Math.floor(n / 65536), me = n - c * 65536, n = Se + c + 65535, c = Math.floor(n / 65536), Se = n - c * 65536, n = Ee + c + 65535, c = Math.floor(n / 65536), Ee = n - c * 65536, n = le + c + 65535, c = Math.floor(n / 65536), le = n - c * 65536, _ += c - 1 + 37 * (c - 1), o[0] = _, o[1] = E, o[2] = L, o[3] = Y, o[4] = be, o[5] = se, o[6] = Me, o[7] = ue, o[8] = we, o[9] = ve, o[10] = Oe, o[11] = Ae, o[12] = me, o[13] = Se, o[14] = Ee, o[15] = le;
    }
    function fe(o, a) {
      q(o, a, a);
    }
    function Ke(o, a) {
      var f = r(), n;
      for (n = 0; n < 16; n++)
        f[n] = a[n];
      for (n = 253; n >= 0; n--)
        fe(f, f), n !== 2 && n !== 4 && q(f, f, a);
      for (n = 0; n < 16; n++)
        o[n] = f[n];
    }
    function _e(o, a) {
      var f = r(), n;
      for (n = 0; n < 16; n++)
        f[n] = a[n];
      for (n = 250; n >= 0; n--)
        fe(f, f), n !== 1 && q(f, f, a);
      for (n = 0; n < 16; n++)
        o[n] = f[n];
    }
    function ge(o, a, f) {
      var n = new Uint8Array(32), c = new Float64Array(80), _, E, L = r(), Y = r(), be = r(), se = r(), Me = r(), ue = r();
      for (E = 0; E < 31; E++)
        n[E] = a[E];
      for (n[31] = a[31] & 127 | 64, n[0] &= 248, re(c, f), E = 0; E < 16; E++)
        Y[E] = c[E], se[E] = L[E] = be[E] = 0;
      for (L[0] = se[0] = 1, E = 254; E >= 0; --E)
        _ = n[E >>> 3] >>> (E & 7) & 1, F(L, Y, _), F(be, se, _), ne(Me, L, be), ee(L, L, be), ne(be, Y, se), ee(Y, Y, se), fe(se, Me), fe(ue, L), q(L, be, L), q(be, Y, Me), ne(Me, L, be), ee(L, L, be), fe(Y, L), ee(be, se, ue), q(L, be, l), ne(L, L, se), q(be, be, L), q(L, se, ue), q(se, Y, c), fe(Y, Me), F(L, Y, _), F(be, se, _);
      for (E = 0; E < 16; E++)
        c[E + 16] = L[E], c[E + 32] = be[E], c[E + 48] = Y[E], c[E + 64] = se[E];
      var we = c.subarray(32), ve = c.subarray(16);
      return Ke(we, we), q(ve, ve, we), T(o, ve), 0;
    }
    function qe(o, a) {
      return ge(o, a, h);
    }
    function We(o, a) {
      return i(a, 32), qe(o, a);
    }
    function et(o, a, f) {
      var n = new Uint8Array(32);
      return ge(n, f, a), V(o, s, n, S);
    }
    var te = Q, ce = J;
    function Te(o, a, f, n, c, _) {
      var E = new Uint8Array(32);
      return et(E, c, _), te(o, a, f, n, E);
    }
    function Ge(o, a, f, n, c, _) {
      var E = new Uint8Array(32);
      return et(E, c, _), ce(o, a, f, n, E);
    }
    var He = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function Ze(o, a, f, n) {
      for (var c = new Int32Array(16), _ = new Int32Array(16), E, L, Y, be, se, Me, ue, we, ve, Oe, Ae, me, Se, Ee, le, ye, ae, he, de, ie, P, I, G, R, M, z, xe = o[0], Pe = o[1], Ue = o[2], Ie = o[3], y = o[4], Ce = o[5], ke = o[6], De = o[7], je = a[0], Re = a[1], Le = a[2], tt = a[3], Ve = a[4], Xe = a[5], Je = a[6], Qe = a[7], nt = 0; n >= 128; ) {
        for (de = 0; de < 16; de++)
          ie = 8 * de + nt, c[de] = f[ie + 0] << 24 | f[ie + 1] << 16 | f[ie + 2] << 8 | f[ie + 3], _[de] = f[ie + 4] << 24 | f[ie + 5] << 16 | f[ie + 6] << 8 | f[ie + 7];
        for (de = 0; de < 80; de++)
          if (E = xe, L = Pe, Y = Ue, be = Ie, se = y, Me = Ce, ue = ke, we = De, ve = je, Oe = Re, Ae = Le, me = tt, Se = Ve, Ee = Xe, le = Je, ye = Qe, P = De, I = Qe, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = (y >>> 14 | Ve << 32 - 14) ^ (y >>> 18 | Ve << 32 - 18) ^ (Ve >>> 41 - 32 | y << 32 - (41 - 32)), I = (Ve >>> 14 | y << 32 - 14) ^ (Ve >>> 18 | y << 32 - 18) ^ (y >>> 41 - 32 | Ve << 32 - (41 - 32)), G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, P = y & Ce ^ ~y & ke, I = Ve & Xe ^ ~Ve & Je, G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, P = He[de * 2], I = He[de * 2 + 1], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, P = c[de % 16], I = _[de % 16], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, ae = M & 65535 | z << 16, he = G & 65535 | R << 16, P = ae, I = he, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = (xe >>> 28 | je << 32 - 28) ^ (je >>> 34 - 32 | xe << 32 - (34 - 32)) ^ (je >>> 39 - 32 | xe << 32 - (39 - 32)), I = (je >>> 28 | xe << 32 - 28) ^ (xe >>> 34 - 32 | je << 32 - (34 - 32)) ^ (xe >>> 39 - 32 | je << 32 - (39 - 32)), G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, P = xe & Pe ^ xe & Ue ^ Pe & Ue, I = je & Re ^ je & Le ^ Re & Le, G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, we = M & 65535 | z << 16, ye = G & 65535 | R << 16, P = be, I = me, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = ae, I = he, G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, be = M & 65535 | z << 16, me = G & 65535 | R << 16, Pe = E, Ue = L, Ie = Y, y = be, Ce = se, ke = Me, De = ue, xe = we, Re = ve, Le = Oe, tt = Ae, Ve = me, Xe = Se, Je = Ee, Qe = le, je = ye, de % 16 === 15)
            for (ie = 0; ie < 16; ie++)
              P = c[ie], I = _[ie], G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = c[(ie + 9) % 16], I = _[(ie + 9) % 16], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, ae = c[(ie + 1) % 16], he = _[(ie + 1) % 16], P = (ae >>> 1 | he << 32 - 1) ^ (ae >>> 8 | he << 32 - 8) ^ ae >>> 7, I = (he >>> 1 | ae << 32 - 1) ^ (he >>> 8 | ae << 32 - 8) ^ (he >>> 7 | ae << 32 - 7), G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, ae = c[(ie + 14) % 16], he = _[(ie + 14) % 16], P = (ae >>> 19 | he << 32 - 19) ^ (he >>> 61 - 32 | ae << 32 - (61 - 32)) ^ ae >>> 6, I = (he >>> 19 | ae << 32 - 19) ^ (ae >>> 61 - 32 | he << 32 - (61 - 32)) ^ (he >>> 6 | ae << 32 - 6), G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, c[ie] = M & 65535 | z << 16, _[ie] = G & 65535 | R << 16;
        P = xe, I = je, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[0], I = a[0], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[0] = xe = M & 65535 | z << 16, a[0] = je = G & 65535 | R << 16, P = Pe, I = Re, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[1], I = a[1], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[1] = Pe = M & 65535 | z << 16, a[1] = Re = G & 65535 | R << 16, P = Ue, I = Le, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[2], I = a[2], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[2] = Ue = M & 65535 | z << 16, a[2] = Le = G & 65535 | R << 16, P = Ie, I = tt, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[3], I = a[3], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[3] = Ie = M & 65535 | z << 16, a[3] = tt = G & 65535 | R << 16, P = y, I = Ve, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[4], I = a[4], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[4] = y = M & 65535 | z << 16, a[4] = Ve = G & 65535 | R << 16, P = Ce, I = Xe, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[5], I = a[5], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[5] = Ce = M & 65535 | z << 16, a[5] = Xe = G & 65535 | R << 16, P = ke, I = Je, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[6], I = a[6], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[6] = ke = M & 65535 | z << 16, a[6] = Je = G & 65535 | R << 16, P = De, I = Qe, G = I & 65535, R = I >>> 16, M = P & 65535, z = P >>> 16, P = o[7], I = a[7], G += I & 65535, R += I >>> 16, M += P & 65535, z += P >>> 16, R += G >>> 16, M += R >>> 16, z += M >>> 16, o[7] = De = M & 65535 | z << 16, a[7] = Qe = G & 65535 | R << 16, nt += 128, n -= 128;
      }
      return n;
    }
    function Fe(o, a, f) {
      var n = new Int32Array(8), c = new Int32Array(8), _ = new Uint8Array(256), E, L = f;
      for (n[0] = 1779033703, n[1] = 3144134277, n[2] = 1013904242, n[3] = 2773480762, n[4] = 1359893119, n[5] = 2600822924, n[6] = 528734635, n[7] = 1541459225, c[0] = 4089235720, c[1] = 2227873595, c[2] = 4271175723, c[3] = 1595750129, c[4] = 2917565137, c[5] = 725511199, c[6] = 4215389547, c[7] = 327033209, Ze(n, c, a, f), f %= 128, E = 0; E < f; E++)
        _[E] = a[L - f + E];
      for (_[f] = 128, f = 256 - 128 * (f < 112 ? 1 : 0), _[f - 9] = 0, $(_, f - 8, L / 536870912 | 0, L << 3), Ze(n, c, _, f), E = 0; E < 8; E++)
        $(o, 8 * E, n[E], c[E]);
      return 0;
    }
    function rt(o, a) {
      var f = r(), n = r(), c = r(), _ = r(), E = r(), L = r(), Y = r(), be = r(), se = r();
      ee(f, o[1], o[0]), ee(se, a[1], a[0]), q(f, f, se), ne(n, o[0], o[1]), ne(se, a[0], a[1]), q(n, n, se), q(c, o[3], a[3]), q(c, c, B), q(_, o[2], a[2]), ne(_, _, _), ee(E, n, f), ee(L, _, c), ne(Y, _, c), ne(be, n, f), q(o[0], E, L), q(o[1], be, Y), q(o[2], Y, L), q(o[3], E, be);
    }
    function bt(o, a, f) {
      var n;
      for (n = 0; n < 4; n++)
        F(o[n], a[n], f);
    }
    function wt(o, a) {
      var f = r(), n = r(), c = r();
      Ke(c, a[2]), q(f, a[0], c), q(n, a[1], c), T(o, n), o[31] ^= k(f) << 7;
    }
    function Ot(o, a, f) {
      var n, c;
      for (K(o[0], u), K(o[1], b), K(o[2], b), K(o[3], u), c = 255; c >= 0; --c)
        n = f[c / 8 | 0] >> (c & 7) & 1, bt(o, a, n), rt(a, o), rt(o, o), bt(o, a, n);
    }
    function Pt(o, a) {
      var f = [r(), r(), r(), r()];
      K(f[0], w), K(f[1], O), K(f[2], b), q(f[3], w, O), Ot(o, f, a);
    }
    function _t(o, a, f) {
      var n = new Uint8Array(64), c = [r(), r(), r(), r()], _;
      for (f || i(a, 32), Fe(n, a, 32), n[0] &= 248, n[31] &= 127, n[31] |= 64, Pt(c, n), wt(o, c), _ = 0; _ < 32; _++)
        a[_ + 32] = o[_];
      return 0;
    }
    var Lt = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function At(o, a) {
      var f, n, c, _;
      for (n = 63; n >= 32; --n) {
        for (f = 0, c = n - 32, _ = n - 12; c < _; ++c)
          a[c] += f - 16 * a[n] * Lt[c - (n - 32)], f = Math.floor((a[c] + 128) / 256), a[c] -= f * 256;
        a[c] += f, a[n] = 0;
      }
      for (f = 0, c = 0; c < 32; c++)
        a[c] += f - (a[31] >> 4) * Lt[c], f = a[c] >> 8, a[c] &= 255;
      for (c = 0; c < 32; c++)
        a[c] -= f * Lt[c];
      for (n = 0; n < 32; n++)
        a[n + 1] += a[n] >> 8, o[n] = a[n] & 255;
    }
    function It(o) {
      var a = new Float64Array(64), f;
      for (f = 0; f < 64; f++)
        a[f] = o[f];
      for (f = 0; f < 64; f++)
        o[f] = 0;
      At(o, a);
    }
    function ur(o, a, f, n) {
      var c = new Uint8Array(64), _ = new Uint8Array(64), E = new Uint8Array(64), L, Y, be = new Float64Array(64), se = [r(), r(), r(), r()];
      Fe(c, n, 32), c[0] &= 248, c[31] &= 127, c[31] |= 64;
      var Me = f + 64;
      for (L = 0; L < f; L++)
        o[64 + L] = a[L];
      for (L = 0; L < 32; L++)
        o[32 + L] = c[32 + L];
      for (Fe(E, o.subarray(32), f + 32), It(E), Pt(se, E), wt(o, se), L = 32; L < 64; L++)
        o[L] = n[L];
      for (Fe(_, o, f + 64), It(_), L = 0; L < 64; L++)
        be[L] = 0;
      for (L = 0; L < 32; L++)
        be[L] = E[L];
      for (L = 0; L < 32; L++)
        for (Y = 0; Y < 32; Y++)
          be[L + Y] += _[L] * c[Y];
      return At(o.subarray(32), be), Me;
    }
    function vt(o, a) {
      var f = r(), n = r(), c = r(), _ = r(), E = r(), L = r(), Y = r();
      return K(o[2], b), re(o[1], a), fe(c, o[1]), q(_, c, p), ee(c, c, o[2]), ne(_, o[2], _), fe(E, _), fe(L, E), q(Y, L, E), q(f, Y, c), q(f, f, _), _e(f, f), q(f, f, c), q(f, f, _), q(f, f, _), q(o[0], f, _), fe(n, o[0]), q(n, n, _), C(n, c) && q(o[0], o[0], U), fe(n, o[0]), q(n, n, _), C(n, c) ? -1 : (k(o[0]) === a[31] >> 7 && ee(o[0], u, o[0]), q(o[3], o[0], o[1]), 0);
    }
    function Ut(o, a, f, n) {
      var c, _ = new Uint8Array(32), E = new Uint8Array(64), L = [r(), r(), r(), r()], Y = [r(), r(), r(), r()];
      if (f < 64 || vt(Y, n))
        return -1;
      for (c = 0; c < f; c++)
        o[c] = a[c];
      for (c = 0; c < 32; c++)
        o[c + 32] = n[c];
      if (Fe(E, o, f), It(E), Ot(L, Y, E), Pt(Y, a.subarray(32)), rt(L, Y), wt(_, L), f -= 64, pe(a, 0, _, 0)) {
        for (c = 0; c < f; c++)
          o[c] = 0;
        return -1;
      }
      for (c = 0; c < f; c++)
        o[c] = a[c + 64];
      return f;
    }
    var Mt = 32, Zt = 24, kt = 32, Qt = 16, lr = 32, vr = 32, hr = 32, dr = 32, Gr = 32, Zn = Zt, Xo = kt, Jo = Qt, Ct = 64, Ft = 32, er = 64, Vr = 32, qr = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: V,
      crypto_stream_xor: H,
      crypto_stream: X,
      crypto_stream_salsa20_xor: j,
      crypto_stream_salsa20: W,
      crypto_onetimeauth: x,
      crypto_onetimeauth_verify: A,
      crypto_verify_16: Z,
      crypto_verify_32: pe,
      crypto_secretbox: Q,
      crypto_secretbox_open: J,
      crypto_scalarmult: ge,
      crypto_scalarmult_base: qe,
      crypto_box_beforenm: et,
      crypto_box_afternm: te,
      crypto_box: Te,
      crypto_box_open: Ge,
      crypto_box_keypair: We,
      crypto_hash: Fe,
      crypto_sign: ur,
      crypto_sign_keypair: _t,
      crypto_sign_open: Ut,
      crypto_secretbox_KEYBYTES: Mt,
      crypto_secretbox_NONCEBYTES: Zt,
      crypto_secretbox_ZEROBYTES: kt,
      crypto_secretbox_BOXZEROBYTES: Qt,
      crypto_scalarmult_BYTES: lr,
      crypto_scalarmult_SCALARBYTES: vr,
      crypto_box_PUBLICKEYBYTES: hr,
      crypto_box_SECRETKEYBYTES: dr,
      crypto_box_BEFORENMBYTES: Gr,
      crypto_box_NONCEBYTES: Zn,
      crypto_box_ZEROBYTES: Xo,
      crypto_box_BOXZEROBYTES: Jo,
      crypto_sign_BYTES: Ct,
      crypto_sign_PUBLICKEYBYTES: Ft,
      crypto_sign_SECRETKEYBYTES: er,
      crypto_sign_SEEDBYTES: Vr,
      crypto_hash_BYTES: qr,
      gf: r,
      D: p,
      L: Lt,
      pack25519: T,
      unpack25519: re,
      M: q,
      A: ne,
      S: fe,
      Z: ee,
      pow2523: _e,
      add: rt,
      set25519: K,
      modL: At,
      scalarmult: Ot,
      scalarbase: Pt
    };
    function Fn(o, a) {
      if (o.length !== Mt)
        throw new Error("bad key size");
      if (a.length !== Zt)
        throw new Error("bad nonce size");
    }
    function Qo(o, a) {
      if (o.length !== hr)
        throw new Error("bad public key size");
      if (a.length !== dr)
        throw new Error("bad secret key size");
    }
    function pt() {
      for (var o = 0; o < arguments.length; o++)
        if (!(arguments[o] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Xn(o) {
      for (var a = 0; a < o.length; a++)
        o[a] = 0;
    }
    t.randomBytes = function(o) {
      var a = new Uint8Array(o);
      return i(a, o), a;
    }, t.secretbox = function(o, a, f) {
      pt(o, a, f), Fn(f, a);
      for (var n = new Uint8Array(kt + o.length), c = new Uint8Array(n.length), _ = 0; _ < o.length; _++)
        n[_ + kt] = o[_];
      return Q(c, n, n.length, a, f), c.subarray(Qt);
    }, t.secretbox.open = function(o, a, f) {
      pt(o, a, f), Fn(f, a);
      for (var n = new Uint8Array(Qt + o.length), c = new Uint8Array(n.length), _ = 0; _ < o.length; _++)
        n[_ + Qt] = o[_];
      return n.length < 32 || J(c, n, n.length, a, f) !== 0 ? null : c.subarray(kt);
    }, t.secretbox.keyLength = Mt, t.secretbox.nonceLength = Zt, t.secretbox.overheadLength = Qt, t.scalarMult = function(o, a) {
      if (pt(o, a), o.length !== vr)
        throw new Error("bad n size");
      if (a.length !== lr)
        throw new Error("bad p size");
      var f = new Uint8Array(lr);
      return ge(f, o, a), f;
    }, t.scalarMult.base = function(o) {
      if (pt(o), o.length !== vr)
        throw new Error("bad n size");
      var a = new Uint8Array(lr);
      return qe(a, o), a;
    }, t.scalarMult.scalarLength = vr, t.scalarMult.groupElementLength = lr, t.box = function(o, a, f, n) {
      var c = t.box.before(f, n);
      return t.secretbox(o, a, c);
    }, t.box.before = function(o, a) {
      pt(o, a), Qo(o, a);
      var f = new Uint8Array(Gr);
      return et(f, o, a), f;
    }, t.box.after = t.secretbox, t.box.open = function(o, a, f, n) {
      var c = t.box.before(f, n);
      return t.secretbox.open(o, a, c);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var o = new Uint8Array(hr), a = new Uint8Array(dr);
      return We(o, a), { publicKey: o, secretKey: a };
    }, t.box.keyPair.fromSecretKey = function(o) {
      if (pt(o), o.length !== dr)
        throw new Error("bad secret key size");
      var a = new Uint8Array(hr);
      return qe(a, o), { publicKey: a, secretKey: new Uint8Array(o) };
    }, t.box.publicKeyLength = hr, t.box.secretKeyLength = dr, t.box.sharedKeyLength = Gr, t.box.nonceLength = Zn, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(o, a) {
      if (pt(o, a), a.length !== er)
        throw new Error("bad secret key size");
      var f = new Uint8Array(Ct + o.length);
      return ur(f, o, o.length, a), f;
    }, t.sign.open = function(o, a) {
      if (pt(o, a), a.length !== Ft)
        throw new Error("bad public key size");
      var f = new Uint8Array(o.length), n = Ut(f, o, o.length, a);
      if (n < 0)
        return null;
      for (var c = new Uint8Array(n), _ = 0; _ < c.length; _++)
        c[_] = f[_];
      return c;
    }, t.sign.detached = function(o, a) {
      for (var f = t.sign(o, a), n = new Uint8Array(Ct), c = 0; c < n.length; c++)
        n[c] = f[c];
      return n;
    }, t.sign.detached.verify = function(o, a, f) {
      if (pt(o, a, f), a.length !== Ct)
        throw new Error("bad signature size");
      if (f.length !== Ft)
        throw new Error("bad public key size");
      var n = new Uint8Array(Ct + o.length), c = new Uint8Array(Ct + o.length), _;
      for (_ = 0; _ < Ct; _++)
        n[_] = a[_];
      for (_ = 0; _ < o.length; _++)
        n[_ + Ct] = o[_];
      return Ut(c, n, n.length, f) >= 0;
    }, t.sign.keyPair = function() {
      var o = new Uint8Array(Ft), a = new Uint8Array(er);
      return _t(o, a), { publicKey: o, secretKey: a };
    }, t.sign.keyPair.fromSecretKey = function(o) {
      if (pt(o), o.length !== er)
        throw new Error("bad secret key size");
      for (var a = new Uint8Array(Ft), f = 0; f < a.length; f++)
        a[f] = o[32 + f];
      return { publicKey: a, secretKey: new Uint8Array(o) };
    }, t.sign.keyPair.fromSeed = function(o) {
      if (pt(o), o.length !== Vr)
        throw new Error("bad seed size");
      for (var a = new Uint8Array(Ft), f = new Uint8Array(er), n = 0; n < 32; n++)
        f[n] = o[n];
      return _t(a, f, !0), { publicKey: a, secretKey: f };
    }, t.sign.publicKeyLength = Ft, t.sign.secretKeyLength = er, t.sign.seedLength = Vr, t.sign.signatureLength = Ct, t.hash = function(o) {
      pt(o);
      var a = new Uint8Array(qr);
      return Fe(a, o, o.length), a;
    }, t.hash.hashLength = qr, t.verify = function(o, a) {
      return pt(o, a), o.length === 0 || a.length === 0 || o.length !== a.length ? !1 : D(o, 0, a, 0, o.length) === 0;
    }, t.setPRNG = function(o) {
      i = o;
    }, function() {
      var o = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (o && o.getRandomValues) {
        var a = 65536;
        t.setPRNG(function(f, n) {
          var c, _ = new Uint8Array(n);
          for (c = 0; c < n; c += a)
            o.getRandomValues(_.subarray(c, c + Math.min(n - c, a)));
          for (c = 0; c < n; c++)
            f[c] = _[c];
          Xn(_);
        });
      } else
        typeof Va < "u" && (o = Ya, o && o.randomBytes && t.setPRNG(function(f, n) {
          var c, _ = o.randomBytes(n);
          for (c = 0; c < n; c++)
            f[c] = _[c];
          Xn(_);
        }));
    }();
  })(e.exports ? e.exports : self.nacl = self.nacl || {});
})(To);
var Wa = Object.create, Mr = Object.defineProperty, Za = Object.getOwnPropertyDescriptor, Fa = Object.getOwnPropertyNames, Xa = Object.getPrototypeOf, Ja = Object.prototype.hasOwnProperty, Qa = (e, t) => {
  for (var r in t)
    Mr(e, r, { get: t[r], enumerable: !0 });
}, Oo = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of Fa(t))
      !Ja.call(e, s) && s !== r && Mr(e, s, { get: () => t[s], enumerable: !(i = Za(t, s)) || i.enumerable });
  return e;
}, ec = (e, t, r) => (r = e != null ? Wa(Xa(e)) : {}, Oo(
  t || !e || !e.__esModule ? Mr(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), tc = (e) => Oo(Mr({}, "__esModule", { value: !0 }), e), Po = {};
Qa(Po, {
  Ed25519PublicKey: () => Io
});
var rc = tc(Po), nc = Bt, fi = _r, ai = ar, ic = ec(To.exports);
const hn = 32;
class Io extends fi.PublicKey {
  constructor(t) {
    if (super(), typeof t == "string" ? this.data = (0, nc.fromB64)(t) : t instanceof Uint8Array ? this.data = t : this.data = Uint8Array.from(t), this.data.length !== hn)
      throw new Error(
        `Invalid public key input. Expected ${hn} bytes, got ${this.data.length}`
      );
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return ai.SIGNATURE_SCHEME_TO_FLAG.ED25519;
  }
  async verify(t, r) {
    let i;
    if (typeof r == "string") {
      const s = (0, ai.parseSerializedSignature)(r);
      if (s.signatureScheme !== "ED25519")
        throw new Error("Invalid signature scheme");
      if (!(0, fi.bytesEqual)(this.toRawBytes(), s.publicKey))
        throw new Error("Signature does not match public key");
      i = s.signature;
    } else
      i = r;
    return ic.default.sign.detached.verify(t, i, this.toRawBytes());
  }
}
Io.SIZE = hn;
var Uo = {}, $e = {}, Be = {};
Object.defineProperty(Be, "__esModule", { value: !0 });
Be.validateObject = Be.createHmacDrbg = Be.bitMask = Be.bitSet = Be.bitGet = Be.bitLen = Be.utf8ToBytes = Be.equalBytes = Be.concatBytes = Be.ensureBytes = Be.numberToVarBytesBE = Be.numberToBytesLE = Be.numberToBytesBE = Be.bytesToNumberLE = Be.bytesToNumberBE = Be.hexToBytes = Be.hexToNumber = Be.numberToHexUnpadded = Be.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const jo = BigInt(0), kr = BigInt(1), oc = BigInt(2), Dr = (e) => e instanceof Uint8Array, sc = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Gn(e) {
  if (!Dr(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += sc[e[r]];
  return t;
}
Be.bytesToHex = Gn;
function No(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
Be.numberToHexUnpadded = No;
function Vn(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
Be.hexToNumber = Vn;
function Hr(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(t / 2);
  for (let i = 0; i < r.length; i++) {
    const s = i * 2, h = e.slice(s, s + 2), u = Number.parseInt(h, 16);
    if (Number.isNaN(u) || u < 0)
      throw new Error("Invalid byte sequence");
    r[i] = u;
  }
  return r;
}
Be.hexToBytes = Hr;
function fc(e) {
  return Vn(Gn(e));
}
Be.bytesToNumberBE = fc;
function ac(e) {
  if (!Dr(e))
    throw new Error("Uint8Array expected");
  return Vn(Gn(Uint8Array.from(e).reverse()));
}
Be.bytesToNumberLE = ac;
function $o(e, t) {
  return Hr(e.toString(16).padStart(t * 2, "0"));
}
Be.numberToBytesBE = $o;
function cc(e, t) {
  return $o(e, t).reverse();
}
Be.numberToBytesLE = cc;
function uc(e) {
  return Hr(No(e));
}
Be.numberToVarBytesBE = uc;
function lc(e, t, r) {
  let i;
  if (typeof t == "string")
    try {
      i = Hr(t);
    } catch (h) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${h}`);
    }
  else if (Dr(t))
    i = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const s = i.length;
  if (typeof r == "number" && s !== r)
    throw new Error(`${e} expected ${r} bytes, got ${s}`);
  return i;
}
Be.ensureBytes = lc;
function Co(...e) {
  const t = new Uint8Array(e.reduce((i, s) => i + s.length, 0));
  let r = 0;
  return e.forEach((i) => {
    if (!Dr(i))
      throw new Error("Uint8Array expected");
    t.set(i, r), r += i.length;
  }), t;
}
Be.concatBytes = Co;
function hc(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
Be.equalBytes = hc;
function dc(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
Be.utf8ToBytes = dc;
function bc(e) {
  let t;
  for (t = 0; e > jo; e >>= kr, t += 1)
    ;
  return t;
}
Be.bitLen = bc;
function yc(e, t) {
  return e >> BigInt(t) & kr;
}
Be.bitGet = yc;
const pc = (e, t, r) => e | (r ? kr : jo) << BigInt(t);
Be.bitSet = pc;
const gc = (e) => (oc << BigInt(e - 1)) - kr;
Be.bitMask = gc;
const en = (e) => new Uint8Array(e), ci = (e) => Uint8Array.from(e);
function xc(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let i = en(e), s = en(e), h = 0;
  const u = () => {
    i.fill(1), s.fill(0), h = 0;
  }, b = (...w) => r(s, i, ...w), l = (w = en()) => {
    s = b(ci([0]), w), i = b(), w.length !== 0 && (s = b(ci([1]), w), i = b());
  }, p = () => {
    if (h++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let w = 0;
    const O = [];
    for (; w < t; ) {
      i = b();
      const U = i.slice();
      O.push(U), w += i.length;
    }
    return Co(...O);
  };
  return (w, O) => {
    u(), l(w);
    let U;
    for (; !(U = O(p())); )
      l();
    return u(), U;
  };
}
Be.createHmacDrbg = xc;
const wc = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function _c(e, t, r = {}) {
  const i = (s, h, u) => {
    const b = wc[h];
    if (typeof b != "function")
      throw new Error(`Invalid validator "${h}", expected function`);
    const l = e[s];
    if (!(u && l === void 0) && !b(l, e))
      throw new Error(`Invalid param ${String(s)}=${l} (${typeof l}), expected ${h}`);
  };
  for (const [s, h] of Object.entries(t))
    i(s, h, !1);
  for (const [s, h] of Object.entries(r))
    i(s, h, !0);
  return e;
}
Be.validateObject = _c;
Object.defineProperty($e, "__esModule", { value: !0 });
$e.hashToPrivateScalar = $e.FpSqrtEven = $e.FpSqrtOdd = $e.Field = $e.nLength = $e.FpIsSquare = $e.FpDiv = $e.FpInvertBatch = $e.FpPow = $e.validateField = $e.isNegativeLE = $e.FpSqrt = $e.tonelliShanks = $e.invert = $e.pow2 = $e.pow = $e.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Rt = Be, st = BigInt(0), Ye = BigInt(1), Yt = BigInt(2), vc = BigInt(3), dn = BigInt(4), ui = BigInt(5), li = BigInt(8);
BigInt(9);
BigInt(16);
function Et(e, t) {
  const r = e % t;
  return r >= st ? r : t + r;
}
$e.mod = Et;
function Ro(e, t, r) {
  if (r <= st || t < st)
    throw new Error("Expected power/modulo > 0");
  if (r === Ye)
    return st;
  let i = Ye;
  for (; t > st; )
    t & Ye && (i = i * e % r), e = e * e % r, t >>= Ye;
  return i;
}
$e.pow = Ro;
function mc(e, t, r) {
  let i = e;
  for (; t-- > st; )
    i *= i, i %= r;
  return i;
}
$e.pow2 = mc;
function Or(e, t) {
  if (e === st || t <= st)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Et(e, t), i = t, s = st, h = Ye;
  for (; r !== st; ) {
    const b = i / r, l = i % r, p = s - h * b;
    i = r, r = l, s = h, h = p;
  }
  if (i !== Ye)
    throw new Error("invert: does not exist");
  return Et(s, t);
}
$e.invert = Or;
function Lo(e) {
  const t = (e - Ye) / Yt;
  let r, i, s;
  for (r = e - Ye, i = 0; r % Yt === st; r /= Yt, i++)
    ;
  for (s = Yt; s < e && Ro(s, t, e) !== e - Ye; s++)
    ;
  if (i === 1) {
    const u = (e + Ye) / dn;
    return function(l, p) {
      const B = l.pow(p, u);
      if (!l.eql(l.sqr(B), p))
        throw new Error("Cannot find square root");
      return B;
    };
  }
  const h = (r + Ye) / Yt;
  return function(b, l) {
    if (b.pow(l, t) === b.neg(b.ONE))
      throw new Error("Cannot find square root");
    let p = i, B = b.pow(b.mul(b.ONE, s), r), w = b.pow(l, h), O = b.pow(l, r);
    for (; !b.eql(O, b.ONE); ) {
      if (b.eql(O, b.ZERO))
        return b.ZERO;
      let U = 1;
      for (let D = b.sqr(O); U < p && !b.eql(D, b.ONE); U++)
        D = b.sqr(D);
      const $ = b.pow(B, Ye << BigInt(p - U - 1));
      B = b.sqr($), w = b.mul(w, $), O = b.mul(O, B), p = U;
    }
    return w;
  };
}
$e.tonelliShanks = Lo;
function Mo(e) {
  if (e % dn === vc) {
    const t = (e + Ye) / dn;
    return function(i, s) {
      const h = i.pow(s, t);
      if (!i.eql(i.sqr(h), s))
        throw new Error("Cannot find square root");
      return h;
    };
  }
  if (e % li === ui) {
    const t = (e - ui) / li;
    return function(i, s) {
      const h = i.mul(s, Yt), u = i.pow(h, t), b = i.mul(s, u), l = i.mul(i.mul(b, Yt), u), p = i.mul(b, i.sub(l, i.ONE));
      if (!i.eql(i.sqr(p), s))
        throw new Error("Cannot find square root");
      return p;
    };
  }
  return Lo(e);
}
$e.FpSqrt = Mo;
const Ec = (e, t) => (Et(e, t) & Ye) === Ye;
$e.isNegativeLE = Ec;
const Sc = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Bc(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = Sc.reduce((i, s) => (i[s] = "function", i), t);
  return (0, Rt.validateObject)(e, r);
}
$e.validateField = Bc;
function ko(e, t, r) {
  if (r < st)
    throw new Error("Expected power > 0");
  if (r === st)
    return e.ONE;
  if (r === Ye)
    return t;
  let i = e.ONE, s = t;
  for (; r > st; )
    r & Ye && (i = e.mul(i, s)), s = e.sqr(s), r >>= Ye;
  return i;
}
$e.FpPow = ko;
function Do(e, t) {
  const r = new Array(t.length), i = t.reduce((h, u, b) => e.is0(u) ? h : (r[b] = h, e.mul(h, u)), e.ONE), s = e.inv(i);
  return t.reduceRight((h, u, b) => e.is0(u) ? h : (r[b] = e.mul(h, r[b]), e.mul(h, u)), s), r;
}
$e.FpInvertBatch = Do;
function Ac(e, t, r) {
  return e.mul(t, typeof r == "bigint" ? Or(r, e.ORDER) : e.inv(r));
}
$e.FpDiv = Ac;
function Tc(e) {
  const t = (e.ORDER - Ye) / Yt;
  return (r) => {
    const i = e.pow(r, t);
    return e.eql(i, e.ZERO) || e.eql(i, e.ONE);
  };
}
$e.FpIsSquare = Tc;
function qn(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, i = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: i };
}
$e.nLength = qn;
function Oc(e, t, r = !1, i = {}) {
  if (e <= st)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: s, nByteLength: h } = qn(e, t);
  if (h > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const u = Mo(e), b = Object.freeze({
    ORDER: e,
    BITS: s,
    BYTES: h,
    MASK: (0, Rt.bitMask)(s),
    ZERO: st,
    ONE: Ye,
    create: (l) => Et(l, e),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
      return st <= l && l < e;
    },
    is0: (l) => l === st,
    isOdd: (l) => (l & Ye) === Ye,
    neg: (l) => Et(-l, e),
    eql: (l, p) => l === p,
    sqr: (l) => Et(l * l, e),
    add: (l, p) => Et(l + p, e),
    sub: (l, p) => Et(l - p, e),
    mul: (l, p) => Et(l * p, e),
    pow: (l, p) => ko(b, l, p),
    div: (l, p) => Et(l * Or(p, e), e),
    sqrN: (l) => l * l,
    addN: (l, p) => l + p,
    subN: (l, p) => l - p,
    mulN: (l, p) => l * p,
    inv: (l) => Or(l, e),
    sqrt: i.sqrt || ((l) => u(b, l)),
    invertBatch: (l) => Do(b, l),
    cmov: (l, p, B) => B ? p : l,
    toBytes: (l) => r ? (0, Rt.numberToBytesLE)(l, h) : (0, Rt.numberToBytesBE)(l, h),
    fromBytes: (l) => {
      if (l.length !== h)
        throw new Error(`Fp.fromBytes: expected ${h}, got ${l.length}`);
      return r ? (0, Rt.bytesToNumberLE)(l) : (0, Rt.bytesToNumberBE)(l);
    }
  });
  return Object.freeze(b);
}
$e.Field = Oc;
function Pc(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? r : e.neg(r);
}
$e.FpSqrtOdd = Pc;
function Ic(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? e.neg(r) : r;
}
$e.FpSqrtEven = Ic;
function Uc(e, t, r = !1) {
  e = (0, Rt.ensureBytes)("privateHash", e);
  const i = e.length, s = qn(t).nByteLength + 8;
  if (s < 24 || i < s || i > 1024)
    throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${i}`);
  const h = r ? (0, Rt.bytesToNumberLE)(e) : (0, Rt.bytesToNumberBE)(e);
  return Et(h, t - Ye) + Ye;
}
$e.hashToPrivateScalar = Uc;
var Kr = {}, fr = {};
Object.defineProperty(fr, "__esModule", { value: !0 });
fr.validateBasic = fr.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hi = $e, jc = Be, Nc = BigInt(0), tn = BigInt(1);
function $c(e, t) {
  const r = (s, h) => {
    const u = h.negate();
    return s ? u : h;
  }, i = (s) => {
    const h = Math.ceil(t / s) + 1, u = 2 ** (s - 1);
    return { windows: h, windowSize: u };
  };
  return {
    constTimeNegate: r,
    unsafeLadder(s, h) {
      let u = e.ZERO, b = s;
      for (; h > Nc; )
        h & tn && (u = u.add(b)), b = b.double(), h >>= tn;
      return u;
    },
    precomputeWindow(s, h) {
      const { windows: u, windowSize: b } = i(h), l = [];
      let p = s, B = p;
      for (let w = 0; w < u; w++) {
        B = p, l.push(B);
        for (let O = 1; O < b; O++)
          B = B.add(p), l.push(B);
        p = B.double();
      }
      return l;
    },
    wNAF(s, h, u) {
      const { windows: b, windowSize: l } = i(s);
      let p = e.ZERO, B = e.BASE;
      const w = BigInt(2 ** s - 1), O = 2 ** s, U = BigInt(s);
      for (let $ = 0; $ < b; $++) {
        const D = $ * l;
        let Z = Number(u & w);
        u >>= U, Z > l && (Z -= O, u += tn);
        const pe = D, v = D + Math.abs(Z) - 1, m = $ % 2 !== 0, d = Z < 0;
        Z === 0 ? B = B.add(r(m, h[pe])) : p = p.add(r(d, h[v]));
      }
      return { p, f: B };
    },
    wNAFCached(s, h, u, b) {
      const l = s._WINDOW_SIZE || 1;
      let p = h.get(s);
      return p || (p = this.precomputeWindow(s, l), l !== 1 && h.set(s, b(p))), this.wNAF(l, p, u);
    }
  };
}
fr.wNAF = $c;
function Cc(e) {
  return (0, hi.validateField)(e.Fp), (0, jc.validateObject)(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, hi.nLength)(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
fr.validateBasic = Cc;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.mapToCurveSimpleSWU = e.SWUFpSqrtRatio = e.weierstrass = e.weierstrassPoints = e.DER = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = $e, r = Be, i = Be, s = fr;
  function h(v) {
    const m = (0, s.validateBasic)(v);
    r.validateObject(m, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: d, Fp: V, a: S } = m;
    if (d) {
      if (!V.eql(S, V.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof d != "object" || typeof d.beta != "bigint" || typeof d.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...m });
  }
  const { bytesToNumberBE: u, hexToBytes: b } = r;
  e.DER = {
    Err: class extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(v) {
      const { Err: m } = e.DER;
      if (v.length < 2 || v[0] !== 2)
        throw new m("Invalid signature integer tag");
      const d = v[1], V = v.subarray(2, d + 2);
      if (!d || V.length !== d)
        throw new m("Invalid signature integer: wrong length");
      if (V[0] & 128)
        throw new m("Invalid signature integer: negative");
      if (V[0] === 0 && !(V[1] & 128))
        throw new m("Invalid signature integer: unnecessary leading zero");
      return { d: u(V), l: v.subarray(d + 2) };
    },
    toSig(v) {
      const { Err: m } = e.DER, d = typeof v == "string" ? b(v) : v;
      if (!(d instanceof Uint8Array))
        throw new Error("ui8a expected");
      let V = d.length;
      if (V < 2 || d[0] != 48)
        throw new m("Invalid signature tag");
      if (d[1] !== V - 2)
        throw new m("Invalid signature: incorrect length");
      const { d: S, l: j } = e.DER._parseInt(d.subarray(2)), { d: W, l: X } = e.DER._parseInt(j);
      if (X.length)
        throw new m("Invalid signature: left bytes after parsing");
      return { r: S, s: W };
    },
    hexFromSig(v) {
      const m = (g) => Number.parseInt(g[0], 16) & 8 ? "00" + g : g, d = (g) => {
        const x = g.toString(16);
        return x.length & 1 ? `0${x}` : x;
      }, V = m(d(v.s)), S = m(d(v.r)), j = V.length / 2, W = S.length / 2, X = d(j), H = d(W);
      return `30${d(W + j + 4)}02${H}${S}02${X}${V}`;
    }
  };
  const l = BigInt(0), p = BigInt(1), B = BigInt(2), w = BigInt(3), O = BigInt(4);
  function U(v) {
    const m = h(v), { Fp: d } = m, V = m.toBytes || ((K, N, F) => {
      const T = N.toAffine();
      return r.concatBytes(Uint8Array.from([4]), d.toBytes(T.x), d.toBytes(T.y));
    }), S = m.fromBytes || ((K) => {
      const N = K.subarray(1), F = d.fromBytes(N.subarray(0, d.BYTES)), T = d.fromBytes(N.subarray(d.BYTES, 2 * d.BYTES));
      return { x: F, y: T };
    });
    function j(K) {
      const { a: N, b: F } = m, T = d.sqr(K), C = d.mul(T, K);
      return d.add(d.add(C, d.mul(K, N)), F);
    }
    if (!d.eql(d.sqr(m.Gy), j(m.Gx)))
      throw new Error("bad generator point: equation left != right");
    function W(K) {
      return typeof K == "bigint" && l < K && K < m.n;
    }
    function X(K) {
      if (!W(K))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function H(K) {
      const { allowedPrivateKeyLengths: N, nByteLength: F, wrapPrivateKey: T, n: C } = m;
      if (N && typeof K != "bigint") {
        if (K instanceof Uint8Array && (K = r.bytesToHex(K)), typeof K != "string" || !N.includes(K.length))
          throw new Error("Invalid key");
        K = K.padStart(F * 2, "0");
      }
      let k;
      try {
        k = typeof K == "bigint" ? K : r.bytesToNumberBE((0, i.ensureBytes)("private key", K, F));
      } catch {
        throw new Error(`private key must be ${F} bytes, hex or bigint, not ${typeof K}`);
      }
      return T && (k = t.mod(k, C)), X(k), k;
    }
    const g = /* @__PURE__ */ new Map();
    function x(K) {
      if (!(K instanceof A))
        throw new Error("ProjectivePoint expected");
    }
    class A {
      constructor(N, F, T) {
        if (this.px = N, this.py = F, this.pz = T, N == null || !d.isValid(N))
          throw new Error("x required");
        if (F == null || !d.isValid(F))
          throw new Error("y required");
        if (T == null || !d.isValid(T))
          throw new Error("z required");
      }
      static fromAffine(N) {
        const { x: F, y: T } = N || {};
        if (!N || !d.isValid(F) || !d.isValid(T))
          throw new Error("invalid affine point");
        if (N instanceof A)
          throw new Error("projective point not allowed");
        const C = (k) => d.eql(k, d.ZERO);
        return C(F) && C(T) ? A.ZERO : new A(F, T, d.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(N) {
        const F = d.invertBatch(N.map((T) => T.pz));
        return N.map((T, C) => T.toAffine(F[C])).map(A.fromAffine);
      }
      static fromHex(N) {
        const F = A.fromAffine(S((0, i.ensureBytes)("pointHex", N)));
        return F.assertValidity(), F;
      }
      static fromPrivateKey(N) {
        return A.BASE.multiply(H(N));
      }
      _setWindowSize(N) {
        this._WINDOW_SIZE = N, g.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (m.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: N, y: F } = this.toAffine();
        if (!d.isValid(N) || !d.isValid(F))
          throw new Error("bad point: x or y not FE");
        const T = d.sqr(F), C = j(N);
        if (!d.eql(T, C))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: N } = this.toAffine();
        if (d.isOdd)
          return !d.isOdd(N);
        throw new Error("Field doesn't support isOdd");
      }
      equals(N) {
        x(N);
        const { px: F, py: T, pz: C } = this, { px: k, py: re, pz: ne } = N, ee = d.eql(d.mul(F, ne), d.mul(k, C)), q = d.eql(d.mul(T, ne), d.mul(re, C));
        return ee && q;
      }
      negate() {
        return new A(this.px, d.neg(this.py), this.pz);
      }
      double() {
        const { a: N, b: F } = m, T = d.mul(F, w), { px: C, py: k, pz: re } = this;
        let ne = d.ZERO, ee = d.ZERO, q = d.ZERO, fe = d.mul(C, C), Ke = d.mul(k, k), _e = d.mul(re, re), ge = d.mul(C, k);
        return ge = d.add(ge, ge), q = d.mul(C, re), q = d.add(q, q), ne = d.mul(N, q), ee = d.mul(T, _e), ee = d.add(ne, ee), ne = d.sub(Ke, ee), ee = d.add(Ke, ee), ee = d.mul(ne, ee), ne = d.mul(ge, ne), q = d.mul(T, q), _e = d.mul(N, _e), ge = d.sub(fe, _e), ge = d.mul(N, ge), ge = d.add(ge, q), q = d.add(fe, fe), fe = d.add(q, fe), fe = d.add(fe, _e), fe = d.mul(fe, ge), ee = d.add(ee, fe), _e = d.mul(k, re), _e = d.add(_e, _e), fe = d.mul(_e, ge), ne = d.sub(ne, fe), q = d.mul(_e, Ke), q = d.add(q, q), q = d.add(q, q), new A(ne, ee, q);
      }
      add(N) {
        x(N);
        const { px: F, py: T, pz: C } = this, { px: k, py: re, pz: ne } = N;
        let ee = d.ZERO, q = d.ZERO, fe = d.ZERO;
        const Ke = m.a, _e = d.mul(m.b, w);
        let ge = d.mul(F, k), qe = d.mul(T, re), We = d.mul(C, ne), et = d.add(F, T), te = d.add(k, re);
        et = d.mul(et, te), te = d.add(ge, qe), et = d.sub(et, te), te = d.add(F, C);
        let ce = d.add(k, ne);
        return te = d.mul(te, ce), ce = d.add(ge, We), te = d.sub(te, ce), ce = d.add(T, C), ee = d.add(re, ne), ce = d.mul(ce, ee), ee = d.add(qe, We), ce = d.sub(ce, ee), fe = d.mul(Ke, te), ee = d.mul(_e, We), fe = d.add(ee, fe), ee = d.sub(qe, fe), fe = d.add(qe, fe), q = d.mul(ee, fe), qe = d.add(ge, ge), qe = d.add(qe, ge), We = d.mul(Ke, We), te = d.mul(_e, te), qe = d.add(qe, We), We = d.sub(ge, We), We = d.mul(Ke, We), te = d.add(te, We), ge = d.mul(qe, te), q = d.add(q, ge), ge = d.mul(ce, te), ee = d.mul(et, ee), ee = d.sub(ee, ge), ge = d.mul(et, qe), fe = d.mul(ce, fe), fe = d.add(fe, ge), new A(ee, q, fe);
      }
      subtract(N) {
        return this.add(N.negate());
      }
      is0() {
        return this.equals(A.ZERO);
      }
      wNAF(N) {
        return J.wNAFCached(this, g, N, (F) => {
          const T = d.invertBatch(F.map((C) => C.pz));
          return F.map((C, k) => C.toAffine(T[k])).map(A.fromAffine);
        });
      }
      multiplyUnsafe(N) {
        const F = A.ZERO;
        if (N === l)
          return F;
        if (X(N), N === p)
          return this;
        const { endo: T } = m;
        if (!T)
          return J.unsafeLadder(this, N);
        let { k1neg: C, k1: k, k2neg: re, k2: ne } = T.splitScalar(N), ee = F, q = F, fe = this;
        for (; k > l || ne > l; )
          k & p && (ee = ee.add(fe)), ne & p && (q = q.add(fe)), fe = fe.double(), k >>= p, ne >>= p;
        return C && (ee = ee.negate()), re && (q = q.negate()), q = new A(d.mul(q.px, T.beta), q.py, q.pz), ee.add(q);
      }
      multiply(N) {
        X(N);
        let F = N, T, C;
        const { endo: k } = m;
        if (k) {
          const { k1neg: re, k1: ne, k2neg: ee, k2: q } = k.splitScalar(F);
          let { p: fe, f: Ke } = this.wNAF(ne), { p: _e, f: ge } = this.wNAF(q);
          fe = J.constTimeNegate(re, fe), _e = J.constTimeNegate(ee, _e), _e = new A(d.mul(_e.px, k.beta), _e.py, _e.pz), T = fe.add(_e), C = Ke.add(ge);
        } else {
          const { p: re, f: ne } = this.wNAF(F);
          T = re, C = ne;
        }
        return A.normalizeZ([T, C])[0];
      }
      multiplyAndAddUnsafe(N, F, T) {
        const C = A.BASE, k = (ne, ee) => ee === l || ee === p || !ne.equals(C) ? ne.multiplyUnsafe(ee) : ne.multiply(ee), re = k(this, F).add(k(N, T));
        return re.is0() ? void 0 : re;
      }
      toAffine(N) {
        const { px: F, py: T, pz: C } = this, k = this.is0();
        N == null && (N = k ? d.ONE : d.inv(C));
        const re = d.mul(F, N), ne = d.mul(T, N), ee = d.mul(C, N);
        if (k)
          return { x: d.ZERO, y: d.ZERO };
        if (!d.eql(ee, d.ONE))
          throw new Error("invZ was invalid");
        return { x: re, y: ne };
      }
      isTorsionFree() {
        const { h: N, isTorsionFree: F } = m;
        if (N === p)
          return !0;
        if (F)
          return F(A, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: N, clearCofactor: F } = m;
        return N === p ? this : F ? F(A, this) : this.multiplyUnsafe(m.h);
      }
      toRawBytes(N = !0) {
        return this.assertValidity(), V(A, this, N);
      }
      toHex(N = !0) {
        return r.bytesToHex(this.toRawBytes(N));
      }
    }
    A.BASE = new A(m.Gx, m.Gy, d.ONE), A.ZERO = new A(d.ZERO, d.ONE, d.ZERO);
    const Q = m.nBitLength, J = (0, s.wNAF)(A, m.endo ? Math.ceil(Q / 2) : Q);
    return {
      CURVE: m,
      ProjectivePoint: A,
      normPrivateKeyToScalar: H,
      weierstrassEquation: j,
      isWithinCurveOrder: W
    };
  }
  e.weierstrassPoints = U;
  function $(v) {
    const m = (0, s.validateBasic)(v);
    return r.validateObject(m, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...m });
  }
  function D(v) {
    const m = $(v), { Fp: d, n: V } = m, S = d.BYTES + 1, j = 2 * d.BYTES + 1;
    function W(te) {
      return l < te && te < d.ORDER;
    }
    function X(te) {
      return t.mod(te, V);
    }
    function H(te) {
      return t.invert(te, V);
    }
    const { ProjectivePoint: g, normPrivateKeyToScalar: x, weierstrassEquation: A, isWithinCurveOrder: Q } = U({
      ...m,
      toBytes(te, ce, Te) {
        const Ge = ce.toAffine(), He = d.toBytes(Ge.x), Ze = r.concatBytes;
        return Te ? Ze(Uint8Array.from([ce.hasEvenY() ? 2 : 3]), He) : Ze(Uint8Array.from([4]), He, d.toBytes(Ge.y));
      },
      fromBytes(te) {
        const ce = te.length, Te = te[0], Ge = te.subarray(1);
        if (ce === S && (Te === 2 || Te === 3)) {
          const He = r.bytesToNumberBE(Ge);
          if (!W(He))
            throw new Error("Point is not on curve");
          const Ze = A(He);
          let Fe = d.sqrt(Ze);
          const rt = (Fe & p) === p;
          return (Te & 1) === 1 !== rt && (Fe = d.neg(Fe)), { x: He, y: Fe };
        } else if (ce === j && Te === 4) {
          const He = d.fromBytes(Ge.subarray(0, d.BYTES)), Ze = d.fromBytes(Ge.subarray(d.BYTES, 2 * d.BYTES));
          return { x: He, y: Ze };
        } else
          throw new Error(`Point of length ${ce} was invalid. Expected ${S} compressed bytes or ${j} uncompressed bytes`);
      }
    }), J = (te) => r.bytesToHex(r.numberToBytesBE(te, m.nByteLength));
    function K(te) {
      const ce = V >> p;
      return te > ce;
    }
    function N(te) {
      return K(te) ? X(-te) : te;
    }
    const F = (te, ce, Te) => r.bytesToNumberBE(te.slice(ce, Te));
    class T {
      constructor(ce, Te, Ge) {
        this.r = ce, this.s = Te, this.recovery = Ge, this.assertValidity();
      }
      static fromCompact(ce) {
        const Te = m.nByteLength;
        return ce = (0, i.ensureBytes)("compactSignature", ce, Te * 2), new T(F(ce, 0, Te), F(ce, Te, 2 * Te));
      }
      static fromDER(ce) {
        const { r: Te, s: Ge } = e.DER.toSig((0, i.ensureBytes)("DER", ce));
        return new T(Te, Ge);
      }
      assertValidity() {
        if (!Q(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!Q(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(ce) {
        return new T(this.r, this.s, ce);
      }
      recoverPublicKey(ce) {
        const { r: Te, s: Ge, recovery: He } = this, Ze = q((0, i.ensureBytes)("msgHash", ce));
        if (He == null || ![0, 1, 2, 3].includes(He))
          throw new Error("recovery id invalid");
        const Fe = He === 2 || He === 3 ? Te + m.n : Te;
        if (Fe >= d.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const rt = (He & 1) === 0 ? "02" : "03", bt = g.fromHex(rt + J(Fe)), wt = H(Fe), Ot = X(-Ze * wt), Pt = X(Ge * wt), _t = g.BASE.multiplyAndAddUnsafe(bt, Ot, Pt);
        if (!_t)
          throw new Error("point at infinify");
        return _t.assertValidity(), _t;
      }
      hasHighS() {
        return K(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new T(this.r, X(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return r.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return r.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return J(this.r) + J(this.s);
      }
    }
    const C = {
      isValidPrivateKey(te) {
        try {
          return x(te), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: x,
      randomPrivateKey: () => {
        const te = m.randomBytes(d.BYTES + 8), ce = t.hashToPrivateScalar(te, V);
        return r.numberToBytesBE(ce, m.nByteLength);
      },
      precompute(te = 8, ce = g.BASE) {
        return ce._setWindowSize(te), ce.multiply(BigInt(3)), ce;
      }
    };
    function k(te, ce = !0) {
      return g.fromPrivateKey(te).toRawBytes(ce);
    }
    function re(te) {
      const ce = te instanceof Uint8Array, Te = typeof te == "string", Ge = (ce || Te) && te.length;
      return ce ? Ge === S || Ge === j : Te ? Ge === 2 * S || Ge === 2 * j : te instanceof g;
    }
    function ne(te, ce, Te = !0) {
      if (re(te))
        throw new Error("first arg must be private key");
      if (!re(ce))
        throw new Error("second arg must be public key");
      return g.fromHex(ce).multiply(x(te)).toRawBytes(Te);
    }
    const ee = m.bits2int || function(te) {
      const ce = r.bytesToNumberBE(te), Te = te.length * 8 - m.nBitLength;
      return Te > 0 ? ce >> BigInt(Te) : ce;
    }, q = m.bits2int_modN || function(te) {
      return X(ee(te));
    }, fe = r.bitMask(m.nBitLength);
    function Ke(te) {
      if (typeof te != "bigint")
        throw new Error("bigint expected");
      if (!(l <= te && te < fe))
        throw new Error(`bigint expected < 2^${m.nBitLength}`);
      return r.numberToBytesBE(te, m.nByteLength);
    }
    function _e(te, ce, Te = ge) {
      if (["recovered", "canonical"].some((At) => At in Te))
        throw new Error("sign() legacy options not supported");
      const { hash: Ge, randomBytes: He } = m;
      let { lowS: Ze, prehash: Fe, extraEntropy: rt } = Te;
      Ze == null && (Ze = !0), te = (0, i.ensureBytes)("msgHash", te), Fe && (te = (0, i.ensureBytes)("prehashed msgHash", Ge(te)));
      const bt = q(te), wt = x(ce), Ot = [Ke(wt), Ke(bt)];
      if (rt != null) {
        const At = rt === !0 ? He(d.BYTES) : rt;
        Ot.push((0, i.ensureBytes)("extraEntropy", At, d.BYTES));
      }
      const Pt = r.concatBytes(...Ot), _t = bt;
      function Lt(At) {
        const It = ee(At);
        if (!Q(It))
          return;
        const ur = H(It), vt = g.BASE.multiply(It).toAffine(), Ut = X(vt.x);
        if (Ut === l)
          return;
        const Mt = X(ur * X(_t + Ut * wt));
        if (Mt === l)
          return;
        let Zt = (vt.x === Ut ? 0 : 2) | Number(vt.y & p), kt = Mt;
        return Ze && K(Mt) && (kt = N(Mt), Zt ^= 1), new T(Ut, kt, Zt);
      }
      return { seed: Pt, k2sig: Lt };
    }
    const ge = { lowS: m.lowS, prehash: !1 }, qe = { lowS: m.lowS, prehash: !1 };
    function We(te, ce, Te = ge) {
      const { seed: Ge, k2sig: He } = _e(te, ce, Te), Ze = m;
      return r.createHmacDrbg(Ze.hash.outputLen, Ze.nByteLength, Ze.hmac)(Ge, He);
    }
    g.BASE._setWindowSize(8);
    function et(te, ce, Te, Ge = qe) {
      const He = te;
      if (ce = (0, i.ensureBytes)("msgHash", ce), Te = (0, i.ensureBytes)("publicKey", Te), "strict" in Ge)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: Ze, prehash: Fe } = Ge;
      let rt, bt;
      try {
        if (typeof He == "string" || He instanceof Uint8Array)
          try {
            rt = T.fromDER(He);
          } catch (vt) {
            if (!(vt instanceof e.DER.Err))
              throw vt;
            rt = T.fromCompact(He);
          }
        else if (typeof He == "object" && typeof He.r == "bigint" && typeof He.s == "bigint") {
          const { r: vt, s: Ut } = He;
          rt = new T(vt, Ut);
        } else
          throw new Error("PARSE");
        bt = g.fromHex(Te);
      } catch (vt) {
        if (vt.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (Ze && rt.hasHighS())
        return !1;
      Fe && (ce = m.hash(ce));
      const { r: wt, s: Ot } = rt, Pt = q(ce), _t = H(Ot), Lt = X(Pt * _t), At = X(wt * _t), It = g.BASE.multiplyAndAddUnsafe(bt, Lt, At)?.toAffine();
      return It ? X(It.x) === wt : !1;
    }
    return {
      CURVE: m,
      getPublicKey: k,
      getSharedSecret: ne,
      sign: We,
      verify: et,
      ProjectivePoint: g,
      Signature: T,
      utils: C
    };
  }
  e.weierstrass = D;
  function Z(v, m) {
    const d = v.ORDER;
    let V = l;
    for (let K = d - p; K % B === l; K /= B)
      V += p;
    const S = V, j = B << S - p - p, W = j * B, X = (d - p) / W, H = (X - p) / B, g = W - p, x = j, A = v.pow(m, X), Q = v.pow(m, (X + p) / B);
    let J = (K, N) => {
      let F = A, T = v.pow(N, g), C = v.sqr(T);
      C = v.mul(C, N);
      let k = v.mul(K, C);
      k = v.pow(k, H), k = v.mul(k, T), T = v.mul(k, N), C = v.mul(k, K);
      let re = v.mul(C, T);
      k = v.pow(re, x);
      let ne = v.eql(k, v.ONE);
      T = v.mul(C, Q), k = v.mul(re, F), C = v.cmov(T, C, ne), re = v.cmov(k, re, ne);
      for (let ee = S; ee > p; ee--) {
        let q = ee - B;
        q = B << q - p;
        let fe = v.pow(re, q);
        const Ke = v.eql(fe, v.ONE);
        T = v.mul(C, F), F = v.mul(F, F), fe = v.mul(re, F), C = v.cmov(T, C, Ke), re = v.cmov(fe, re, Ke);
      }
      return { isValid: ne, value: C };
    };
    if (v.ORDER % O === w) {
      const K = (v.ORDER - w) / O, N = v.sqrt(v.neg(m));
      J = (F, T) => {
        let C = v.sqr(T);
        const k = v.mul(F, T);
        C = v.mul(C, k);
        let re = v.pow(C, K);
        re = v.mul(re, k);
        const ne = v.mul(re, N), ee = v.mul(v.sqr(re), T), q = v.eql(ee, F);
        let fe = v.cmov(ne, re, q);
        return { isValid: q, value: fe };
      };
    }
    return J;
  }
  e.SWUFpSqrtRatio = Z;
  function pe(v, m) {
    if (t.validateField(v), !v.isValid(m.A) || !v.isValid(m.B) || !v.isValid(m.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const d = Z(v, m.Z);
    if (!v.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (V) => {
      let S, j, W, X, H, g, x, A;
      S = v.sqr(V), S = v.mul(S, m.Z), j = v.sqr(S), j = v.add(j, S), W = v.add(j, v.ONE), W = v.mul(W, m.B), X = v.cmov(m.Z, v.neg(j), !v.eql(j, v.ZERO)), X = v.mul(X, m.A), j = v.sqr(W), g = v.sqr(X), H = v.mul(g, m.A), j = v.add(j, H), j = v.mul(j, W), g = v.mul(g, X), H = v.mul(g, m.B), j = v.add(j, H), x = v.mul(S, W);
      const { isValid: Q, value: J } = d(j, g);
      A = v.mul(S, V), A = v.mul(A, J), x = v.cmov(x, W, Q), A = v.cmov(A, J, Q);
      const K = v.isOdd(V) === v.isOdd(A);
      return A = v.cmov(v.neg(A), A, K), x = v.div(x, X), { x, y: A };
    };
  }
  e.mapToCurveSimpleSWU = pe;
})(Kr);
var gt = {};
Object.defineProperty(gt, "__esModule", { value: !0 });
gt.createHasher = gt.isogenyMap = gt.hash_to_field = gt.expand_message_xof = gt.expand_message_xmd = void 0;
const Rc = $e, Tt = Be;
function Lc(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, Tt.utf8ToBytes)(e);
  throw new Error("DST must be Uint8Array or string");
}
const Mc = Tt.bytesToNumberBE;
function zt(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let i = t - 1; i >= 0; i--)
    r[i] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function kc(e, t) {
  const r = new Uint8Array(e.length);
  for (let i = 0; i < e.length; i++)
    r[i] = e[i] ^ t[i];
  return r;
}
function gr(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function zn(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function Ho(e, t, r, i) {
  gr(e), gr(t), zn(r), t.length > 255 && (t = i((0, Tt.concatBytes)((0, Tt.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: s, blockLen: h } = i, u = Math.ceil(r / s);
  if (u > 255)
    throw new Error("Invalid xmd length");
  const b = (0, Tt.concatBytes)(t, zt(t.length, 1)), l = zt(0, h), p = zt(r, 2), B = new Array(u), w = i((0, Tt.concatBytes)(l, e, p, zt(0, 1), b));
  B[0] = i((0, Tt.concatBytes)(w, zt(1, 1), b));
  for (let U = 1; U <= u; U++) {
    const $ = [kc(w, B[U - 1]), zt(U + 1, 1), b];
    B[U] = i((0, Tt.concatBytes)(...$));
  }
  return (0, Tt.concatBytes)(...B).slice(0, r);
}
gt.expand_message_xmd = Ho;
function Ko(e, t, r, i, s) {
  if (gr(e), gr(t), zn(r), t.length > 255) {
    const h = Math.ceil(2 * i / 8);
    t = s.create({ dkLen: h }).update((0, Tt.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return s.create({ dkLen: r }).update(e).update(zt(r, 2)).update(t).update(zt(t.length, 1)).digest();
}
gt.expand_message_xof = Ko;
function bn(e, t, r) {
  (0, Tt.validateObject)(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: i, k: s, m: h, hash: u, expand: b, DST: l } = r;
  gr(e), zn(t);
  const p = Lc(l), B = i.toString(2).length, w = Math.ceil((B + s) / 8), O = t * h * w;
  let U;
  if (b === "xmd")
    U = Ho(e, p, O, u);
  else if (b === "xof")
    U = Ko(e, p, O, s, u);
  else if (b === "_internal_pass")
    U = e;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const $ = new Array(t);
  for (let D = 0; D < t; D++) {
    const Z = new Array(h);
    for (let pe = 0; pe < h; pe++) {
      const v = w * (pe + D * h), m = U.subarray(v, v + w);
      Z[pe] = (0, Rc.mod)(Mc(m), i);
    }
    $[D] = Z;
  }
  return $;
}
gt.hash_to_field = bn;
function Dc(e, t) {
  const r = t.map((i) => Array.from(i).reverse());
  return (i, s) => {
    const [h, u, b, l] = r.map((p) => p.reduce((B, w) => e.add(e.mul(B, i), w)));
    return i = e.div(h, u), s = e.mul(s, e.div(b, l)), { x: i, y: s };
  };
}
gt.isogenyMap = Dc;
function Hc(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(i, s) {
      const h = bn(i, 2, { ...r, DST: r.DST, ...s }), u = e.fromAffine(t(h[0])), b = e.fromAffine(t(h[1])), l = u.add(b).clearCofactor();
      return l.assertValidity(), l;
    },
    encodeToCurve(i, s) {
      const h = bn(i, 1, { ...r, DST: r.encodeDST, ...s }), u = e.fromAffine(t(h[0])).clearCofactor();
      return u.assertValidity(), u;
    }
  };
}
gt.createHasher = Hc;
var Jt = {};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.createCurve = Jt.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Kc = Cn, di = xt, Gc = Kr;
function Go(e) {
  return {
    hash: e,
    hmac: (t, ...r) => (0, Kc.hmac)(e, t, (0, di.concatBytes)(...r)),
    randomBytes: di.randomBytes
  };
}
Jt.getHash = Go;
function Vc(e, t) {
  const r = (i) => (0, Gc.weierstrass)({ ...e, ...Go(i) });
  return Object.freeze({ ...r(t), create: r });
}
Jt.createCurve = Vc;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = $t, r = xt, i = $e, s = Kr, h = Be, u = gt, b = Jt, l = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), p = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), B = BigInt(1), w = BigInt(2), O = (T, C) => (T + C / w) / C;
  function U(T) {
    const C = l, k = BigInt(3), re = BigInt(6), ne = BigInt(11), ee = BigInt(22), q = BigInt(23), fe = BigInt(44), Ke = BigInt(88), _e = T * T * T % C, ge = _e * _e * T % C, qe = (0, i.pow2)(ge, k, C) * ge % C, We = (0, i.pow2)(qe, k, C) * ge % C, et = (0, i.pow2)(We, w, C) * _e % C, te = (0, i.pow2)(et, ne, C) * et % C, ce = (0, i.pow2)(te, ee, C) * te % C, Te = (0, i.pow2)(ce, fe, C) * ce % C, Ge = (0, i.pow2)(Te, Ke, C) * Te % C, He = (0, i.pow2)(Ge, fe, C) * ce % C, Ze = (0, i.pow2)(He, k, C) * ge % C, Fe = (0, i.pow2)(Ze, q, C) * te % C, rt = (0, i.pow2)(Fe, re, C) * _e % C, bt = (0, i.pow2)(rt, w, C);
    if (!$.eql($.sqr(bt), T))
      throw new Error("Cannot find square root");
    return bt;
  }
  const $ = (0, i.Field)(l, void 0, void 0, { sqrt: U });
  e.secp256k1 = (0, b.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp: $,
    n: p,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (T) => {
        const C = p, k = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), re = -B * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ne = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ee = k, q = BigInt("0x100000000000000000000000000000000"), fe = O(ee * T, C), Ke = O(-re * T, C);
        let _e = (0, i.mod)(T - fe * k - Ke * ne, C), ge = (0, i.mod)(-fe * re - Ke * ee, C);
        const qe = _e > q, We = ge > q;
        if (qe && (_e = C - _e), We && (ge = C - ge), _e > q || ge > q)
          throw new Error("splitScalar: Endomorphism failed, k=" + T);
        return { k1neg: qe, k1: _e, k2neg: We, k2: ge };
      }
    }
  }, t.sha256);
  const D = BigInt(0), Z = (T) => typeof T == "bigint" && D < T && T < l, pe = (T) => typeof T == "bigint" && D < T && T < p, v = {};
  function m(T, ...C) {
    let k = v[T];
    if (k === void 0) {
      const re = (0, t.sha256)(Uint8Array.from(T, (ne) => ne.charCodeAt(0)));
      k = (0, h.concatBytes)(re, re), v[T] = k;
    }
    return (0, t.sha256)((0, h.concatBytes)(k, ...C));
  }
  const d = (T) => T.toRawBytes(!0).slice(1), V = (T) => (0, h.numberToBytesBE)(T, 32), S = (T) => (0, i.mod)(T, l), j = (T) => (0, i.mod)(T, p), W = e.secp256k1.ProjectivePoint, X = (T, C, k) => W.BASE.multiplyAndAddUnsafe(T, C, k);
  function H(T) {
    let C = e.secp256k1.utils.normPrivateKeyToScalar(T), k = W.fromPrivateKey(C);
    return { scalar: k.hasEvenY() ? C : j(-C), bytes: d(k) };
  }
  function g(T) {
    if (!Z(T))
      throw new Error("bad x: need 0 < x < p");
    const C = S(T * T), k = S(C * T + BigInt(7));
    let re = U(k);
    re % w !== D && (re = S(-re));
    const ne = new W(T, re, B);
    return ne.assertValidity(), ne;
  }
  function x(...T) {
    return j((0, h.bytesToNumberBE)(m("BIP0340/challenge", ...T)));
  }
  function A(T) {
    return H(T).bytes;
  }
  function Q(T, C, k = (0, r.randomBytes)(32)) {
    const re = (0, h.ensureBytes)("message", T), { bytes: ne, scalar: ee } = H(C), q = (0, h.ensureBytes)("auxRand", k, 32), fe = V(ee ^ (0, h.bytesToNumberBE)(m("BIP0340/aux", q))), Ke = m("BIP0340/nonce", fe, ne, re), _e = j((0, h.bytesToNumberBE)(Ke));
    if (_e === D)
      throw new Error("sign failed: k is zero");
    const { bytes: ge, scalar: qe } = H(_e), We = x(ge, ne, re), et = new Uint8Array(64);
    if (et.set(ge, 0), et.set(V(j(qe + We * ee)), 32), !J(et, re, ne))
      throw new Error("sign: Invalid signature produced");
    return et;
  }
  function J(T, C, k) {
    const re = (0, h.ensureBytes)("signature", T, 64), ne = (0, h.ensureBytes)("message", C), ee = (0, h.ensureBytes)("publicKey", k, 32);
    try {
      const q = g((0, h.bytesToNumberBE)(ee)), fe = (0, h.bytesToNumberBE)(re.subarray(0, 32));
      if (!Z(fe))
        return !1;
      const Ke = (0, h.bytesToNumberBE)(re.subarray(32, 64));
      if (!pe(Ke))
        return !1;
      const _e = x(V(fe), d(q), ne), ge = X(q, Ke, j(-_e));
      return !(!ge || !ge.hasEvenY() || ge.toAffine().x !== fe);
    } catch {
      return !1;
    }
  }
  e.schnorr = (() => ({
    getPublicKey: A,
    sign: Q,
    verify: J,
    utils: {
      randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
      lift_x: g,
      pointToBytes: d,
      numberToBytesBE: h.numberToBytesBE,
      bytesToNumberBE: h.bytesToNumberBE,
      taggedHash: m,
      mod: i.mod
    }
  }))();
  const K = /* @__PURE__ */ (() => (0, u.isogenyMap)($, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((T) => T.map((C) => BigInt(C)))))(), N = /* @__PURE__ */ (() => (0, s.mapToCurveSimpleSWU)($, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: $.create(BigInt("-11"))
  }))(), F = /* @__PURE__ */ (() => (0, u.createHasher)(e.secp256k1.ProjectivePoint, (T) => {
    const { x: C, y: k } = N($.create(T[0]));
    return K(C, k);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: $.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: t.sha256
  }))();
  e.hashToCurve = (() => F.hashToCurve)(), e.encodeToCurve = (() => F.encodeToCurve)();
})(Uo);
var Yn = Object.defineProperty, qc = Object.getOwnPropertyDescriptor, zc = Object.getOwnPropertyNames, Yc = Object.prototype.hasOwnProperty, Wc = (e, t) => {
  for (var r in t)
    Yn(e, r, { get: t[r], enumerable: !0 });
}, Zc = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of zc(t))
      !Yc.call(e, s) && s !== r && Yn(e, s, { get: () => t[s], enumerable: !(i = qc(t, s)) || i.enumerable });
  return e;
}, Fc = (e) => Zc(Yn({}, "__esModule", { value: !0 }), e), Vo = {};
Wc(Vo, {
  Secp256k1PublicKey: () => qo
});
var Xc = Fc(Vo), Jc = Bt, bi = _r, yi = ar, pi = Uo, Qc = $t;
const yn = 33;
class qo extends bi.PublicKey {
  constructor(t) {
    if (super(), typeof t == "string" ? this.data = (0, Jc.fromB64)(t) : t instanceof Uint8Array ? this.data = t : this.data = Uint8Array.from(t), this.data.length !== yn)
      throw new Error(
        `Invalid public key input. Expected ${yn} bytes, got ${this.data.length}`
      );
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return yi.SIGNATURE_SCHEME_TO_FLAG.Secp256k1;
  }
  async verify(t, r) {
    let i;
    if (typeof r == "string") {
      const s = (0, yi.parseSerializedSignature)(r);
      if (s.signatureScheme !== "Secp256k1")
        throw new Error("Invalid signature scheme");
      if (!(0, bi.bytesEqual)(this.toRawBytes(), s.publicKey))
        throw new Error("Signature does not match public key");
      i = s.signature;
    } else
      i = r;
    return pi.secp256k1.verify(
      pi.secp256k1.Signature.fromCompact(i),
      (0, Qc.sha256)(t),
      this.toRawBytes()
    );
  }
}
qo.SIZE = yn;
var zo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.secp256r1 = e.p256 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = Jt, r = $t, i = $e, s = Kr, h = gt, u = (0, i.Field)(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")), b = u.create(BigInt("-3")), l = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
  e.p256 = (0, t.createCurve)({
    a: b,
    b: l,
    Fp: u,
    n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
    Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
    Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
    h: BigInt(1),
    lowS: !1
  }, r.sha256), e.secp256r1 = e.p256;
  const p = /* @__PURE__ */ (() => (0, s.mapToCurveSimpleSWU)(u, {
    A: b,
    B: l,
    Z: u.create(BigInt("-10"))
  }))(), B = /* @__PURE__ */ (() => (0, h.createHasher)(e.secp256r1.ProjectivePoint, (w) => p(w[0]), {
    DST: "P256_XMD:SHA-256_SSWU_RO_",
    encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
    p: u.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: r.sha256
  }))();
  e.hashToCurve = (() => B.hashToCurve)(), e.encodeToCurve = (() => B.encodeToCurve)();
})(zo);
var Wn = Object.defineProperty, e0 = Object.getOwnPropertyDescriptor, t0 = Object.getOwnPropertyNames, r0 = Object.prototype.hasOwnProperty, n0 = (e, t) => {
  for (var r in t)
    Wn(e, r, { get: t[r], enumerable: !0 });
}, i0 = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of t0(t))
      !r0.call(e, s) && s !== r && Wn(e, s, { get: () => t[s], enumerable: !(i = e0(t, s)) || i.enumerable });
  return e;
}, o0 = (e) => i0(Wn({}, "__esModule", { value: !0 }), e), Yo = {};
n0(Yo, {
  Secp256r1PublicKey: () => Wo
});
var s0 = o0(Yo), f0 = Bt, gi = _r, xi = ar, a0 = $t, wi = zo;
const pn = 33;
class Wo extends gi.PublicKey {
  constructor(t) {
    if (super(), typeof t == "string" ? this.data = (0, f0.fromB64)(t) : t instanceof Uint8Array ? this.data = t : this.data = Uint8Array.from(t), this.data.length !== pn)
      throw new Error(
        `Invalid public key input. Expected ${pn} bytes, got ${this.data.length}`
      );
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return xi.SIGNATURE_SCHEME_TO_FLAG.Secp256r1;
  }
  async verify(t, r) {
    let i;
    if (typeof r == "string") {
      const s = (0, xi.parseSerializedSignature)(r);
      if (s.signatureScheme !== "Secp256r1")
        throw new Error("Invalid signature scheme");
      if (!(0, gi.bytesEqual)(this.toRawBytes(), s.publicKey))
        throw new Error("Signature does not match public key");
      i = s.signature;
    } else
      i = r;
    return wi.secp256r1.verify(
      wi.secp256r1.Signature.fromCompact(i),
      (0, a0.sha256)(t),
      this.toRawBytes()
    );
  }
}
Wo.SIZE = pn;
var rn, _i;
function c0() {
  if (_i)
    return rn;
  _i = 1;
  var e = Object.defineProperty, t = Object.getOwnPropertyDescriptor, r = Object.getOwnPropertyNames, i = Object.prototype.hasOwnProperty, s = (d, V) => {
    for (var S in V)
      e(d, S, { get: V[S], enumerable: !0 });
  }, h = (d, V, S, j) => {
    if (V && typeof V == "object" || typeof V == "function")
      for (let W of r(V))
        !i.call(d, W) && W !== S && e(d, W, { get: () => V[W], enumerable: !(j = t(V, W)) || j.enumerable });
    return d;
  }, u = (d) => h(e({}, "__esModule", { value: !0 }), d), b = {};
  s(b, {
    MAX_SIGNER_IN_MULTISIG: () => Z,
    MultiSigPublicKey: () => pe,
    parsePartialSignatures: () => v
  }), rn = u(b);
  var l = Bt, p = cr, B = xt, w = _r, O = ar, U = $r, $ = Gi, D = Zo();
  const Z = 10;
  class pe extends w.PublicKey {
    constructor(V) {
      if (super(), typeof V == "string" ? (this.rawBytes = (0, l.fromB64)(V), this.multisigPublicKey = $.builder.de("MultiSigPublicKey", this.rawBytes)) : V instanceof Uint8Array ? (this.rawBytes = V, this.multisigPublicKey = $.builder.de("MultiSigPublicKey", this.rawBytes)) : (this.multisigPublicKey = V, this.rawBytes = $.builder.ser("MultiSigPublicKey", V).toBytes()), this.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey: S, weight: j }) => {
        const [W, X] = Object.entries(S)[0];
        return {
          publicKey: (0, D.publicKeyFromRawBytes)(W, Uint8Array.from(X)),
          weight: j
        };
      }), this.publicKeys.length > Z)
        throw new Error(`Max number of signers in a multisig is ${Z}`);
    }
    static fromPublicKeys({
      threshold: V,
      publicKeys: S
    }) {
      return new pe({
        pk_map: S.map(({ publicKey: j, weight: W }) => ({
          pubKey: { [O.SIGNATURE_FLAG_TO_SCHEME[j.flag()]]: Array.from(j.toRawBytes()) },
          weight: W
        })),
        threshold: V
      });
    }
    equals(V) {
      return super.equals(V);
    }
    toRawBytes() {
      return this.rawBytes;
    }
    getPublicKeys() {
      return this.publicKeys;
    }
    toSuiAddress() {
      const V = 1 + 65 * Z + 2, S = new Uint8Array(V);
      S.set([O.SIGNATURE_SCHEME_TO_FLAG.MultiSig]), S.set($.builder.ser("u16", this.multisigPublicKey.threshold).toBytes(), 1);
      let j = 3;
      for (const { publicKey: W, weight: X } of this.publicKeys) {
        const H = W.toSuiBytes();
        S.set(H, j), j += H.length, S.set([X], j++);
      }
      return (0, U.normalizeSuiAddress)((0, B.bytesToHex)((0, p.blake2b)(S.slice(0, j), { dkLen: 32 })));
    }
    flag() {
      return O.SIGNATURE_SCHEME_TO_FLAG.MultiSig;
    }
    async verify(V, S) {
      if (typeof S != "string")
        throw new Error("Multisig verification only supports serialized signature");
      const { signatureScheme: j, multisig: W } = (0, O.parseSerializedSignature)(S);
      if (j !== "MultiSig")
        throw new Error("Invalid signature scheme");
      let X = 0;
      if (!(0, w.bytesEqual)(
        $.builder.ser("MultiSigPublicKey", this.multisigPublicKey).toBytes(),
        $.builder.ser("MultiSigPublicKey", W.multisig_pk).toBytes()
      ))
        return !1;
      for (const { publicKey: H, weight: g, signature: x } of v(W)) {
        if (!await H.verify(V, x))
          return !1;
        X += g;
      }
      return X >= this.multisigPublicKey.threshold;
    }
    combinePartialSignatures(V) {
      let S = 0;
      const j = new Array(V.length);
      for (let g = 0; g < V.length; g++) {
        let x = (0, O.parseSerializedSignature)(V[g]);
        if (x.signatureScheme === "MultiSig")
          throw new Error("MultiSig is not supported inside MultiSig");
        let A = Array.from(x.signature.map((J) => Number(J)));
        x.signatureScheme === "ED25519" ? j[g] = { ED25519: A } : x.signatureScheme === "Secp256k1" ? j[g] = { Secp256k1: A } : x.signatureScheme === "Secp256r1" && (j[g] = { Secp256r1: A });
        let Q;
        for (let J = 0; J < this.publicKeys.length; J++)
          if ((0, w.bytesEqual)(x.publicKey, this.publicKeys[J].publicKey.toRawBytes())) {
            if (S & 1 << J)
              throw new Error("Received multiple signatures from the same public key");
            Q = J;
            break;
          }
        if (Q === void 0)
          throw new Error("Received signature from unknown public key");
        S |= 1 << Q;
      }
      let W = {
        sigs: j,
        bitmap: S,
        multisig_pk: this.multisigPublicKey
      };
      const X = $.builder.ser("MultiSig", W).toBytes();
      let H = new Uint8Array(X.length + 1);
      return H.set([O.SIGNATURE_SCHEME_TO_FLAG.MultiSig]), H.set(X, 1), (0, l.toB64)(H);
    }
  }
  function v(d) {
    let V = new Array(d.sigs.length);
    for (let S = 0; S < d.sigs.length; S++) {
      const [j, W] = Object.entries(d.sigs[S])[0], X = m(d.bitmap).at(S), H = d.multisig_pk.pk_map[X], g = Uint8Array.from(Object.values(H.pubKey)[0]);
      if (j === "MultiSig")
        throw new Error("MultiSig is not supported inside MultiSig");
      const x = (0, D.publicKeyFromRawBytes)(j, g);
      V[S] = {
        signatureScheme: j,
        signature: Uint8Array.from(W),
        publicKey: x,
        weight: H.weight
      };
    }
    return V;
  }
  function m(d) {
    if (d < 0 || d > 1024)
      throw new Error("Invalid bitmap");
    let V = [];
    for (let S = 0; S < 10; S++)
      (d & 1 << S) !== 0 && V.push(S);
    return Uint8Array.from(V);
  }
  return rn;
}
var nn, vi;
function Zo() {
  if (vi)
    return nn;
  vi = 1;
  var e = Object.defineProperty, t = Object.getOwnPropertyDescriptor, r = Object.getOwnPropertyNames, i = Object.prototype.hasOwnProperty, s = (v, m) => {
    for (var d in m)
      e(v, d, { get: m[d], enumerable: !0 });
  }, h = (v, m, d, V) => {
    if (m && typeof m == "object" || typeof m == "function")
      for (let S of r(m))
        !i.call(v, S) && S !== d && e(v, S, { get: () => m[S], enumerable: !(V = t(m, S)) || V.enumerable });
    return v;
  }, u = (v) => h(e({}, "__esModule", { value: !0 }), v), b = {};
  s(b, {
    publicKeyFromRawBytes: () => pe,
    verifyPersonalMessage: () => $,
    verifySignature: () => U,
    verifyTransactionBlock: () => D
  }), nn = u(b);
  var l = Bi.exports, p = rc, B = Xc, w = s0, O = c0();
  async function U(v, m) {
    const d = Z(m);
    if (!await d.publicKey.verify(v, d.serializedSignature))
      throw new Error("Signature is not valid for the provided data");
    return d.publicKey;
  }
  async function $(v, m) {
    const d = Z(m);
    if (!await d.publicKey.verifyPersonalMessage(
      v,
      d.serializedSignature
    ))
      throw new Error("Signature is not valid for the provided message");
    return d.publicKey;
  }
  async function D(v, m) {
    const d = Z(m);
    if (!await d.publicKey.verifyTransactionBlock(
      v,
      d.serializedSignature
    ))
      throw new Error("Signature is not valid for the provided TransactionBlock");
    return d.publicKey;
  }
  function Z(v) {
    const m = (0, l.parseSerializedSignature)(v);
    if (m.signatureScheme === "MultiSig")
      return {
        ...m,
        publicKey: new O.MultiSigPublicKey(m.multisig.multisig_pk)
      };
    const d = pe(
      m.signatureScheme,
      m.publicKey
    );
    return {
      ...m,
      publicKey: d
    };
  }
  function pe(v, m) {
    switch (v) {
      case "ED25519":
        return new p.Ed25519PublicKey(m);
      case "Secp256k1":
        return new B.Secp256k1PublicKey(m);
      case "Secp256r1":
        return new w.Secp256r1PublicKey(m);
      case "MultiSig":
        return new O.MultiSigPublicKey(m);
      default:
        throw new Error(`Unsupported signature scheme ${v}`);
    }
  }
  return nn;
}
var u0 = Zo();
function Fo(e) {
  return Uint8Array.from(atob(e), (t) => t.charCodeAt(0));
}
async function w0(e, t) {
  try {
    const r = await u0.verifyPersonalMessage(Fo(e.messageBytes), e.signature);
    return ss(r.toRawBytes(), t);
  } catch {
    return !1;
  }
}
function _0(e) {
  return new TextDecoder().decode(Fo(e));
}
export {
  d0 as Account,
  y0 as Provider,
  b0 as SUI_SYSTEM_STATE_OBJECT_ID,
  g0 as addressEllipsis,
  mi as formatCurrency,
  p0 as formatSUI,
  _0 as stringBytesToString,
  Fo as stringBytesToUint8Array,
  w0 as verifySignedMessage
};
