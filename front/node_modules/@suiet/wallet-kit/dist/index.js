import * as Xe from "react";
import Ct, { useCallback as St, createContext as Zn, useMemo as tr, createElement as Ve, useContext as vo, useLayoutEffect as Su, useRef as ht, useEffect as pt, useState as Bt, forwardRef as jt, Children as Br, isValidElement as Kn, cloneElement as mo, Fragment as ua, useReducer as Nu } from "react";
import la, { flushSync as fa } from "react-dom";
import { JsonRpcProvider as da, Connection as ha, getSuiObjectData as Tu, getMoveObject as as, Coin as Vi, bytesEqual as Iu, SUI_TYPE_ARG as pa } from "@mysten/sui.js";
var ga = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function r() {
      for (var n = [], i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        if (!!o) {
          var a = typeof o;
          if (a === "string" || a === "number")
            n.push(o);
          else if (Array.isArray(o)) {
            if (o.length) {
              var u = r.apply(null, o);
              u && n.push(u);
            }
          } else if (a === "object") {
            if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]")) {
              n.push(o.toString());
              continue;
            }
            for (var f in o)
              t.call(o, f) && o[f] && n.push(f);
          }
        }
      }
      return n.join(" ");
    }
    e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
  })();
})(ga);
const vn = ga.exports;
function Be() {
  return Be = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Be.apply(this, arguments);
}
function Nr(e, t, { checkForDefaultPrevented: r = !0 } = {}) {
  return function(i) {
    if (e?.(i), r === !1 || !i.defaultPrevented)
      return t?.(i);
  };
}
function Ou(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function ya(...e) {
  return (t) => e.forEach(
    (r) => Ou(r, t)
  );
}
function tn(...e) {
  return St(ya(...e), e);
}
function Du(e, t = []) {
  let r = [];
  function n(o, a) {
    const u = /* @__PURE__ */ Zn(a), f = r.length;
    r = [
      ...r,
      a
    ];
    function p(y) {
      const { scope: A, children: S, ...I } = y, D = A?.[e][f] || u, L = tr(
        () => I,
        Object.values(I)
      );
      return /* @__PURE__ */ Ve(D.Provider, {
        value: L
      }, S);
    }
    function g(y, A) {
      const S = A?.[e][f] || u, I = vo(S);
      if (I)
        return I;
      if (a !== void 0)
        return a;
      throw new Error(`\`${y}\` must be used within \`${o}\``);
    }
    return p.displayName = o + "Provider", [
      p,
      g
    ];
  }
  const i = () => {
    const o = r.map((a) => /* @__PURE__ */ Zn(a));
    return function(u) {
      const f = u?.[e] || o;
      return tr(
        () => ({
          [`__scope${e}`]: {
            ...u,
            [e]: f
          }
        }),
        [
          u,
          f
        ]
      );
    };
  };
  return i.scopeName = e, [
    n,
    Cu(i, ...t)
  ];
}
function Cu(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const r = () => {
    const n = e.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(o) {
      const a = n.reduce((u, { useScope: f, scopeName: p }) => {
        const y = f(o)[`__scope${p}`];
        return {
          ...u,
          ...y
        };
      }, {});
      return tr(
        () => ({
          [`__scope${t.scopeName}`]: a
        }),
        [
          a
        ]
      );
    };
  };
  return r.scopeName = t.scopeName, r;
}
const Gi = Boolean(globalThis?.document) ? Su : () => {
}, ju = Xe["useId".toString()] || (() => {
});
let xu = 0;
function Di(e) {
  const [t, r] = Xe.useState(ju());
  return Gi(() => {
    e || r(
      (n) => n ?? String(xu++)
    );
  }, [
    e
  ]), e || (t ? `radix-${t}` : "");
}
function Rr(e) {
  const t = ht(e);
  return pt(() => {
    t.current = e;
  }), tr(
    () => (...r) => {
      var n;
      return (n = t.current) === null || n === void 0 ? void 0 : n.call(t, ...r);
    },
    []
  );
}
function Lu({ prop: e, defaultProp: t, onChange: r = () => {
} }) {
  const [n, i] = Bu({
    defaultProp: t,
    onChange: r
  }), o = e !== void 0, a = o ? e : n, u = Rr(r), f = St((p) => {
    if (o) {
      const y = typeof p == "function" ? p(e) : p;
      y !== e && u(y);
    } else
      i(p);
  }, [
    o,
    e,
    i,
    u
  ]);
  return [
    a,
    f
  ];
}
function Bu({ defaultProp: e, onChange: t }) {
  const r = Bt(e), [n] = r, i = ht(n), o = Rr(t);
  return pt(() => {
    i.current !== n && (o(n), i.current = n);
  }, [
    n,
    i,
    o
  ]), r;
}
function Tr() {
  return Tr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Tr.apply(this, arguments);
}
const wo = /* @__PURE__ */ jt((e, t) => {
  const { children: r, ...n } = e, i = Br.toArray(r), o = i.find(Uu);
  if (o) {
    const a = o.props.children, u = i.map((f) => f === o ? Br.count(a) > 1 ? Br.only(null) : /* @__PURE__ */ Kn(a) ? a.props.children : null : f);
    return /* @__PURE__ */ Ve($i, Tr({}, n, {
      ref: t
    }), /* @__PURE__ */ Kn(a) ? /* @__PURE__ */ mo(a, void 0, u) : null);
  }
  return /* @__PURE__ */ Ve($i, Tr({}, n, {
    ref: t
  }), r);
});
wo.displayName = "Slot";
const $i = /* @__PURE__ */ jt((e, t) => {
  const { children: r, ...n } = e;
  return /* @__PURE__ */ Kn(r) ? /* @__PURE__ */ mo(r, {
    ...Pu(n, r.props),
    ref: ya(t, r.ref)
  }) : Br.count(r) > 1 ? Br.only(null) : null;
});
$i.displayName = "SlotClone";
const Ru = ({ children: e }) => /* @__PURE__ */ Ve(ua, null, e);
function Uu(e) {
  return /* @__PURE__ */ Kn(e) && e.type === Ru;
}
function Pu(e, t) {
  const r = {
    ...t
  };
  for (const n in t) {
    const i = e[n], o = t[n];
    /^on[A-Z]/.test(n) ? i && o ? r[n] = (...u) => {
      o(...u), i(...u);
    } : i && (r[n] = i) : n === "style" ? r[n] = {
      ...i,
      ...o
    } : n === "className" && (r[n] = [
      i,
      o
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...r
  };
}
const ku = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], kr = ku.reduce((e, t) => {
  const r = /* @__PURE__ */ jt((n, i) => {
    const { asChild: o, ...a } = n, u = o ? wo : t;
    return pt(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ Ve(u, Tr({}, a, {
      ref: i
    }));
  });
  return r.displayName = `Primitive.${t}`, {
    ...e,
    [t]: r
  };
}, {});
function _u(e, t) {
  e && fa(
    () => e.dispatchEvent(t)
  );
}
function Fu(e, t = globalThis?.document) {
  const r = Rr(e);
  pt(() => {
    const n = (i) => {
      i.key === "Escape" && r(i);
    };
    return t.addEventListener("keydown", n), () => t.removeEventListener("keydown", n);
  }, [
    r,
    t
  ]);
}
const Xi = "dismissableLayer.update", zu = "dismissableLayer.pointerDownOutside", Qu = "dismissableLayer.focusOutside";
let cs;
const Wu = /* @__PURE__ */ Zn({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Yu = /* @__PURE__ */ jt((e, t) => {
  var r;
  const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: a, onInteractOutside: u, onDismiss: f, ...p } = e, g = vo(Wu), [y, A] = Bt(null), S = (r = y?.ownerDocument) !== null && r !== void 0 ? r : globalThis?.document, [, I] = Bt({}), D = tn(
    t,
    (Q) => A(Q)
  ), L = Array.from(g.layers), [Y] = [
    ...g.layersWithOutsidePointerEventsDisabled
  ].slice(-1), M = L.indexOf(Y), N = y ? L.indexOf(y) : -1, b = g.layersWithOutsidePointerEventsDisabled.size > 0, k = N >= M, O = Hu((Q) => {
    const G = Q.target, B = [
      ...g.branches
    ].some(
      (E) => E.contains(G)
    );
    !k || B || (o?.(Q), u?.(Q), Q.defaultPrevented || f?.());
  }, S), R = qu((Q) => {
    const G = Q.target;
    [
      ...g.branches
    ].some(
      (E) => E.contains(G)
    ) || (a?.(Q), u?.(Q), Q.defaultPrevented || f?.());
  }, S);
  return Fu((Q) => {
    N === g.layers.size - 1 && (i?.(Q), !Q.defaultPrevented && f && (Q.preventDefault(), f()));
  }, S), pt(() => {
    if (!!y)
      return n && (g.layersWithOutsidePointerEventsDisabled.size === 0 && (cs = S.body.style.pointerEvents, S.body.style.pointerEvents = "none"), g.layersWithOutsidePointerEventsDisabled.add(y)), g.layers.add(y), us(), () => {
        n && g.layersWithOutsidePointerEventsDisabled.size === 1 && (S.body.style.pointerEvents = cs);
      };
  }, [
    y,
    S,
    n,
    g
  ]), pt(() => () => {
    !y || (g.layers.delete(y), g.layersWithOutsidePointerEventsDisabled.delete(y), us());
  }, [
    y,
    g
  ]), pt(() => {
    const Q = () => I({});
    return document.addEventListener(Xi, Q), () => document.removeEventListener(Xi, Q);
  }, []), /* @__PURE__ */ Ve(kr.div, Tr({}, p, {
    ref: D,
    style: {
      pointerEvents: b ? k ? "auto" : "none" : void 0,
      ...e.style
    },
    onFocusCapture: Nr(e.onFocusCapture, R.onFocusCapture),
    onBlurCapture: Nr(e.onBlurCapture, R.onBlurCapture),
    onPointerDownCapture: Nr(e.onPointerDownCapture, O.onPointerDownCapture)
  }));
});
function Hu(e, t = globalThis?.document) {
  const r = Rr(e), n = ht(!1), i = ht(() => {
  });
  return pt(() => {
    const o = (u) => {
      if (u.target && !n.current) {
        let p = function() {
          ba(zu, r, f, {
            discrete: !0
          });
        };
        const f = {
          originalEvent: u
        };
        u.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = p, t.addEventListener("click", i.current, {
          once: !0
        })) : p();
      }
      n.current = !1;
    }, a = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(a), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [
    t,
    r
  ]), {
    onPointerDownCapture: () => n.current = !0
  };
}
function qu(e, t = globalThis?.document) {
  const r = Rr(e), n = ht(!1);
  return pt(() => {
    const i = (o) => {
      o.target && !n.current && ba(Qu, r, {
        originalEvent: o
      }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [
    t,
    r
  ]), {
    onFocusCapture: () => n.current = !0,
    onBlurCapture: () => n.current = !1
  };
}
function us() {
  const e = new CustomEvent(Xi);
  document.dispatchEvent(e);
}
function ba(e, t, r, { discrete: n }) {
  const i = r.originalEvent.target, o = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: r
  });
  t && i.addEventListener(e, t, {
    once: !0
  }), n ? _u(i, o) : i.dispatchEvent(o);
}
const Ci = "focusScope.autoFocusOnMount", ji = "focusScope.autoFocusOnUnmount", ls = {
  bubbles: !1,
  cancelable: !0
}, Zu = /* @__PURE__ */ jt((e, t) => {
  const { loop: r = !1, trapped: n = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...a } = e, [u, f] = Bt(null), p = Rr(i), g = Rr(o), y = ht(null), A = tn(
    t,
    (D) => f(D)
  ), S = ht({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  pt(() => {
    if (n) {
      let D = function(Y) {
        if (S.paused || !u)
          return;
        const M = Y.target;
        u.contains(M) ? y.current = M : Cr(y.current, {
          select: !0
        });
      }, L = function(Y) {
        S.paused || !u || u.contains(Y.relatedTarget) || Cr(y.current, {
          select: !0
        });
      };
      return document.addEventListener("focusin", D), document.addEventListener("focusout", L), () => {
        document.removeEventListener("focusin", D), document.removeEventListener("focusout", L);
      };
    }
  }, [
    n,
    u,
    S.paused
  ]), pt(() => {
    if (u) {
      ds.add(S);
      const D = document.activeElement;
      if (!u.contains(D)) {
        const Y = new CustomEvent(Ci, ls);
        u.addEventListener(Ci, p), u.dispatchEvent(Y), Y.defaultPrevented || (Ku(Ju(va(u)), {
          select: !0
        }), document.activeElement === D && Cr(u));
      }
      return () => {
        u.removeEventListener(Ci, p), setTimeout(() => {
          const Y = new CustomEvent(ji, ls);
          u.addEventListener(ji, g), u.dispatchEvent(Y), Y.defaultPrevented || Cr(D ?? document.body, {
            select: !0
          }), u.removeEventListener(ji, g), ds.remove(S);
        }, 0);
      };
    }
  }, [
    u,
    p,
    g,
    S
  ]);
  const I = St((D) => {
    if (!r && !n || S.paused)
      return;
    const L = D.key === "Tab" && !D.altKey && !D.ctrlKey && !D.metaKey, Y = document.activeElement;
    if (L && Y) {
      const M = D.currentTarget, [N, b] = Vu(M);
      N && b ? !D.shiftKey && Y === b ? (D.preventDefault(), r && Cr(N, {
        select: !0
      })) : D.shiftKey && Y === N && (D.preventDefault(), r && Cr(b, {
        select: !0
      })) : Y === M && D.preventDefault();
    }
  }, [
    r,
    n,
    S.paused
  ]);
  return /* @__PURE__ */ Ve(kr.div, Tr({
    tabIndex: -1
  }, a, {
    ref: A,
    onKeyDown: I
  }));
});
function Ku(e, { select: t = !1 } = {}) {
  const r = document.activeElement;
  for (const n of e)
    if (Cr(n, {
      select: t
    }), document.activeElement !== r)
      return;
}
function Vu(e) {
  const t = va(e), r = fs(t, e), n = fs(t.reverse(), e);
  return [
    r,
    n
  ];
}
function va(e) {
  const t = [], r = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const i = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || i ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r.nextNode(); )
    t.push(r.currentNode);
  return t;
}
function fs(e, t) {
  for (const r of e)
    if (!Gu(r, {
      upTo: t
    }))
      return r;
}
function Gu(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t !== void 0 && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}
function $u(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Cr(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const r = document.activeElement;
    e.focus({
      preventScroll: !0
    }), e !== r && $u(e) && t && e.select();
  }
}
const ds = Xu();
function Xu() {
  let e = [];
  return {
    add(t) {
      const r = e[0];
      t !== r && r?.pause(), e = hs(e, t), e.unshift(t);
    },
    remove(t) {
      var r;
      e = hs(e, t), (r = e[0]) === null || r === void 0 || r.resume();
    }
  };
}
function hs(e, t) {
  const r = [
    ...e
  ], n = r.indexOf(t);
  return n !== -1 && r.splice(n, 1), r;
}
function Ju(e) {
  return e.filter(
    (t) => t.tagName !== "A"
  );
}
const el = /* @__PURE__ */ jt((e, t) => {
  var r;
  const { container: n = globalThis == null || (r = globalThis.document) === null || r === void 0 ? void 0 : r.body, ...i } = e;
  return n ? /* @__PURE__ */ la.createPortal(/* @__PURE__ */ Ve(kr.div, Tr({}, i, {
    ref: t
  })), n) : null;
});
function tl(e, t) {
  return Nu((r, n) => {
    const i = t[r][n];
    return i ?? r;
  }, e);
}
const ai = (e) => {
  const { present: t, children: r } = e, n = rl(t), i = typeof r == "function" ? r({
    present: n.isPresent
  }) : Br.only(r), o = tn(n.ref, i.ref);
  return typeof r == "function" || n.isPresent ? /* @__PURE__ */ mo(i, {
    ref: o
  }) : null;
};
ai.displayName = "Presence";
function rl(e) {
  const [t, r] = Bt(), n = ht({}), i = ht(e), o = ht("none"), a = e ? "mounted" : "unmounted", [u, f] = tl(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return pt(() => {
    const p = Cn(n.current);
    o.current = u === "mounted" ? p : "none";
  }, [
    u
  ]), Gi(() => {
    const p = n.current, g = i.current;
    if (g !== e) {
      const A = o.current, S = Cn(p);
      e ? f("MOUNT") : S === "none" || p?.display === "none" ? f("UNMOUNT") : f(g && A !== S ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [
    e,
    f
  ]), Gi(() => {
    if (t) {
      const p = (y) => {
        const S = Cn(n.current).includes(y.animationName);
        y.target === t && S && fa(
          () => f("ANIMATION_END")
        );
      }, g = (y) => {
        y.target === t && (o.current = Cn(n.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => {
        t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p);
      };
    } else
      f("ANIMATION_END");
  }, [
    t,
    f
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(u),
    ref: St((p) => {
      p && (n.current = getComputedStyle(p)), r(p);
    }, [])
  };
}
function Cn(e) {
  return e?.animationName || "none";
}
let xi = 0;
function nl() {
  pt(() => {
    var e, t;
    const r = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e = r[0]) !== null && e !== void 0 ? e : ps()), document.body.insertAdjacentElement("beforeend", (t = r[1]) !== null && t !== void 0 ? t : ps()), xi++, () => {
      xi === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (n) => n.remove()
      ), xi--;
    };
  }, []);
}
function ps() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e;
}
var Mr = function() {
  return Mr = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o]);
    }
    return t;
  }, Mr.apply(this, arguments);
};
function il(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
}
function ol(e, t, r) {
  if (r || arguments.length === 2)
    for (var n = 0, i = t.length, o; n < i; n++)
      (o || !(n in t)) && (o || (o = Array.prototype.slice.call(t, 0, n)), o[n] = t[n]);
  return e.concat(o || Array.prototype.slice.call(t));
}
var _n = "right-scroll-bar-position", Fn = "width-before-scroll-bar", sl = "with-scroll-bars-hidden", al = "--removed-body-scroll-bar-size";
function cl(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function ul(e, t) {
  var r = Bt(function() {
    return {
      value: e,
      callback: t,
      facade: {
        get current() {
          return r.value;
        },
        set current(n) {
          var i = r.value;
          i !== n && (r.value = n, r.callback(n, i));
        }
      }
    };
  })[0];
  return r.callback = t, r.facade;
}
function ll(e, t) {
  return ul(t || null, function(r) {
    return e.forEach(function(n) {
      return cl(n, r);
    });
  });
}
var Vn = function() {
  return Vn = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o]);
    }
    return t;
  }, Vn.apply(this, arguments);
};
function fl(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
}
var ci = { exports: {} }, fn = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gs;
function dl() {
  if (gs)
    return fn;
  gs = 1;
  var e = Ct, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(u, f, p) {
    var g, y = {}, A = null, S = null;
    p !== void 0 && (A = "" + p), f.key !== void 0 && (A = "" + f.key), f.ref !== void 0 && (S = f.ref);
    for (g in f)
      n.call(f, g) && !o.hasOwnProperty(g) && (y[g] = f[g]);
    if (u && u.defaultProps)
      for (g in f = u.defaultProps, f)
        y[g] === void 0 && (y[g] = f[g]);
    return { $$typeof: t, type: u, key: A, ref: S, props: y, _owner: i.current };
  }
  return fn.Fragment = r, fn.jsx = a, fn.jsxs = a, fn;
}
var dn = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ys;
function hl() {
  return ys || (ys = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ct, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), u = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), y = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), S = Symbol.for("react.offscreen"), I = Symbol.iterator, D = "@@iterator";
    function L(c) {
      if (c === null || typeof c != "object")
        return null;
      var v = I && c[I] || c[D];
      return typeof v == "function" ? v : null;
    }
    var Y = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function M(c) {
      {
        for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), j = 1; j < v; j++)
          m[j - 1] = arguments[j];
        N("error", c, m);
      }
    }
    function N(c, v, m) {
      {
        var j = Y.ReactDebugCurrentFrame, z = j.getStackAddendum();
        z !== "" && (v += "%s", m = m.concat([z]));
        var re = m.map(function(V) {
          return String(V);
        });
        re.unshift("Warning: " + v), Function.prototype.apply.call(console[c], console, re);
      }
    }
    var b = !1, k = !1, O = !1, R = !1, Q = !1, G;
    G = Symbol.for("react.module.reference");
    function B(c) {
      return !!(typeof c == "string" || typeof c == "function" || c === n || c === o || Q || c === i || c === p || c === g || R || c === S || b || k || O || typeof c == "object" && c !== null && (c.$$typeof === A || c.$$typeof === y || c.$$typeof === a || c.$$typeof === u || c.$$typeof === f || c.$$typeof === G || c.getModuleId !== void 0));
    }
    function E(c, v, m) {
      var j = c.displayName;
      if (j)
        return j;
      var z = v.displayName || v.name || "";
      return z !== "" ? m + "(" + z + ")" : m;
    }
    function T(c) {
      return c.displayName || "Context";
    }
    function C(c) {
      if (c == null)
        return null;
      if (typeof c.tag == "number" && M("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function")
        return c.displayName || c.name || null;
      if (typeof c == "string")
        return c;
      switch (c) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case p:
          return "Suspense";
        case g:
          return "SuspenseList";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case u:
            var v = c;
            return T(v) + ".Consumer";
          case a:
            var m = c;
            return T(m._context) + ".Provider";
          case f:
            return E(c, c.render, "ForwardRef");
          case y:
            var j = c.displayName || null;
            return j !== null ? j : C(c.type) || "Memo";
          case A: {
            var z = c, re = z._payload, V = z._init;
            try {
              return C(V(re));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var K = Object.assign, $ = 0, W, _, ee, x, F, H, oe;
    function ae() {
    }
    ae.__reactDisabledLog = !0;
    function ne() {
      {
        if ($ === 0) {
          W = console.log, _ = console.info, ee = console.warn, x = console.error, F = console.group, H = console.groupCollapsed, oe = console.groupEnd;
          var c = {
            configurable: !0,
            enumerable: !0,
            value: ae,
            writable: !0
          };
          Object.defineProperties(console, {
            info: c,
            log: c,
            warn: c,
            error: c,
            group: c,
            groupCollapsed: c,
            groupEnd: c
          });
        }
        $++;
      }
    }
    function J() {
      {
        if ($--, $ === 0) {
          var c = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: K({}, c, {
              value: W
            }),
            info: K({}, c, {
              value: _
            }),
            warn: K({}, c, {
              value: ee
            }),
            error: K({}, c, {
              value: x
            }),
            group: K({}, c, {
              value: F
            }),
            groupCollapsed: K({}, c, {
              value: H
            }),
            groupEnd: K({}, c, {
              value: oe
            })
          });
        }
        $ < 0 && M("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ce = Y.ReactCurrentDispatcher, _e;
    function Ne(c, v, m) {
      {
        if (_e === void 0)
          try {
            throw Error();
          } catch (z) {
            var j = z.stack.trim().match(/\n( *(at )?)/);
            _e = j && j[1] || "";
          }
        return `
` + _e + c;
      }
    }
    var Ee = !1, qe;
    {
      var $e = typeof WeakMap == "function" ? WeakMap : Map;
      qe = new $e();
    }
    function et(c, v) {
      if (!c || Ee)
        return "";
      {
        var m = qe.get(c);
        if (m !== void 0)
          return m;
      }
      var j;
      Ee = !0;
      var z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var re;
      re = ce.current, ce.current = null, ne();
      try {
        if (v) {
          var V = function() {
            throw Error();
          };
          if (Object.defineProperty(V.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(V, []);
            } catch (Me) {
              j = Me;
            }
            Reflect.construct(c, [], V);
          } else {
            try {
              V.call();
            } catch (Me) {
              j = Me;
            }
            c.call(V.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Me) {
            j = Me;
          }
          c();
        }
      } catch (Me) {
        if (Me && j && typeof Me.stack == "string") {
          for (var fe = Me.stack.split(`
`), ie = j.stack.split(`
`), pe = fe.length - 1, ye = ie.length - 1; pe >= 1 && ye >= 0 && fe[pe] !== ie[ye]; )
            ye--;
          for (; pe >= 1 && ye >= 0; pe--, ye--)
            if (fe[pe] !== ie[ye]) {
              if (pe !== 1 || ye !== 1)
                do
                  if (pe--, ye--, ye < 0 || fe[pe] !== ie[ye]) {
                    var Ae = `
` + fe[pe].replace(" at new ", " at ");
                    return c.displayName && Ae.includes("<anonymous>") && (Ae = Ae.replace("<anonymous>", c.displayName)), typeof c == "function" && qe.set(c, Ae), Ae;
                  }
                while (pe >= 1 && ye >= 0);
              break;
            }
        }
      } finally {
        Ee = !1, ce.current = re, J(), Error.prepareStackTrace = z;
      }
      var Te = c ? c.displayName || c.name : "", Ie = Te ? Ne(Te) : "";
      return typeof c == "function" && qe.set(c, Ie), Ie;
    }
    function se(c, v, m) {
      return et(c, !1);
    }
    function he(c) {
      var v = c.prototype;
      return !!(v && v.isReactComponent);
    }
    function Oe(c, v, m) {
      if (c == null)
        return "";
      if (typeof c == "function")
        return et(c, he(c));
      if (typeof c == "string")
        return Ne(c);
      switch (c) {
        case p:
          return Ne("Suspense");
        case g:
          return Ne("SuspenseList");
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case f:
            return se(c.render);
          case y:
            return Oe(c.type, v, m);
          case A: {
            var j = c, z = j._payload, re = j._init;
            try {
              return Oe(re(z), v, m);
            } catch {
            }
          }
        }
      return "";
    }
    var We = Object.prototype.hasOwnProperty, Fe = {}, Ge = Y.ReactDebugCurrentFrame;
    function Ke(c) {
      if (c) {
        var v = c._owner, m = Oe(c.type, c._source, v ? v.type : null);
        Ge.setExtraStackFrame(m);
      } else
        Ge.setExtraStackFrame(null);
    }
    function rt(c, v, m, j, z) {
      {
        var re = Function.call.bind(We);
        for (var V in c)
          if (re(c, V)) {
            var fe = void 0;
            try {
              if (typeof c[V] != "function") {
                var ie = Error((j || "React class") + ": " + m + " type `" + V + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[V] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ie.name = "Invariant Violation", ie;
              }
              fe = c[V](v, V, j, m, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (pe) {
              fe = pe;
            }
            fe && !(fe instanceof Error) && (Ke(z), M("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", j || "React class", m, V, typeof fe), Ke(null)), fe instanceof Error && !(fe.message in Fe) && (Fe[fe.message] = !0, Ke(z), M("Failed %s type: %s", m, fe.message), Ke(null));
          }
      }
    }
    var Nt = Array.isArray;
    function vt(c) {
      return Nt(c);
    }
    function kt(c) {
      {
        var v = typeof Symbol == "function" && Symbol.toStringTag, m = v && c[Symbol.toStringTag] || c.constructor.name || "Object";
        return m;
      }
    }
    function _t(c) {
      try {
        return Tt(c), !1;
      } catch {
        return !0;
      }
    }
    function Tt(c) {
      return "" + c;
    }
    function Zt(c) {
      if (_t(c))
        return M("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", kt(c)), Tt(c);
    }
    var gt = Y.ReactCurrentOwner, Ft = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, xt, $t, zt;
    zt = {};
    function Xt(c) {
      if (We.call(c, "ref")) {
        var v = Object.getOwnPropertyDescriptor(c, "ref").get;
        if (v && v.isReactWarning)
          return !1;
      }
      return c.ref !== void 0;
    }
    function or(c) {
      if (We.call(c, "key")) {
        var v = Object.getOwnPropertyDescriptor(c, "key").get;
        if (v && v.isReactWarning)
          return !1;
      }
      return c.key !== void 0;
    }
    function Jt(c, v) {
      if (typeof c.ref == "string" && gt.current && v && gt.current.stateNode !== v) {
        var m = C(gt.current.type);
        zt[m] || (M('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', C(gt.current.type), c.ref), zt[m] = !0);
      }
    }
    function dr(c, v) {
      {
        var m = function() {
          xt || (xt = !0, M("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", v));
        };
        m.isReactWarning = !0, Object.defineProperty(c, "key", {
          get: m,
          configurable: !0
        });
      }
    }
    function Or(c, v) {
      {
        var m = function() {
          $t || ($t = !0, M("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", v));
        };
        m.isReactWarning = !0, Object.defineProperty(c, "ref", {
          get: m,
          configurable: !0
        });
      }
    }
    var Fr = function(c, v, m, j, z, re, V) {
      var fe = {
        $$typeof: t,
        type: c,
        key: v,
        ref: m,
        props: V,
        _owner: re
      };
      return fe._store = {}, Object.defineProperty(fe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(fe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: j
      }), Object.defineProperty(fe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: z
      }), Object.freeze && (Object.freeze(fe.props), Object.freeze(fe)), fe;
    };
    function Dr(c, v, m, j, z) {
      {
        var re, V = {}, fe = null, ie = null;
        m !== void 0 && (Zt(m), fe = "" + m), or(v) && (Zt(v.key), fe = "" + v.key), Xt(v) && (ie = v.ref, Jt(v, z));
        for (re in v)
          We.call(v, re) && !Ft.hasOwnProperty(re) && (V[re] = v[re]);
        if (c && c.defaultProps) {
          var pe = c.defaultProps;
          for (re in pe)
            V[re] === void 0 && (V[re] = pe[re]);
        }
        if (fe || ie) {
          var ye = typeof c == "function" ? c.displayName || c.name || "Unknown" : c;
          fe && dr(V, ye), ie && Or(V, ye);
        }
        return Fr(c, fe, ie, z, j, gt.current, V);
      }
    }
    var sr = Y.ReactCurrentOwner, zr = Y.ReactDebugCurrentFrame;
    function ar(c) {
      if (c) {
        var v = c._owner, m = Oe(c.type, c._source, v ? v.type : null);
        zr.setExtraStackFrame(m);
      } else
        zr.setExtraStackFrame(null);
    }
    var sn;
    sn = !1;
    function an(c) {
      return typeof c == "object" && c !== null && c.$$typeof === t;
    }
    function Qt() {
      {
        if (sr.current) {
          var c = C(sr.current.type);
          if (c)
            return `

Check the render method of \`` + c + "`.";
        }
        return "";
      }
    }
    function cr(c) {
      {
        if (c !== void 0) {
          var v = c.fileName.replace(/^.*[\\\/]/, ""), m = c.lineNumber;
          return `

Check your code at ` + v + ":" + m + ".";
        }
        return "";
      }
    }
    var ur = {};
    function cn(c) {
      {
        var v = Qt();
        if (!v) {
          var m = typeof c == "string" ? c : c.displayName || c.name;
          m && (v = `

Check the top-level render call using <` + m + ">.");
        }
        return v;
      }
    }
    function Qr(c, v) {
      {
        if (!c._store || c._store.validated || c.key != null)
          return;
        c._store.validated = !0;
        var m = cn(v);
        if (ur[m])
          return;
        ur[m] = !0;
        var j = "";
        c && c._owner && c._owner !== sr.current && (j = " It was passed a child from " + C(c._owner.type) + "."), ar(c), M('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', m, j), ar(null);
      }
    }
    function un(c, v) {
      {
        if (typeof c != "object")
          return;
        if (vt(c))
          for (var m = 0; m < c.length; m++) {
            var j = c[m];
            an(j) && Qr(j, v);
          }
        else if (an(c))
          c._store && (c._store.validated = !0);
        else if (c) {
          var z = L(c);
          if (typeof z == "function" && z !== c.entries)
            for (var re = z.call(c), V; !(V = re.next()).done; )
              an(V.value) && Qr(V.value, v);
        }
      }
    }
    function Oi(c) {
      {
        var v = c.type;
        if (v == null || typeof v == "string")
          return;
        var m;
        if (typeof v == "function")
          m = v.propTypes;
        else if (typeof v == "object" && (v.$$typeof === f || v.$$typeof === y))
          m = v.propTypes;
        else
          return;
        if (m) {
          var j = C(v);
          rt(m, c.props, "prop", j, c);
        } else if (v.PropTypes !== void 0 && !sn) {
          sn = !0;
          var z = C(v);
          M("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", z || "Unknown");
        }
        typeof v.getDefaultProps == "function" && !v.getDefaultProps.isReactClassApproved && M("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function It(c) {
      {
        for (var v = Object.keys(c.props), m = 0; m < v.length; m++) {
          var j = v[m];
          if (j !== "children" && j !== "key") {
            ar(c), M("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", j), ar(null);
            break;
          }
        }
        c.ref !== null && (ar(c), M("Invalid attribute `ref` supplied to `React.Fragment`."), ar(null));
      }
    }
    function ln(c, v, m, j, z, re) {
      {
        var V = B(c);
        if (!V) {
          var fe = "";
          (c === void 0 || typeof c == "object" && c !== null && Object.keys(c).length === 0) && (fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ie = cr(z);
          ie ? fe += ie : fe += Qt();
          var pe;
          c === null ? pe = "null" : vt(c) ? pe = "array" : c !== void 0 && c.$$typeof === t ? (pe = "<" + (C(c.type) || "Unknown") + " />", fe = " Did you accidentally export a JSX literal instead of a component?") : pe = typeof c, M("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", pe, fe);
        }
        var ye = Dr(c, v, m, z, re);
        if (ye == null)
          return ye;
        if (V) {
          var Ae = v.children;
          if (Ae !== void 0)
            if (j)
              if (vt(Ae)) {
                for (var Te = 0; Te < Ae.length; Te++)
                  un(Ae[Te], c);
                Object.freeze && Object.freeze(Ae);
              } else
                M("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              un(Ae, c);
        }
        return c === n ? It(ye) : Oi(ye), ye;
      }
    }
    function l(c, v, m) {
      return ln(c, v, m, !0);
    }
    function h(c, v, m) {
      return ln(c, v, m, !1);
    }
    var d = h, s = l;
    dn.Fragment = n, dn.jsx = d, dn.jsxs = s;
  }()), dn;
}
(function(e) {
  process.env.NODE_ENV === "production" ? e.exports = dl() : e.exports = hl();
})(ci);
const Gn = ci.exports.Fragment, ge = ci.exports.jsx, ct = ci.exports.jsxs;
function pl(e) {
  return e;
}
function gl(e, t) {
  t === void 0 && (t = pl);
  var r = [], n = !1, i = {
    read: function() {
      if (n)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return r.length ? r[r.length - 1] : e;
    },
    useMedium: function(o) {
      var a = t(o, n);
      return r.push(a), function() {
        r = r.filter(function(u) {
          return u !== a;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (n = !0; r.length; ) {
        var a = r;
        r = [], a.forEach(o);
      }
      r = {
        push: function(u) {
          return o(u);
        },
        filter: function() {
          return r;
        }
      };
    },
    assignMedium: function(o) {
      n = !0;
      var a = [];
      if (r.length) {
        var u = r;
        r = [], u.forEach(o), a = r;
      }
      var f = function() {
        var g = a;
        a = [], g.forEach(o);
      }, p = function() {
        return Promise.resolve().then(f);
      };
      p(), r = {
        push: function(g) {
          a.push(g), p();
        },
        filter: function(g) {
          return a = a.filter(g), r;
        }
      };
    }
  };
  return i;
}
function yl(e) {
  e === void 0 && (e = {});
  var t = gl(null);
  return t.options = Vn({ async: !0, ssr: !1 }, e), t;
}
var ma = function(e) {
  var t = e.sideCar, r = fl(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var n = t.read();
  if (!n)
    throw new Error("Sidecar medium not found");
  return /* @__PURE__ */ ge(n, {
    ...Vn({}, r)
  });
};
ma.isSideCarExport = !0;
function bl(e, t) {
  return e.useMedium(t), ma;
}
var wa = yl(), Li = function() {
}, ui = Xe.forwardRef(function(e, t) {
  var r = Xe.useRef(null), n = Xe.useState({
    onScrollCapture: Li,
    onWheelCapture: Li,
    onTouchMoveCapture: Li
  }), i = n[0], o = n[1], a = e.forwardProps, u = e.children, f = e.className, p = e.removeScrollBar, g = e.enabled, y = e.shards, A = e.sideCar, S = e.noIsolation, I = e.inert, D = e.allowPinchZoom, L = e.as, Y = L === void 0 ? "div" : L, M = il(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), N = A, b = ll([r, t]), k = Mr(Mr({}, M), i);
  return /* @__PURE__ */ ct(Gn, {
    children: [g && /* @__PURE__ */ ge(N, {
      sideCar: wa,
      removeScrollBar: p,
      shards: y,
      noIsolation: S,
      inert: I,
      setCallbacks: o,
      allowPinchZoom: !!D,
      lockRef: r
    }), a ? Xe.cloneElement(Xe.Children.only(u), Mr(Mr({}, k), {
      ref: b
    })) : /* @__PURE__ */ ge(Y, {
      ...Mr({}, k, {
        className: f,
        ref: b
      }),
      children: u
    })]
  });
});
ui.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
ui.classNames = {
  fullWidth: Fn,
  zeroRight: _n
};
var vl = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function ml() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = vl();
  return t && e.setAttribute("nonce", t), e;
}
function wl(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function El(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Al = function() {
  var e = 0, t = null;
  return {
    add: function(r) {
      e == 0 && (t = ml()) && (wl(t, r), El(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Ml = function() {
  var e = Al();
  return function(t, r) {
    Xe.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && r]);
  };
}, Ea = function() {
  var e = Ml(), t = function(r) {
    var n = r.styles, i = r.dynamic;
    return e(n, i), null;
  };
  return t;
}, Sl = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Bi = function(e) {
  return parseInt(e || "", 10) || 0;
}, Nl = function(e) {
  var t = window.getComputedStyle(document.body);
  process.env.NODE_ENV !== "production" && t.overflowY === "hidden" && console.error("react-remove-scroll-bar: cannot calculate scrollbar size because it is removed (overflow:hidden on body");
  var r = t[e === "padding" ? "paddingLeft" : "marginLeft"], n = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Bi(r), Bi(n), Bi(i)];
}, Tl = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Sl;
  var t = Nl(e), r = document.documentElement.clientWidth, n = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, n - r + t[2] - t[0])
  };
}, Il = Ea(), Ol = function(e, t, r, n) {
  var i = e.left, o = e.top, a = e.right, u = e.gap;
  return r === void 0 && (r = "margin"), `
  .`.concat(sl, ` {
   overflow: hidden `).concat(n, `;
   padding-right: `).concat(u, "px ").concat(n, `;
  }
  body {
    overflow: hidden `).concat(n, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(n, ";"), r === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(n, `;
    `), r === "padding" && "padding-right: ".concat(u, "px ").concat(n, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(_n, ` {
    right: `).concat(u, "px ").concat(n, `;
  }
  
  .`).concat(Fn, ` {
    margin-right: `).concat(u, "px ").concat(n, `;
  }
  
  .`).concat(_n, " .").concat(_n, ` {
    right: 0 `).concat(n, `;
  }
  
  .`).concat(Fn, " .").concat(Fn, ` {
    margin-right: 0 `).concat(n, `;
  }
  
  body {
    `).concat(al, ": ").concat(u, `px;
  }
`);
}, Dl = function(e) {
  var t = e.noRelative, r = e.noImportant, n = e.gapMode, i = n === void 0 ? "margin" : n, o = Xe.useMemo(function() {
    return Tl(i);
  }, [i]);
  return /* @__PURE__ */ ge(Il, {
    styles: Ol(o, !t, i, r ? "" : "!important")
  });
}, Ji = !1;
if (typeof window < "u")
  try {
    var jn = Object.defineProperty({}, "passive", {
      get: function() {
        return Ji = !0, !0;
      }
    });
    window.addEventListener("test", jn, jn), window.removeEventListener("test", jn, jn);
  } catch {
    Ji = !1;
  }
var Wr = Ji ? { passive: !1 } : !1, Cl = function(e) {
  return e.tagName === "TEXTAREA";
}, Aa = function(e, t) {
  var r = window.getComputedStyle(e);
  return r[t] !== "hidden" && !(r.overflowY === r.overflowX && !Cl(e) && r[t] === "visible");
}, jl = function(e) {
  return Aa(e, "overflowY");
}, xl = function(e) {
  return Aa(e, "overflowX");
}, bs = function(e, t) {
  var r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var n = Ma(e, r);
    if (n) {
      var i = Sa(e, r), o = i[1], a = i[2];
      if (o > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== document.body);
  return !1;
}, Ll = function(e) {
  var t = e.scrollTop, r = e.scrollHeight, n = e.clientHeight;
  return [
    t,
    r,
    n
  ];
}, Bl = function(e) {
  var t = e.scrollLeft, r = e.scrollWidth, n = e.clientWidth;
  return [
    t,
    r,
    n
  ];
}, Ma = function(e, t) {
  return e === "v" ? jl(t) : xl(t);
}, Sa = function(e, t) {
  return e === "v" ? Ll(t) : Bl(t);
}, Rl = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, Ul = function(e, t, r, n, i) {
  var o = Rl(e, window.getComputedStyle(t).direction), a = o * n, u = r.target, f = t.contains(u), p = !1, g = a > 0, y = 0, A = 0;
  do {
    var S = Sa(e, u), I = S[0], D = S[1], L = S[2], Y = D - L - o * I;
    (I || Y) && Ma(e, u) && (y += Y, A += I), u = u.parentNode;
  } while (!f && u !== document.body || f && (t.contains(u) || t === u));
  return (g && (i && y === 0 || !i && a > y) || !g && (i && A === 0 || !i && -a > A)) && (p = !0), p;
}, xn = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, vs = function(e) {
  return [e.deltaX, e.deltaY];
}, ms = function(e) {
  return e && "current" in e ? e.current : e;
}, Pl = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, kl = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, _l = 0, Yr = [];
function Fl(e) {
  var t = Xe.useRef([]), r = Xe.useRef([0, 0]), n = Xe.useRef(), i = Xe.useState(_l++)[0], o = Xe.useState(function() {
    return Ea();
  })[0], a = Xe.useRef(e);
  Xe.useEffect(function() {
    a.current = e;
  }, [e]), Xe.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var D = ol([e.lockRef.current], (e.shards || []).map(ms), !0).filter(Boolean);
      return D.forEach(function(L) {
        return L.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), D.forEach(function(L) {
          return L.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var u = Xe.useCallback(function(D, L) {
    if ("touches" in D && D.touches.length === 2)
      return !a.current.allowPinchZoom;
    var Y = xn(D), M = r.current, N = "deltaX" in D ? D.deltaX : M[0] - Y[0], b = "deltaY" in D ? D.deltaY : M[1] - Y[1], k, O = D.target, R = Math.abs(N) > Math.abs(b) ? "h" : "v";
    if ("touches" in D && R === "h" && O.type === "range")
      return !1;
    var Q = bs(R, O);
    if (!Q)
      return !0;
    if (Q ? k = R : (k = R === "v" ? "h" : "v", Q = bs(R, O)), !Q)
      return !1;
    if (!n.current && "changedTouches" in D && (N || b) && (n.current = k), !k)
      return !0;
    var G = n.current || k;
    return Ul(G, L, D, G === "h" ? N : b, !0);
  }, []), f = Xe.useCallback(function(D) {
    var L = D;
    if (!(!Yr.length || Yr[Yr.length - 1] !== o)) {
      var Y = "deltaY" in L ? vs(L) : xn(L), M = t.current.filter(function(k) {
        return k.name === L.type && k.target === L.target && Pl(k.delta, Y);
      })[0];
      if (M && M.should) {
        L.cancelable && L.preventDefault();
        return;
      }
      if (!M) {
        var N = (a.current.shards || []).map(ms).filter(Boolean).filter(function(k) {
          return k.contains(L.target);
        }), b = N.length > 0 ? u(L, N[0]) : !a.current.noIsolation;
        b && L.cancelable && L.preventDefault();
      }
    }
  }, []), p = Xe.useCallback(function(D, L, Y, M) {
    var N = {
      name: D,
      delta: L,
      target: Y,
      should: M
    };
    t.current.push(N), setTimeout(function() {
      t.current = t.current.filter(function(b) {
        return b !== N;
      });
    }, 1);
  }, []), g = Xe.useCallback(function(D) {
    r.current = xn(D), n.current = void 0;
  }, []), y = Xe.useCallback(function(D) {
    p(D.type, vs(D), D.target, u(D, e.lockRef.current));
  }, []), A = Xe.useCallback(function(D) {
    p(D.type, xn(D), D.target, u(D, e.lockRef.current));
  }, []);
  Xe.useEffect(function() {
    return Yr.push(o), e.setCallbacks({
      onScrollCapture: y,
      onWheelCapture: y,
      onTouchMoveCapture: A
    }), document.addEventListener("wheel", f, Wr), document.addEventListener("touchmove", f, Wr), document.addEventListener("touchstart", g, Wr), function() {
      Yr = Yr.filter(function(D) {
        return D !== o;
      }), document.removeEventListener("wheel", f, Wr), document.removeEventListener("touchmove", f, Wr), document.removeEventListener("touchstart", g, Wr);
    };
  }, []);
  var S = e.removeScrollBar, I = e.inert;
  return /* @__PURE__ */ ct(Gn, {
    children: [I ? /* @__PURE__ */ ge(o, {
      styles: kl(i)
    }) : null, S ? /* @__PURE__ */ ge(Dl, {
      gapMode: "margin"
    }) : null]
  });
}
const zl = bl(wa, Fl);
var Na = Xe.forwardRef(function(e, t) {
  return /* @__PURE__ */ ge(ui, {
    ...Mr({}, e, {
      ref: t,
      sideCar: zl
    })
  });
});
Na.classNames = ui.classNames;
const Ql = Na;
var Wl = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Hr = /* @__PURE__ */ new WeakMap(), Ln = /* @__PURE__ */ new WeakMap(), Bn = {}, Ri = 0, Yl = function(e, t, r, n) {
  var i = Array.isArray(e) ? e : [e];
  Bn[r] || (Bn[r] = /* @__PURE__ */ new WeakMap());
  var o = Bn[r], a = [], u = /* @__PURE__ */ new Set(), f = new Set(i), p = function(y) {
    !y || u.has(y) || (u.add(y), p(y.parentNode));
  };
  i.forEach(p);
  var g = function(y) {
    !y || f.has(y) || Array.prototype.forEach.call(y.children, function(A) {
      if (u.has(A))
        g(A);
      else {
        var S = A.getAttribute(n), I = S !== null && S !== "false", D = (Hr.get(A) || 0) + 1, L = (o.get(A) || 0) + 1;
        Hr.set(A, D), o.set(A, L), a.push(A), D === 1 && I && Ln.set(A, !0), L === 1 && A.setAttribute(r, "true"), I || A.setAttribute(n, "true");
      }
    });
  };
  return g(t), u.clear(), Ri++, function() {
    a.forEach(function(y) {
      var A = Hr.get(y) - 1, S = o.get(y) - 1;
      Hr.set(y, A), o.set(y, S), A || (Ln.has(y) || y.removeAttribute(n), Ln.delete(y)), S || y.removeAttribute(r);
    }), Ri--, Ri || (Hr = /* @__PURE__ */ new WeakMap(), Hr = /* @__PURE__ */ new WeakMap(), Ln = /* @__PURE__ */ new WeakMap(), Bn = {});
  };
}, Hl = function(e, t, r) {
  r === void 0 && (r = "data-aria-hidden");
  var n = Array.from(Array.isArray(e) ? e : [e]), i = t || Wl(e);
  return i ? (n.push.apply(n, Array.from(i.querySelectorAll("[aria-live]"))), Yl(n, i, r, "aria-hidden")) : function() {
    return null;
  };
};
const Ta = "Dialog", [Ia, z1] = Du(Ta), [ql, ir] = Ia(Ta), Zl = (e) => {
  const { __scopeDialog: t, children: r, open: n, defaultOpen: i, onOpenChange: o, modal: a = !0 } = e, u = ht(null), f = ht(null), [p = !1, g] = Lu({
    prop: n,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ Ve(ql, {
    scope: t,
    triggerRef: u,
    contentRef: f,
    contentId: Di(),
    titleId: Di(),
    descriptionId: Di(),
    open: p,
    onOpenChange: g,
    onOpenToggle: St(
      () => g(
        (y) => !y
      ),
      [
        g
      ]
    ),
    modal: a
  }, r);
}, Kl = "DialogTrigger", Vl = /* @__PURE__ */ jt((e, t) => {
  const { __scopeDialog: r, ...n } = e, i = ir(Kl, r), o = tn(t, i.triggerRef);
  return /* @__PURE__ */ Ve(kr.button, Be({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": i.open,
    "aria-controls": i.contentId,
    "data-state": Eo(i.open)
  }, n, {
    ref: o,
    onClick: Nr(e.onClick, i.onOpenToggle)
  }));
}), Oa = "DialogPortal", [Gl, Da] = Ia(Oa, {
  forceMount: void 0
}), $l = (e) => {
  const { __scopeDialog: t, forceMount: r, children: n, container: i } = e, o = ir(Oa, t);
  return /* @__PURE__ */ Ve(Gl, {
    scope: t,
    forceMount: r
  }, Br.map(
    n,
    (a) => /* @__PURE__ */ Ve(ai, {
      present: r || o.open
    }, /* @__PURE__ */ Ve(el, {
      asChild: !0,
      container: i
    }, a))
  ));
}, eo = "DialogOverlay", Xl = /* @__PURE__ */ jt((e, t) => {
  const r = Da(eo, e.__scopeDialog), { forceMount: n = r.forceMount, ...i } = e, o = ir(eo, e.__scopeDialog);
  return o.modal ? /* @__PURE__ */ Ve(ai, {
    present: n || o.open
  }, /* @__PURE__ */ Ve(Jl, Be({}, i, {
    ref: t
  }))) : null;
}), Jl = /* @__PURE__ */ jt((e, t) => {
  const { __scopeDialog: r, ...n } = e, i = ir(eo, r);
  return /* @__PURE__ */ Ve(Ql, {
    as: wo,
    allowPinchZoom: !0,
    shards: [
      i.contentRef
    ]
  }, /* @__PURE__ */ Ve(kr.div, Be({
    "data-state": Eo(i.open)
  }, n, {
    ref: t,
    style: {
      pointerEvents: "auto",
      ...n.style
    }
  })));
}), mn = "DialogContent", ef = /* @__PURE__ */ jt((e, t) => {
  const r = Da(mn, e.__scopeDialog), { forceMount: n = r.forceMount, ...i } = e, o = ir(mn, e.__scopeDialog);
  return /* @__PURE__ */ Ve(ai, {
    present: n || o.open
  }, o.modal ? /* @__PURE__ */ Ve(tf, Be({}, i, {
    ref: t
  })) : /* @__PURE__ */ Ve(rf, Be({}, i, {
    ref: t
  })));
}), tf = /* @__PURE__ */ jt((e, t) => {
  const r = ir(mn, e.__scopeDialog), n = ht(null), i = tn(t, r.contentRef, n);
  return pt(() => {
    const o = n.current;
    if (o)
      return Hl(o);
  }, []), /* @__PURE__ */ Ve(Ca, Be({}, e, {
    ref: i,
    trapFocus: r.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: Nr(e.onCloseAutoFocus, (o) => {
      var a;
      o.preventDefault(), (a = r.triggerRef.current) === null || a === void 0 || a.focus();
    }),
    onPointerDownOutside: Nr(e.onPointerDownOutside, (o) => {
      const a = o.detail.originalEvent, u = a.button === 0 && a.ctrlKey === !0;
      (a.button === 2 || u) && o.preventDefault();
    }),
    onFocusOutside: Nr(
      e.onFocusOutside,
      (o) => o.preventDefault()
    )
  }));
}), rf = /* @__PURE__ */ jt((e, t) => {
  const r = ir(mn, e.__scopeDialog), n = ht(!1);
  return /* @__PURE__ */ Ve(Ca, Be({}, e, {
    ref: t,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (i) => {
      var o;
      if ((o = e.onCloseAutoFocus) === null || o === void 0 || o.call(e, i), !i.defaultPrevented) {
        var a;
        n.current || (a = r.triggerRef.current) === null || a === void 0 || a.focus(), i.preventDefault();
      }
      n.current = !1;
    },
    onInteractOutside: (i) => {
      var o, a;
      (o = e.onInteractOutside) === null || o === void 0 || o.call(e, i), i.defaultPrevented || (n.current = !0);
      const u = i.target;
      ((a = r.triggerRef.current) === null || a === void 0 ? void 0 : a.contains(u)) && i.preventDefault();
    }
  }));
}), Ca = /* @__PURE__ */ jt((e, t) => {
  const { __scopeDialog: r, trapFocus: n, onOpenAutoFocus: i, onCloseAutoFocus: o, ...a } = e, u = ir(mn, r), f = ht(null), p = tn(t, f);
  return nl(), /* @__PURE__ */ Ve(ua, null, /* @__PURE__ */ Ve(Zu, {
    asChild: !0,
    loop: !0,
    trapped: n,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o
  }, /* @__PURE__ */ Ve(Yu, Be({
    role: "dialog",
    id: u.contentId,
    "aria-describedby": u.descriptionId,
    "aria-labelledby": u.titleId,
    "data-state": Eo(u.open)
  }, a, {
    ref: p,
    onDismiss: () => u.onOpenChange(!1)
  }))), !1);
}), nf = "DialogTitle", of = /* @__PURE__ */ jt((e, t) => {
  const { __scopeDialog: r, ...n } = e, i = ir(nf, r);
  return /* @__PURE__ */ Ve(kr.h2, Be({
    id: i.titleId
  }, n, {
    ref: t
  }));
}), sf = "DialogClose", af = /* @__PURE__ */ jt((e, t) => {
  const { __scopeDialog: r, ...n } = e, i = ir(sf, r);
  return /* @__PURE__ */ Ve(kr.button, Be({
    type: "button"
  }, n, {
    ref: t,
    onClick: Nr(
      e.onClick,
      () => i.onOpenChange(!1)
    )
  }));
});
function Eo(e) {
  return e ? "open" : "closed";
}
const cf = Zl, uf = Vl, lf = $l, ff = Xl, df = ef, wn = of, hf = af, pf = (e) => /* @__PURE__ */ ct(cf, {
  open: e.open,
  onOpenChange: e.onOpenChange,
  children: [/* @__PURE__ */ ge(uf, {
    asChild: !0,
    children: e.trigger
  }), /* @__PURE__ */ ge(lf, {
    children: /* @__PURE__ */ ge(ff, {
      className: "wkit-dialog__overlay",
      children: /* @__PURE__ */ ge(df, {
        ...e.contentProps,
        className: vn("wkit-dialog__content", e.className),
        style: e.style,
        children: e.children
      })
    })
  })]
});
function ja() {
  return /* @__PURE__ */ ge("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ ge("path", {
      d: "M15.8332 10.0003H4.1665M4.1665 10.0003L9.99984 15.8337M4.1665 10.0003L9.99984 4.16699",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function gf() {
  return /* @__PURE__ */ ge("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ ge("path", {
      d: "M15 5L5 15M5 5L15 15",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
}
function yf() {
  return /* @__PURE__ */ ct("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/* @__PURE__ */ ge("g", {
      clipPath: "url(#clip0_1790_28273)",
      children: /* @__PURE__ */ ge("path", {
        d: "M9.99989 10.9766L14.1249 6.85156L15.3032 8.0299L9.99989 13.3332L4.69656 8.0299L5.87489 6.85156L9.99989 10.9766Z",
        fill: "currentColor"
      })
    }), /* @__PURE__ */ ge("defs", {
      children: /* @__PURE__ */ ge("clipPath", {
        id: "clip0_1790_28273",
        children: /* @__PURE__ */ ge("rect", {
          width: "20",
          height: "20",
          fill: "white",
          transform: "translate(20) rotate(90)"
        })
      })
    })]
  });
}
var Kt = /* @__PURE__ */ ((e) => (e.DISCONNECTED = "disconnected", e.CONNECTED = "connected", e.CONNECTING = "connecting", e))(Kt || {}), bf = Object.defineProperty, vf = (e, t, r) => t in e ? bf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ws = (e, t, r) => (vf(e, typeof t != "symbol" ? t + "" : t, r), r), Gt = /* @__PURE__ */ ((e) => (e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.KIT__UNKNOWN_ERROR = "KIT.UNKNOWN_ERROR", e.WALLET__UNKNOWN_ERROR = "WALLET.UNKNOWN_ERROR", e.WALLET__CONNECT_ERROR = "WALLET.CONNECT_ERROR", e.WALLET__CONNECT_ERROR__USER_REJECTED = "WALLET.CONNECT_ERROR.USER_REJECTED", e.WALLET__DISCONNECT_ERROR = "WALLET.DISCONNECT_ERROR", e.WALLET__SIGN_TX_ERROR = "WALLET.SIGN_TX_ERROR", e.WALLET__SIGN_MSG_ERROR = "WALLET.SIGN_MSG_ERROR", e.WALLET__LISTEN_TO_EVENT_ERROR = "WALLET.LISTEN_TO_EVENT_ERROR", e.WALLET__METHOD_NOT_IMPLEMENTED_ERROR = "WALLET.METHOD_NOT_IMPLEMENTED_ERROR", e))(Gt || {});
class xa extends Error {
  constructor(t, r = "UNKNOWN_ERROR", n) {
    super(t), ws(this, "code"), ws(this, "details"), this.details = n, this.code = r, this.message = this.formatErrorStr(r, t, n);
  }
  formatErrorStr(t, r, n) {
    let i = `[${this.code}] ${r}`;
    return n && (i += " | details: " + JSON.stringify(n)), i;
  }
}
class Ot extends xa {
  constructor(t = "kit unknown error", r = "KIT.UNKNOWN_ERROR", n) {
    super(t, r, n);
  }
}
class jr extends xa {
  constructor(t = "wallet unknown error", r = "WALLET.UNKNOWN_ERROR", n) {
    super(t, r, n);
  }
}
class mf extends jr {
  constructor(t) {
    super(`wallet does not implement function: ${t}`, "WALLET.METHOD_NOT_IMPLEMENTED_ERROR");
  }
}
function hr(e) {
  return `Failed to call ${e}, missing context provider to run within`;
}
const wf = {
  configuredWallets: [],
  detectedWallets: [],
  allAvailableWallets: [],
  chains: [],
  chain: void 0,
  name: void 0,
  adapter: void 0,
  connecting: !1,
  connected: !1,
  account: void 0,
  status: Kt.DISCONNECTED,
  address: void 0,
  async select() {
    throw new Ot(hr("select"));
  },
  on() {
    throw new Ot(hr("on"));
  },
  async disconnect() {
    throw new Ot(hr("disconnect"));
  },
  getAccounts() {
    throw new Ot(hr("getAccounts"));
  },
  async signAndExecuteTransactionBlock() {
    throw new Ot(hr("signAndExecuteTransactionBlock"));
  },
  async signTransactionBlock() {
    throw new Ot(hr("signTransactionBlock"));
  },
  async signMessage() {
    throw new Ot(hr("signMessage"));
  },
  verifySignedMessage() {
    throw new Ot(hr("verifySignedMessage"));
  }
}, La = Zn(wf);
function Sn() {
  return vo(La);
}
function to(e, t) {
  return to = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, to(e, t);
}
function Nn(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, to(e, t);
}
var Tn = /* @__PURE__ */ function() {
  function e() {
    this.listeners = [];
  }
  var t = e.prototype;
  return t.subscribe = function(n) {
    var i = this, o = n || function() {
    };
    return this.listeners.push(o), this.onSubscribe(), function() {
      i.listeners = i.listeners.filter(function(a) {
        return a !== o;
      }), i.onUnsubscribe();
    };
  }, t.hasListeners = function() {
    return this.listeners.length > 0;
  }, t.onSubscribe = function() {
  }, t.onUnsubscribe = function() {
  }, e;
}(), $n = typeof window > "u";
function Mt() {
}
function Ef(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ro(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function Xn(e) {
  return Array.isArray(e) ? e : [e];
}
function Ba(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function zn(e, t, r) {
  return li(e) ? typeof t == "function" ? Be({}, r, {
    queryKey: e,
    queryFn: t
  }) : Be({}, t, {
    queryKey: e
  }) : e;
}
function Er(e, t, r) {
  return li(e) ? [Be({}, t, {
    queryKey: e
  }), r] : [e || {}, t];
}
function Af(e, t) {
  if (e === !0 && t === !0 || e == null && t == null)
    return "all";
  if (e === !1 && t === !1)
    return "none";
  var r = e ?? !t;
  return r ? "active" : "inactive";
}
function Es(e, t) {
  var r = e.active, n = e.exact, i = e.fetching, o = e.inactive, a = e.predicate, u = e.queryKey, f = e.stale;
  if (li(u)) {
    if (n) {
      if (t.queryHash !== Ao(u, t.options))
        return !1;
    } else if (!Jn(t.queryKey, u))
      return !1;
  }
  var p = Af(r, o);
  if (p === "none")
    return !1;
  if (p !== "all") {
    var g = t.isActive();
    if (p === "active" && !g || p === "inactive" && g)
      return !1;
  }
  return !(typeof f == "boolean" && t.isStale() !== f || typeof i == "boolean" && t.isFetching() !== i || a && !a(t));
}
function As(e, t) {
  var r = e.exact, n = e.fetching, i = e.predicate, o = e.mutationKey;
  if (li(o)) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (Lr(t.options.mutationKey) !== Lr(o))
        return !1;
    } else if (!Jn(t.options.mutationKey, o))
      return !1;
  }
  return !(typeof n == "boolean" && t.state.status === "loading" !== n || i && !i(t));
}
function Ao(e, t) {
  var r = t?.queryKeyHashFn || Lr;
  return r(e);
}
function Lr(e) {
  var t = Xn(e);
  return Mf(t);
}
function Mf(e) {
  return JSON.stringify(e, function(t, r) {
    return no(r) ? Object.keys(r).sort().reduce(function(n, i) {
      return n[i] = r[i], n;
    }, {}) : r;
  });
}
function Jn(e, t) {
  return Ra(Xn(e), Xn(t));
}
function Ra(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(function(r) {
    return !Ra(e[r], t[r]);
  }) : !1;
}
function ei(e, t) {
  if (e === t)
    return e;
  var r = Array.isArray(e) && Array.isArray(t);
  if (r || no(e) && no(t)) {
    for (var n = r ? e.length : Object.keys(e).length, i = r ? t : Object.keys(t), o = i.length, a = r ? [] : {}, u = 0, f = 0; f < o; f++) {
      var p = r ? f : i[f];
      a[p] = ei(e[p], t[p]), a[p] === e[p] && u++;
    }
    return n === o && u === n ? e : a;
  }
  return t;
}
function Sf(e, t) {
  if (e && !t || t && !e)
    return !1;
  for (var r in e)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function no(e) {
  if (!Ms(e))
    return !1;
  var t = e.constructor;
  if (typeof t > "u")
    return !0;
  var r = t.prototype;
  return !(!Ms(r) || !r.hasOwnProperty("isPrototypeOf"));
}
function Ms(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function li(e) {
  return typeof e == "string" || Array.isArray(e);
}
function Nf(e) {
  return new Promise(function(t) {
    setTimeout(t, e);
  });
}
function Ss(e) {
  Promise.resolve().then(e).catch(function(t) {
    return setTimeout(function() {
      throw t;
    });
  });
}
function Ua() {
  if (typeof AbortController == "function")
    return new AbortController();
}
var Tf = /* @__PURE__ */ function(e) {
  Nn(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.setup = function(i) {
      var o;
      if (!$n && ((o = window) == null ? void 0 : o.addEventListener)) {
        var a = function() {
          return i();
        };
        return window.addEventListener("visibilitychange", a, !1), window.addEventListener("focus", a, !1), function() {
          window.removeEventListener("visibilitychange", a), window.removeEventListener("focus", a);
        };
      }
    }, n;
  }
  var r = t.prototype;
  return r.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, r.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var i;
      (i = this.cleanup) == null || i.call(this), this.cleanup = void 0;
    }
  }, r.setEventListener = function(i) {
    var o, a = this;
    this.setup = i, (o = this.cleanup) == null || o.call(this), this.cleanup = i(function(u) {
      typeof u == "boolean" ? a.setFocused(u) : a.onFocus();
    });
  }, r.setFocused = function(i) {
    this.focused = i, i && this.onFocus();
  }, r.onFocus = function() {
    this.listeners.forEach(function(i) {
      i();
    });
  }, r.isFocused = function() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }, t;
}(Tn), bn = new Tf(), If = /* @__PURE__ */ function(e) {
  Nn(t, e);
  function t() {
    var n;
    return n = e.call(this) || this, n.setup = function(i) {
      var o;
      if (!$n && ((o = window) == null ? void 0 : o.addEventListener)) {
        var a = function() {
          return i();
        };
        return window.addEventListener("online", a, !1), window.addEventListener("offline", a, !1), function() {
          window.removeEventListener("online", a), window.removeEventListener("offline", a);
        };
      }
    }, n;
  }
  var r = t.prototype;
  return r.onSubscribe = function() {
    this.cleanup || this.setEventListener(this.setup);
  }, r.onUnsubscribe = function() {
    if (!this.hasListeners()) {
      var i;
      (i = this.cleanup) == null || i.call(this), this.cleanup = void 0;
    }
  }, r.setEventListener = function(i) {
    var o, a = this;
    this.setup = i, (o = this.cleanup) == null || o.call(this), this.cleanup = i(function(u) {
      typeof u == "boolean" ? a.setOnline(u) : a.onOnline();
    });
  }, r.setOnline = function(i) {
    this.online = i, i && this.onOnline();
  }, r.onOnline = function() {
    this.listeners.forEach(function(i) {
      i();
    });
  }, r.isOnline = function() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? !0 : navigator.onLine;
  }, t;
}(Tn), Qn = new If();
function Of(e) {
  return Math.min(1e3 * Math.pow(2, e), 3e4);
}
function ti(e) {
  return typeof e?.cancel == "function";
}
var Pa = function(t) {
  this.revert = t?.revert, this.silent = t?.silent;
};
function Wn(e) {
  return e instanceof Pa;
}
var ka = function(t) {
  var r = this, n = !1, i, o, a, u;
  this.abort = t.abort, this.cancel = function(A) {
    return i?.(A);
  }, this.cancelRetry = function() {
    n = !0;
  }, this.continueRetry = function() {
    n = !1;
  }, this.continue = function() {
    return o?.();
  }, this.failureCount = 0, this.isPaused = !1, this.isResolved = !1, this.isTransportCancelable = !1, this.promise = new Promise(function(A, S) {
    a = A, u = S;
  });
  var f = function(S) {
    r.isResolved || (r.isResolved = !0, t.onSuccess == null || t.onSuccess(S), o?.(), a(S));
  }, p = function(S) {
    r.isResolved || (r.isResolved = !0, t.onError == null || t.onError(S), o?.(), u(S));
  }, g = function() {
    return new Promise(function(S) {
      o = S, r.isPaused = !0, t.onPause == null || t.onPause();
    }).then(function() {
      o = void 0, r.isPaused = !1, t.onContinue == null || t.onContinue();
    });
  }, y = function A() {
    if (!r.isResolved) {
      var S;
      try {
        S = t.fn();
      } catch (I) {
        S = Promise.reject(I);
      }
      i = function(D) {
        if (!r.isResolved && (p(new Pa(D)), r.abort == null || r.abort(), ti(S)))
          try {
            S.cancel();
          } catch {
          }
      }, r.isTransportCancelable = ti(S), Promise.resolve(S).then(f).catch(function(I) {
        var D, L;
        if (!r.isResolved) {
          var Y = (D = t.retry) != null ? D : 3, M = (L = t.retryDelay) != null ? L : Of, N = typeof M == "function" ? M(r.failureCount, I) : M, b = Y === !0 || typeof Y == "number" && r.failureCount < Y || typeof Y == "function" && Y(r.failureCount, I);
          if (n || !b) {
            p(I);
            return;
          }
          r.failureCount++, t.onFail == null || t.onFail(r.failureCount, I), Nf(N).then(function() {
            if (!bn.isFocused() || !Qn.isOnline())
              return g();
          }).then(function() {
            n ? p(I) : A();
          });
        }
      });
    }
  };
  y();
}, Df = /* @__PURE__ */ function() {
  function e() {
    this.queue = [], this.transactions = 0, this.notifyFn = function(r) {
      r();
    }, this.batchNotifyFn = function(r) {
      r();
    };
  }
  var t = e.prototype;
  return t.batch = function(n) {
    var i;
    this.transactions++;
    try {
      i = n();
    } finally {
      this.transactions--, this.transactions || this.flush();
    }
    return i;
  }, t.schedule = function(n) {
    var i = this;
    this.transactions ? this.queue.push(n) : Ss(function() {
      i.notifyFn(n);
    });
  }, t.batchCalls = function(n) {
    var i = this;
    return function() {
      for (var o = arguments.length, a = new Array(o), u = 0; u < o; u++)
        a[u] = arguments[u];
      i.schedule(function() {
        n.apply(void 0, a);
      });
    };
  }, t.flush = function() {
    var n = this, i = this.queue;
    this.queue = [], i.length && Ss(function() {
      n.batchNotifyFn(function() {
        i.forEach(function(o) {
          n.notifyFn(o);
        });
      });
    });
  }, t.setNotifyFunction = function(n) {
    this.notifyFn = n;
  }, t.setBatchNotifyFunction = function(n) {
    this.batchNotifyFn = n;
  }, e;
}(), st = new Df(), _a = console;
function ri() {
  return _a;
}
function Cf(e) {
  _a = e;
}
var jf = /* @__PURE__ */ function() {
  function e(r) {
    this.abortSignalConsumed = !1, this.hadObservers = !1, this.defaultOptions = r.defaultOptions, this.setOptions(r.options), this.observers = [], this.cache = r.cache, this.queryKey = r.queryKey, this.queryHash = r.queryHash, this.initialState = r.state || this.getDefaultState(this.options), this.state = this.initialState, this.meta = r.meta, this.scheduleGc();
  }
  var t = e.prototype;
  return t.setOptions = function(n) {
    var i;
    this.options = Be({}, this.defaultOptions, n), this.meta = n?.meta, this.cacheTime = Math.max(this.cacheTime || 0, (i = this.options.cacheTime) != null ? i : 5 * 60 * 1e3);
  }, t.setDefaultOptions = function(n) {
    this.defaultOptions = n;
  }, t.scheduleGc = function() {
    var n = this;
    this.clearGcTimeout(), ro(this.cacheTime) && (this.gcTimeout = setTimeout(function() {
      n.optionalRemove();
    }, this.cacheTime));
  }, t.clearGcTimeout = function() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }, t.optionalRemove = function() {
    this.observers.length || (this.state.isFetching ? this.hadObservers && this.scheduleGc() : this.cache.remove(this));
  }, t.setData = function(n, i) {
    var o, a, u = this.state.data, f = Ef(n, u);
    return (o = (a = this.options).isDataEqual) != null && o.call(a, u, f) ? f = u : this.options.structuralSharing !== !1 && (f = ei(u, f)), this.dispatch({
      data: f,
      type: "success",
      dataUpdatedAt: i?.updatedAt
    }), f;
  }, t.setState = function(n, i) {
    this.dispatch({
      type: "setState",
      state: n,
      setStateOptions: i
    });
  }, t.cancel = function(n) {
    var i, o = this.promise;
    return (i = this.retryer) == null || i.cancel(n), o ? o.then(Mt).catch(Mt) : Promise.resolve();
  }, t.destroy = function() {
    this.clearGcTimeout(), this.cancel({
      silent: !0
    });
  }, t.reset = function() {
    this.destroy(), this.setState(this.initialState);
  }, t.isActive = function() {
    return this.observers.some(function(n) {
      return n.options.enabled !== !1;
    });
  }, t.isFetching = function() {
    return this.state.isFetching;
  }, t.isStale = function() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function(n) {
      return n.getCurrentResult().isStale;
    });
  }, t.isStaleByTime = function(n) {
    return n === void 0 && (n = 0), this.state.isInvalidated || !this.state.dataUpdatedAt || !Ba(this.state.dataUpdatedAt, n);
  }, t.onFocus = function() {
    var n, i = this.observers.find(function(o) {
      return o.shouldFetchOnWindowFocus();
    });
    i && i.refetch(), (n = this.retryer) == null || n.continue();
  }, t.onOnline = function() {
    var n, i = this.observers.find(function(o) {
      return o.shouldFetchOnReconnect();
    });
    i && i.refetch(), (n = this.retryer) == null || n.continue();
  }, t.addObserver = function(n) {
    this.observers.indexOf(n) === -1 && (this.observers.push(n), this.hadObservers = !0, this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: n
    }));
  }, t.removeObserver = function(n) {
    this.observers.indexOf(n) !== -1 && (this.observers = this.observers.filter(function(i) {
      return i !== n;
    }), this.observers.length || (this.retryer && (this.retryer.isTransportCancelable || this.abortSignalConsumed ? this.retryer.cancel({
      revert: !0
    }) : this.retryer.cancelRetry()), this.cacheTime ? this.scheduleGc() : this.cache.remove(this)), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: n
    }));
  }, t.getObserversCount = function() {
    return this.observers.length;
  }, t.invalidate = function() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }, t.fetch = function(n, i) {
    var o = this, a, u, f;
    if (this.state.isFetching) {
      if (this.state.dataUpdatedAt && i?.cancelRefetch)
        this.cancel({
          silent: !0
        });
      else if (this.promise) {
        var p;
        return (p = this.retryer) == null || p.continueRetry(), this.promise;
      }
    }
    if (n && this.setOptions(n), !this.options.queryFn) {
      var g = this.observers.find(function(M) {
        return M.options.queryFn;
      });
      g && this.setOptions(g.options);
    }
    var y = Xn(this.queryKey), A = Ua(), S = {
      queryKey: y,
      pageParam: void 0,
      meta: this.meta
    };
    Object.defineProperty(S, "signal", {
      enumerable: !0,
      get: function() {
        if (A)
          return o.abortSignalConsumed = !0, A.signal;
      }
    });
    var I = function() {
      return o.options.queryFn ? (o.abortSignalConsumed = !1, o.options.queryFn(S)) : Promise.reject("Missing queryFn");
    }, D = {
      fetchOptions: i,
      options: this.options,
      queryKey: y,
      state: this.state,
      fetchFn: I,
      meta: this.meta
    };
    if ((a = this.options.behavior) != null && a.onFetch) {
      var L;
      (L = this.options.behavior) == null || L.onFetch(D);
    }
    if (this.revertState = this.state, !this.state.isFetching || this.state.fetchMeta !== ((u = D.fetchOptions) == null ? void 0 : u.meta)) {
      var Y;
      this.dispatch({
        type: "fetch",
        meta: (Y = D.fetchOptions) == null ? void 0 : Y.meta
      });
    }
    return this.retryer = new ka({
      fn: D.fetchFn,
      abort: A == null || (f = A.abort) == null ? void 0 : f.bind(A),
      onSuccess: function(N) {
        o.setData(N), o.cache.config.onSuccess == null || o.cache.config.onSuccess(N, o), o.cacheTime === 0 && o.optionalRemove();
      },
      onError: function(N) {
        Wn(N) && N.silent || o.dispatch({
          type: "error",
          error: N
        }), Wn(N) || (o.cache.config.onError == null || o.cache.config.onError(N, o), ri().error(N)), o.cacheTime === 0 && o.optionalRemove();
      },
      onFail: function() {
        o.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        o.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        o.dispatch({
          type: "continue"
        });
      },
      retry: D.options.retry,
      retryDelay: D.options.retryDelay
    }), this.promise = this.retryer.promise, this.promise;
  }, t.dispatch = function(n) {
    var i = this;
    this.state = this.reducer(this.state, n), st.batch(function() {
      i.observers.forEach(function(o) {
        o.onQueryUpdate(n);
      }), i.cache.notify({
        query: i,
        type: "queryUpdated",
        action: n
      });
    });
  }, t.getDefaultState = function(n) {
    var i = typeof n.initialData == "function" ? n.initialData() : n.initialData, o = typeof n.initialData < "u", a = o ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0, u = typeof i < "u";
    return {
      data: i,
      dataUpdateCount: 0,
      dataUpdatedAt: u ? a ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchMeta: null,
      isFetching: !1,
      isInvalidated: !1,
      isPaused: !1,
      status: u ? "success" : "idle"
    };
  }, t.reducer = function(n, i) {
    var o, a;
    switch (i.type) {
      case "failed":
        return Be({}, n, {
          fetchFailureCount: n.fetchFailureCount + 1
        });
      case "pause":
        return Be({}, n, {
          isPaused: !0
        });
      case "continue":
        return Be({}, n, {
          isPaused: !1
        });
      case "fetch":
        return Be({}, n, {
          fetchFailureCount: 0,
          fetchMeta: (o = i.meta) != null ? o : null,
          isFetching: !0,
          isPaused: !1
        }, !n.dataUpdatedAt && {
          error: null,
          status: "loading"
        });
      case "success":
        return Be({}, n, {
          data: i.data,
          dataUpdateCount: n.dataUpdateCount + 1,
          dataUpdatedAt: (a = i.dataUpdatedAt) != null ? a : Date.now(),
          error: null,
          fetchFailureCount: 0,
          isFetching: !1,
          isInvalidated: !1,
          isPaused: !1,
          status: "success"
        });
      case "error":
        var u = i.error;
        return Wn(u) && u.revert && this.revertState ? Be({}, this.revertState) : Be({}, n, {
          error: u,
          errorUpdateCount: n.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: n.fetchFailureCount + 1,
          isFetching: !1,
          isPaused: !1,
          status: "error"
        });
      case "invalidate":
        return Be({}, n, {
          isInvalidated: !0
        });
      case "setState":
        return Be({}, n, i.state);
      default:
        return n;
    }
  }, e;
}(), xf = /* @__PURE__ */ function(e) {
  Nn(t, e);
  function t(n) {
    var i;
    return i = e.call(this) || this, i.config = n || {}, i.queries = [], i.queriesMap = {}, i;
  }
  var r = t.prototype;
  return r.build = function(i, o, a) {
    var u, f = o.queryKey, p = (u = o.queryHash) != null ? u : Ao(f, o), g = this.get(p);
    return g || (g = new jf({
      cache: this,
      queryKey: f,
      queryHash: p,
      options: i.defaultQueryOptions(o),
      state: a,
      defaultOptions: i.getQueryDefaults(f),
      meta: o.meta
    }), this.add(g)), g;
  }, r.add = function(i) {
    this.queriesMap[i.queryHash] || (this.queriesMap[i.queryHash] = i, this.queries.push(i), this.notify({
      type: "queryAdded",
      query: i
    }));
  }, r.remove = function(i) {
    var o = this.queriesMap[i.queryHash];
    o && (i.destroy(), this.queries = this.queries.filter(function(a) {
      return a !== i;
    }), o === i && delete this.queriesMap[i.queryHash], this.notify({
      type: "queryRemoved",
      query: i
    }));
  }, r.clear = function() {
    var i = this;
    st.batch(function() {
      i.queries.forEach(function(o) {
        i.remove(o);
      });
    });
  }, r.get = function(i) {
    return this.queriesMap[i];
  }, r.getAll = function() {
    return this.queries;
  }, r.find = function(i, o) {
    var a = Er(i, o), u = a[0];
    return typeof u.exact > "u" && (u.exact = !0), this.queries.find(function(f) {
      return Es(u, f);
    });
  }, r.findAll = function(i, o) {
    var a = Er(i, o), u = a[0];
    return Object.keys(u).length > 0 ? this.queries.filter(function(f) {
      return Es(u, f);
    }) : this.queries;
  }, r.notify = function(i) {
    var o = this;
    st.batch(function() {
      o.listeners.forEach(function(a) {
        a(i);
      });
    });
  }, r.onFocus = function() {
    var i = this;
    st.batch(function() {
      i.queries.forEach(function(o) {
        o.onFocus();
      });
    });
  }, r.onOnline = function() {
    var i = this;
    st.batch(function() {
      i.queries.forEach(function(o) {
        o.onOnline();
      });
    });
  }, t;
}(Tn), Lf = /* @__PURE__ */ function() {
  function e(r) {
    this.options = Be({}, r.defaultOptions, r.options), this.mutationId = r.mutationId, this.mutationCache = r.mutationCache, this.observers = [], this.state = r.state || Bf(), this.meta = r.meta;
  }
  var t = e.prototype;
  return t.setState = function(n) {
    this.dispatch({
      type: "setState",
      state: n
    });
  }, t.addObserver = function(n) {
    this.observers.indexOf(n) === -1 && this.observers.push(n);
  }, t.removeObserver = function(n) {
    this.observers = this.observers.filter(function(i) {
      return i !== n;
    });
  }, t.cancel = function() {
    return this.retryer ? (this.retryer.cancel(), this.retryer.promise.then(Mt).catch(Mt)) : Promise.resolve();
  }, t.continue = function() {
    return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();
  }, t.execute = function() {
    var n = this, i, o = this.state.status === "loading", a = Promise.resolve();
    return o || (this.dispatch({
      type: "loading",
      variables: this.options.variables
    }), a = a.then(function() {
      n.mutationCache.config.onMutate == null || n.mutationCache.config.onMutate(n.state.variables, n);
    }).then(function() {
      return n.options.onMutate == null ? void 0 : n.options.onMutate(n.state.variables);
    }).then(function(u) {
      u !== n.state.context && n.dispatch({
        type: "loading",
        context: u,
        variables: n.state.variables
      });
    })), a.then(function() {
      return n.executeMutation();
    }).then(function(u) {
      i = u, n.mutationCache.config.onSuccess == null || n.mutationCache.config.onSuccess(i, n.state.variables, n.state.context, n);
    }).then(function() {
      return n.options.onSuccess == null ? void 0 : n.options.onSuccess(i, n.state.variables, n.state.context);
    }).then(function() {
      return n.options.onSettled == null ? void 0 : n.options.onSettled(i, null, n.state.variables, n.state.context);
    }).then(function() {
      return n.dispatch({
        type: "success",
        data: i
      }), i;
    }).catch(function(u) {
      return n.mutationCache.config.onError == null || n.mutationCache.config.onError(u, n.state.variables, n.state.context, n), ri().error(u), Promise.resolve().then(function() {
        return n.options.onError == null ? void 0 : n.options.onError(u, n.state.variables, n.state.context);
      }).then(function() {
        return n.options.onSettled == null ? void 0 : n.options.onSettled(void 0, u, n.state.variables, n.state.context);
      }).then(function() {
        throw n.dispatch({
          type: "error",
          error: u
        }), u;
      });
    });
  }, t.executeMutation = function() {
    var n = this, i;
    return this.retryer = new ka({
      fn: function() {
        return n.options.mutationFn ? n.options.mutationFn(n.state.variables) : Promise.reject("No mutationFn found");
      },
      onFail: function() {
        n.dispatch({
          type: "failed"
        });
      },
      onPause: function() {
        n.dispatch({
          type: "pause"
        });
      },
      onContinue: function() {
        n.dispatch({
          type: "continue"
        });
      },
      retry: (i = this.options.retry) != null ? i : 0,
      retryDelay: this.options.retryDelay
    }), this.retryer.promise;
  }, t.dispatch = function(n) {
    var i = this;
    this.state = Rf(this.state, n), st.batch(function() {
      i.observers.forEach(function(o) {
        o.onMutationUpdate(n);
      }), i.mutationCache.notify(i);
    });
  }, e;
}();
function Bf() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    isPaused: !1,
    status: "idle",
    variables: void 0
  };
}
function Rf(e, t) {
  switch (t.type) {
    case "failed":
      return Be({}, e, {
        failureCount: e.failureCount + 1
      });
    case "pause":
      return Be({}, e, {
        isPaused: !0
      });
    case "continue":
      return Be({}, e, {
        isPaused: !1
      });
    case "loading":
      return Be({}, e, {
        context: t.context,
        data: void 0,
        error: null,
        isPaused: !1,
        status: "loading",
        variables: t.variables
      });
    case "success":
      return Be({}, e, {
        data: t.data,
        error: null,
        status: "success",
        isPaused: !1
      });
    case "error":
      return Be({}, e, {
        data: void 0,
        error: t.error,
        failureCount: e.failureCount + 1,
        isPaused: !1,
        status: "error"
      });
    case "setState":
      return Be({}, e, t.state);
    default:
      return e;
  }
}
var Uf = /* @__PURE__ */ function(e) {
  Nn(t, e);
  function t(n) {
    var i;
    return i = e.call(this) || this, i.config = n || {}, i.mutations = [], i.mutationId = 0, i;
  }
  var r = t.prototype;
  return r.build = function(i, o, a) {
    var u = new Lf({
      mutationCache: this,
      mutationId: ++this.mutationId,
      options: i.defaultMutationOptions(o),
      state: a,
      defaultOptions: o.mutationKey ? i.getMutationDefaults(o.mutationKey) : void 0,
      meta: o.meta
    });
    return this.add(u), u;
  }, r.add = function(i) {
    this.mutations.push(i), this.notify(i);
  }, r.remove = function(i) {
    this.mutations = this.mutations.filter(function(o) {
      return o !== i;
    }), i.cancel(), this.notify(i);
  }, r.clear = function() {
    var i = this;
    st.batch(function() {
      i.mutations.forEach(function(o) {
        i.remove(o);
      });
    });
  }, r.getAll = function() {
    return this.mutations;
  }, r.find = function(i) {
    return typeof i.exact > "u" && (i.exact = !0), this.mutations.find(function(o) {
      return As(i, o);
    });
  }, r.findAll = function(i) {
    return this.mutations.filter(function(o) {
      return As(i, o);
    });
  }, r.notify = function(i) {
    var o = this;
    st.batch(function() {
      o.listeners.forEach(function(a) {
        a(i);
      });
    });
  }, r.onFocus = function() {
    this.resumePausedMutations();
  }, r.onOnline = function() {
    this.resumePausedMutations();
  }, r.resumePausedMutations = function() {
    var i = this.mutations.filter(function(o) {
      return o.state.isPaused;
    });
    return st.batch(function() {
      return i.reduce(function(o, a) {
        return o.then(function() {
          return a.continue().catch(Mt);
        });
      }, Promise.resolve());
    });
  }, t;
}(Tn);
function Pf() {
  return {
    onFetch: function(t) {
      t.fetchFn = function() {
        var r, n, i, o, a, u, f = (r = t.fetchOptions) == null || (n = r.meta) == null ? void 0 : n.refetchPage, p = (i = t.fetchOptions) == null || (o = i.meta) == null ? void 0 : o.fetchMore, g = p?.pageParam, y = p?.direction === "forward", A = p?.direction === "backward", S = ((a = t.state.data) == null ? void 0 : a.pages) || [], I = ((u = t.state.data) == null ? void 0 : u.pageParams) || [], D = Ua(), L = D?.signal, Y = I, M = !1, N = t.options.queryFn || function() {
          return Promise.reject("Missing queryFn");
        }, b = function(K, $, W, _) {
          return Y = _ ? [$].concat(Y) : [].concat(Y, [$]), _ ? [W].concat(K) : [].concat(K, [W]);
        }, k = function(K, $, W, _) {
          if (M)
            return Promise.reject("Cancelled");
          if (typeof W > "u" && !$ && K.length)
            return Promise.resolve(K);
          var ee = {
            queryKey: t.queryKey,
            signal: L,
            pageParam: W,
            meta: t.meta
          }, x = N(ee), F = Promise.resolve(x).then(function(oe) {
            return b(K, W, oe, _);
          });
          if (ti(x)) {
            var H = F;
            H.cancel = x.cancel;
          }
          return F;
        }, O;
        if (!S.length)
          O = k([]);
        else if (y) {
          var R = typeof g < "u", Q = R ? g : Ns(t.options, S);
          O = k(S, R, Q);
        } else if (A) {
          var G = typeof g < "u", B = G ? g : kf(t.options, S);
          O = k(S, G, B, !0);
        } else
          (function() {
            Y = [];
            var C = typeof t.options.getNextPageParam > "u", K = f && S[0] ? f(S[0], 0, S) : !0;
            O = K ? k([], C, I[0]) : Promise.resolve(b([], I[0], S[0]));
            for (var $ = function(ee) {
              O = O.then(function(x) {
                var F = f && S[ee] ? f(S[ee], ee, S) : !0;
                if (F) {
                  var H = C ? I[ee] : Ns(t.options, x);
                  return k(x, C, H);
                }
                return Promise.resolve(b(x, I[ee], S[ee]));
              });
            }, W = 1; W < S.length; W++)
              $(W);
          })();
        var E = O.then(function(C) {
          return {
            pages: C,
            pageParams: Y
          };
        }), T = E;
        return T.cancel = function() {
          M = !0, D?.abort(), ti(O) && O.cancel();
        }, E;
      };
    }
  };
}
function Ns(e, t) {
  return e.getNextPageParam == null ? void 0 : e.getNextPageParam(t[t.length - 1], t);
}
function kf(e, t) {
  return e.getPreviousPageParam == null ? void 0 : e.getPreviousPageParam(t[0], t);
}
var _f = /* @__PURE__ */ function() {
  function e(r) {
    r === void 0 && (r = {}), this.queryCache = r.queryCache || new xf(), this.mutationCache = r.mutationCache || new Uf(), this.defaultOptions = r.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];
  }
  var t = e.prototype;
  return t.mount = function() {
    var n = this;
    this.unsubscribeFocus = bn.subscribe(function() {
      bn.isFocused() && Qn.isOnline() && (n.mutationCache.onFocus(), n.queryCache.onFocus());
    }), this.unsubscribeOnline = Qn.subscribe(function() {
      bn.isFocused() && Qn.isOnline() && (n.mutationCache.onOnline(), n.queryCache.onOnline());
    });
  }, t.unmount = function() {
    var n, i;
    (n = this.unsubscribeFocus) == null || n.call(this), (i = this.unsubscribeOnline) == null || i.call(this);
  }, t.isFetching = function(n, i) {
    var o = Er(n, i), a = o[0];
    return a.fetching = !0, this.queryCache.findAll(a).length;
  }, t.isMutating = function(n) {
    return this.mutationCache.findAll(Be({}, n, {
      fetching: !0
    })).length;
  }, t.getQueryData = function(n, i) {
    var o;
    return (o = this.queryCache.find(n, i)) == null ? void 0 : o.state.data;
  }, t.getQueriesData = function(n) {
    return this.getQueryCache().findAll(n).map(function(i) {
      var o = i.queryKey, a = i.state, u = a.data;
      return [o, u];
    });
  }, t.setQueryData = function(n, i, o) {
    var a = zn(n), u = this.defaultQueryOptions(a);
    return this.queryCache.build(this, u).setData(i, o);
  }, t.setQueriesData = function(n, i, o) {
    var a = this;
    return st.batch(function() {
      return a.getQueryCache().findAll(n).map(function(u) {
        var f = u.queryKey;
        return [f, a.setQueryData(f, i, o)];
      });
    });
  }, t.getQueryState = function(n, i) {
    var o;
    return (o = this.queryCache.find(n, i)) == null ? void 0 : o.state;
  }, t.removeQueries = function(n, i) {
    var o = Er(n, i), a = o[0], u = this.queryCache;
    st.batch(function() {
      u.findAll(a).forEach(function(f) {
        u.remove(f);
      });
    });
  }, t.resetQueries = function(n, i, o) {
    var a = this, u = Er(n, i, o), f = u[0], p = u[1], g = this.queryCache, y = Be({}, f, {
      active: !0
    });
    return st.batch(function() {
      return g.findAll(f).forEach(function(A) {
        A.reset();
      }), a.refetchQueries(y, p);
    });
  }, t.cancelQueries = function(n, i, o) {
    var a = this, u = Er(n, i, o), f = u[0], p = u[1], g = p === void 0 ? {} : p;
    typeof g.revert > "u" && (g.revert = !0);
    var y = st.batch(function() {
      return a.queryCache.findAll(f).map(function(A) {
        return A.cancel(g);
      });
    });
    return Promise.all(y).then(Mt).catch(Mt);
  }, t.invalidateQueries = function(n, i, o) {
    var a, u, f, p = this, g = Er(n, i, o), y = g[0], A = g[1], S = Be({}, y, {
      active: (a = (u = y.refetchActive) != null ? u : y.active) != null ? a : !0,
      inactive: (f = y.refetchInactive) != null ? f : !1
    });
    return st.batch(function() {
      return p.queryCache.findAll(y).forEach(function(I) {
        I.invalidate();
      }), p.refetchQueries(S, A);
    });
  }, t.refetchQueries = function(n, i, o) {
    var a = this, u = Er(n, i, o), f = u[0], p = u[1], g = st.batch(function() {
      return a.queryCache.findAll(f).map(function(A) {
        return A.fetch(void 0, Be({}, p, {
          meta: {
            refetchPage: f?.refetchPage
          }
        }));
      });
    }), y = Promise.all(g).then(Mt);
    return p?.throwOnError || (y = y.catch(Mt)), y;
  }, t.fetchQuery = function(n, i, o) {
    var a = zn(n, i, o), u = this.defaultQueryOptions(a);
    typeof u.retry > "u" && (u.retry = !1);
    var f = this.queryCache.build(this, u);
    return f.isStaleByTime(u.staleTime) ? f.fetch(u) : Promise.resolve(f.state.data);
  }, t.prefetchQuery = function(n, i, o) {
    return this.fetchQuery(n, i, o).then(Mt).catch(Mt);
  }, t.fetchInfiniteQuery = function(n, i, o) {
    var a = zn(n, i, o);
    return a.behavior = Pf(), this.fetchQuery(a);
  }, t.prefetchInfiniteQuery = function(n, i, o) {
    return this.fetchInfiniteQuery(n, i, o).then(Mt).catch(Mt);
  }, t.cancelMutations = function() {
    var n = this, i = st.batch(function() {
      return n.mutationCache.getAll().map(function(o) {
        return o.cancel();
      });
    });
    return Promise.all(i).then(Mt).catch(Mt);
  }, t.resumePausedMutations = function() {
    return this.getMutationCache().resumePausedMutations();
  }, t.executeMutation = function(n) {
    return this.mutationCache.build(this, n).execute();
  }, t.getQueryCache = function() {
    return this.queryCache;
  }, t.getMutationCache = function() {
    return this.mutationCache;
  }, t.getDefaultOptions = function() {
    return this.defaultOptions;
  }, t.setDefaultOptions = function(n) {
    this.defaultOptions = n;
  }, t.setQueryDefaults = function(n, i) {
    var o = this.queryDefaults.find(function(a) {
      return Lr(n) === Lr(a.queryKey);
    });
    o ? o.defaultOptions = i : this.queryDefaults.push({
      queryKey: n,
      defaultOptions: i
    });
  }, t.getQueryDefaults = function(n) {
    var i;
    return n ? (i = this.queryDefaults.find(function(o) {
      return Jn(n, o.queryKey);
    })) == null ? void 0 : i.defaultOptions : void 0;
  }, t.setMutationDefaults = function(n, i) {
    var o = this.mutationDefaults.find(function(a) {
      return Lr(n) === Lr(a.mutationKey);
    });
    o ? o.defaultOptions = i : this.mutationDefaults.push({
      mutationKey: n,
      defaultOptions: i
    });
  }, t.getMutationDefaults = function(n) {
    var i;
    return n ? (i = this.mutationDefaults.find(function(o) {
      return Jn(n, o.mutationKey);
    })) == null ? void 0 : i.defaultOptions : void 0;
  }, t.defaultQueryOptions = function(n) {
    if (n?._defaulted)
      return n;
    var i = Be({}, this.defaultOptions.queries, this.getQueryDefaults(n?.queryKey), n, {
      _defaulted: !0
    });
    return !i.queryHash && i.queryKey && (i.queryHash = Ao(i.queryKey, i)), i;
  }, t.defaultQueryObserverOptions = function(n) {
    return this.defaultQueryOptions(n);
  }, t.defaultMutationOptions = function(n) {
    return n?._defaulted ? n : Be({}, this.defaultOptions.mutations, this.getMutationDefaults(n?.mutationKey), n, {
      _defaulted: !0
    });
  }, t.clear = function() {
    this.queryCache.clear(), this.mutationCache.clear();
  }, e;
}(), Ff = /* @__PURE__ */ function(e) {
  Nn(t, e);
  function t(n, i) {
    var o;
    return o = e.call(this) || this, o.client = n, o.options = i, o.trackedProps = [], o.selectError = null, o.bindMethods(), o.setOptions(i), o;
  }
  var r = t.prototype;
  return r.bindMethods = function() {
    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);
  }, r.onSubscribe = function() {
    this.listeners.length === 1 && (this.currentQuery.addObserver(this), Ts(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());
  }, r.onUnsubscribe = function() {
    this.listeners.length || this.destroy();
  }, r.shouldFetchOnReconnect = function() {
    return io(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }, r.shouldFetchOnWindowFocus = function() {
    return io(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }, r.destroy = function() {
    this.listeners = [], this.clearTimers(), this.currentQuery.removeObserver(this);
  }, r.setOptions = function(i, o) {
    var a = this.options, u = this.currentQuery;
    if (this.options = this.client.defaultQueryObserverOptions(i), typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = a.queryKey), this.updateQuery();
    var f = this.hasListeners();
    f && Is(this.currentQuery, u, this.options, a) && this.executeFetch(), this.updateResult(o), f && (this.currentQuery !== u || this.options.enabled !== a.enabled || this.options.staleTime !== a.staleTime) && this.updateStaleTimeout();
    var p = this.computeRefetchInterval();
    f && (this.currentQuery !== u || this.options.enabled !== a.enabled || p !== this.currentRefetchInterval) && this.updateRefetchInterval(p);
  }, r.getOptimisticResult = function(i) {
    var o = this.client.defaultQueryObserverOptions(i), a = this.client.getQueryCache().build(this.client, o);
    return this.createResult(a, o);
  }, r.getCurrentResult = function() {
    return this.currentResult;
  }, r.trackResult = function(i, o) {
    var a = this, u = {}, f = function(g) {
      a.trackedProps.includes(g) || a.trackedProps.push(g);
    };
    return Object.keys(i).forEach(function(p) {
      Object.defineProperty(u, p, {
        configurable: !1,
        enumerable: !0,
        get: function() {
          return f(p), i[p];
        }
      });
    }), (o.useErrorBoundary || o.suspense) && f("error"), u;
  }, r.getNextResult = function(i) {
    var o = this;
    return new Promise(function(a, u) {
      var f = o.subscribe(function(p) {
        p.isFetching || (f(), p.isError && i?.throwOnError ? u(p.error) : a(p));
      });
    });
  }, r.getCurrentQuery = function() {
    return this.currentQuery;
  }, r.remove = function() {
    this.client.getQueryCache().remove(this.currentQuery);
  }, r.refetch = function(i) {
    return this.fetch(Be({}, i, {
      meta: {
        refetchPage: i?.refetchPage
      }
    }));
  }, r.fetchOptimistic = function(i) {
    var o = this, a = this.client.defaultQueryObserverOptions(i), u = this.client.getQueryCache().build(this.client, a);
    return u.fetch().then(function() {
      return o.createResult(u, a);
    });
  }, r.fetch = function(i) {
    var o = this;
    return this.executeFetch(i).then(function() {
      return o.updateResult(), o.currentResult;
    });
  }, r.executeFetch = function(i) {
    this.updateQuery();
    var o = this.currentQuery.fetch(this.options, i);
    return i?.throwOnError || (o = o.catch(Mt)), o;
  }, r.updateStaleTimeout = function() {
    var i = this;
    if (this.clearStaleTimeout(), !($n || this.currentResult.isStale || !ro(this.options.staleTime))) {
      var o = Ba(this.currentResult.dataUpdatedAt, this.options.staleTime), a = o + 1;
      this.staleTimeoutId = setTimeout(function() {
        i.currentResult.isStale || i.updateResult();
      }, a);
    }
  }, r.computeRefetchInterval = function() {
    var i;
    return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (i = this.options.refetchInterval) != null ? i : !1;
  }, r.updateRefetchInterval = function(i) {
    var o = this;
    this.clearRefetchInterval(), this.currentRefetchInterval = i, !($n || this.options.enabled === !1 || !ro(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(function() {
      (o.options.refetchIntervalInBackground || bn.isFocused()) && o.executeFetch();
    }, this.currentRefetchInterval));
  }, r.updateTimers = function() {
    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());
  }, r.clearTimers = function() {
    this.clearStaleTimeout(), this.clearRefetchInterval();
  }, r.clearStaleTimeout = function() {
    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);
  }, r.clearRefetchInterval = function() {
    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);
  }, r.createResult = function(i, o) {
    var a = this.currentQuery, u = this.options, f = this.currentResult, p = this.currentResultState, g = this.currentResultOptions, y = i !== a, A = y ? i.state : this.currentQueryInitialState, S = y ? this.currentResult : this.previousQueryResult, I = i.state, D = I.dataUpdatedAt, L = I.error, Y = I.errorUpdatedAt, M = I.isFetching, N = I.status, b = !1, k = !1, O;
    if (o.optimisticResults) {
      var R = this.hasListeners(), Q = !R && Ts(i, o), G = R && Is(i, a, o, u);
      (Q || G) && (M = !0, D || (N = "loading"));
    }
    if (o.keepPreviousData && !I.dataUpdateCount && S?.isSuccess && N !== "error")
      O = S.data, D = S.dataUpdatedAt, N = S.status, b = !0;
    else if (o.select && typeof I.data < "u")
      if (f && I.data === p?.data && o.select === this.selectFn)
        O = this.selectResult;
      else
        try {
          this.selectFn = o.select, O = o.select(I.data), o.structuralSharing !== !1 && (O = ei(f?.data, O)), this.selectResult = O, this.selectError = null;
        } catch (T) {
          ri().error(T), this.selectError = T;
        }
    else
      O = I.data;
    if (typeof o.placeholderData < "u" && typeof O > "u" && (N === "loading" || N === "idle")) {
      var B;
      if (f?.isPlaceholderData && o.placeholderData === g?.placeholderData)
        B = f.data;
      else if (B = typeof o.placeholderData == "function" ? o.placeholderData() : o.placeholderData, o.select && typeof B < "u")
        try {
          B = o.select(B), o.structuralSharing !== !1 && (B = ei(f?.data, B)), this.selectError = null;
        } catch (T) {
          ri().error(T), this.selectError = T;
        }
      typeof B < "u" && (N = "success", O = B, k = !0);
    }
    this.selectError && (L = this.selectError, O = this.selectResult, Y = Date.now(), N = "error");
    var E = {
      status: N,
      isLoading: N === "loading",
      isSuccess: N === "success",
      isError: N === "error",
      isIdle: N === "idle",
      data: O,
      dataUpdatedAt: D,
      error: L,
      errorUpdatedAt: Y,
      failureCount: I.fetchFailureCount,
      errorUpdateCount: I.errorUpdateCount,
      isFetched: I.dataUpdateCount > 0 || I.errorUpdateCount > 0,
      isFetchedAfterMount: I.dataUpdateCount > A.dataUpdateCount || I.errorUpdateCount > A.errorUpdateCount,
      isFetching: M,
      isRefetching: M && N !== "loading",
      isLoadingError: N === "error" && I.dataUpdatedAt === 0,
      isPlaceholderData: k,
      isPreviousData: b,
      isRefetchError: N === "error" && I.dataUpdatedAt !== 0,
      isStale: Mo(i, o),
      refetch: this.refetch,
      remove: this.remove
    };
    return E;
  }, r.shouldNotifyListeners = function(i, o) {
    if (!o)
      return !0;
    var a = this.options, u = a.notifyOnChangeProps, f = a.notifyOnChangePropsExclusions;
    if (!u && !f || u === "tracked" && !this.trackedProps.length)
      return !0;
    var p = u === "tracked" ? this.trackedProps : u;
    return Object.keys(i).some(function(g) {
      var y = g, A = i[y] !== o[y], S = p?.some(function(D) {
        return D === g;
      }), I = f?.some(function(D) {
        return D === g;
      });
      return A && !I && (!p || S);
    });
  }, r.updateResult = function(i) {
    var o = this.currentResult;
    if (this.currentResult = this.createResult(this.currentQuery, this.options), this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, !Sf(this.currentResult, o)) {
      var a = {
        cache: !0
      };
      i?.listeners !== !1 && this.shouldNotifyListeners(this.currentResult, o) && (a.listeners = !0), this.notify(Be({}, a, i));
    }
  }, r.updateQuery = function() {
    var i = this.client.getQueryCache().build(this.client, this.options);
    if (i !== this.currentQuery) {
      var o = this.currentQuery;
      this.currentQuery = i, this.currentQueryInitialState = i.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (o?.removeObserver(this), i.addObserver(this));
    }
  }, r.onQueryUpdate = function(i) {
    var o = {};
    i.type === "success" ? o.onSuccess = !0 : i.type === "error" && !Wn(i.error) && (o.onError = !0), this.updateResult(o), this.hasListeners() && this.updateTimers();
  }, r.notify = function(i) {
    var o = this;
    st.batch(function() {
      i.onSuccess ? (o.options.onSuccess == null || o.options.onSuccess(o.currentResult.data), o.options.onSettled == null || o.options.onSettled(o.currentResult.data, null)) : i.onError && (o.options.onError == null || o.options.onError(o.currentResult.error), o.options.onSettled == null || o.options.onSettled(void 0, o.currentResult.error)), i.listeners && o.listeners.forEach(function(a) {
        a(o.currentResult);
      }), i.cache && o.client.getQueryCache().notify({
        query: o.currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }, t;
}(Tn);
function zf(e, t) {
  return t.enabled !== !1 && !e.state.dataUpdatedAt && !(e.state.status === "error" && t.retryOnMount === !1);
}
function Ts(e, t) {
  return zf(e, t) || e.state.dataUpdatedAt > 0 && io(e, t, t.refetchOnMount);
}
function io(e, t, r) {
  if (t.enabled !== !1) {
    var n = typeof r == "function" ? r(e) : r;
    return n === "always" || n !== !1 && Mo(e, t);
  }
  return !1;
}
function Is(e, t, r, n) {
  return r.enabled !== !1 && (e !== t || n.enabled === !1) && (!r.suspense || e.state.status !== "error") && Mo(e, r);
}
function Mo(e, t) {
  return e.isStaleByTime(t.staleTime);
}
var Qf = la.unstable_batchedUpdates;
st.setBatchNotifyFunction(Qf);
var Wf = console;
Cf(Wf);
var Os = /* @__PURE__ */ Ct.createContext(void 0), Fa = /* @__PURE__ */ Ct.createContext(!1);
function za(e) {
  return e && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = Os), window.ReactQueryClientContext) : Os;
}
var Yf = function() {
  var t = Ct.useContext(za(Ct.useContext(Fa)));
  if (!t)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t;
}, Hf = function(t) {
  var r = t.client, n = t.contextSharing, i = n === void 0 ? !1 : n, o = t.children;
  Ct.useEffect(function() {
    return r.mount(), function() {
      r.unmount();
    };
  }, [r]);
  var a = za(i);
  return /* @__PURE__ */ ge(Fa.Provider, {
    value: i,
    children: /* @__PURE__ */ ge(a.Provider, {
      value: r,
      children: o
    })
  });
};
function qf() {
  var e = !1;
  return {
    clearReset: function() {
      e = !1;
    },
    reset: function() {
      e = !0;
    },
    isReset: function() {
      return e;
    }
  };
}
var Zf = /* @__PURE__ */ Ct.createContext(qf()), Kf = function() {
  return Ct.useContext(Zf);
};
function Vf(e, t, r) {
  return typeof t == "function" ? t.apply(void 0, r) : typeof t == "boolean" ? t : !!e;
}
function Gf(e, t) {
  var r = Ct.useRef(!1), n = Ct.useState(0), i = n[1], o = Yf(), a = Kf(), u = o.defaultQueryObserverOptions(e);
  u.optimisticResults = !0, u.onError && (u.onError = st.batchCalls(u.onError)), u.onSuccess && (u.onSuccess = st.batchCalls(u.onSuccess)), u.onSettled && (u.onSettled = st.batchCalls(u.onSettled)), u.suspense && (typeof u.staleTime != "number" && (u.staleTime = 1e3), u.cacheTime === 0 && (u.cacheTime = 1)), (u.suspense || u.useErrorBoundary) && (a.isReset() || (u.retryOnMount = !1));
  var f = Ct.useState(function() {
    return new t(o, u);
  }), p = f[0], g = p.getOptimisticResult(u);
  if (Ct.useEffect(function() {
    r.current = !0, a.clearReset();
    var y = p.subscribe(st.batchCalls(function() {
      r.current && i(function(A) {
        return A + 1;
      });
    }));
    return p.updateResult(), function() {
      r.current = !1, y();
    };
  }, [a, p]), Ct.useEffect(function() {
    p.setOptions(u, {
      listeners: !1
    });
  }, [u, p]), u.suspense && g.isLoading)
    throw p.fetchOptimistic(u).then(function(y) {
      var A = y.data;
      u.onSuccess == null || u.onSuccess(A), u.onSettled == null || u.onSettled(A, null);
    }).catch(function(y) {
      a.clearReset(), u.onError == null || u.onError(y), u.onSettled == null || u.onSettled(void 0, y);
    });
  if (g.isError && !a.isReset() && !g.isFetching && Vf(u.suspense, u.useErrorBoundary, [g.error, p.getCurrentQuery()]))
    throw g.error;
  return u.notifyOnChangeProps === "tracked" && (g = p.trackResult(g, u)), g;
}
function $f(e, t, r) {
  var n = zn(e, t, r);
  return Gf(n, Ff);
}
var Xf = /* @__PURE__ */ ((e) => (e.DEV_NET = "sui:devnet", e.TEST_NET = "sui:testnet", e.MAIN_NET = "sui:mainnet", e.DEVNET = "sui:devnet", e.TestNET = "sui:testnet", e))(Xf || {});
const Jf = {
  id: "sui:devnet",
  name: "Sui Devnet",
  rpcUrl: "https://fullnode.devnet.sui.io/"
}, ed = {
  id: "sui:testnet",
  name: "Sui Testnet",
  rpcUrl: "https://fullnode.testnet.sui.io/"
}, td = {
  id: "sui:mainnet",
  name: "Sui Mainnet",
  rpcUrl: "https://rpc.mainnet.sui.io/"
}, Yn = {
  id: "unknown:unknown",
  name: "Unknown Network",
  rpcUrl: ""
}, rd = [
  Jf,
  ed,
  td
];
var Qa = /* @__PURE__ */ ((e) => (e.COIN_BALANCE = "SUIET_COIN_BALANCE", e))(Qa || {});
function nd(e, t) {
  const r = new URLSearchParams(t);
  return e + "?" + r.toString();
}
var id = Object.defineProperty, od = (e, t, r) => t in e ? id(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, fr = (e, t, r) => (od(e, typeof t != "symbol" ? t + "" : t, r), r);
class sd {
  constructor(t, r) {
    fr(this, "provider"), fr(this, "address"), this.provider = t, this.address = r;
  }
  async get(t = pa) {
    return (await this.getAllCoins()).find((r) => r.typeArg === t)?.balance || BigInt(0);
  }
  async getAllCoins() {
    const t = await this.provider.query.getOwnedCoins(this.address), r = /* @__PURE__ */ new Map();
    for (const n of t)
      r.has(n.typeArg) ? r.set(n.typeArg, r.get(n.typeArg) + n.balance) : r.set(n.typeArg, n.balance);
    return Array.from(r.entries()).map((n) => ({
      typeArg: n[0],
      balance: n[1]
    }));
  }
}
class ad {
  constructor(t, r) {
    fr(this, "balance"), this.balance = new sd(t, r);
  }
}
const Ds = "0x2::coin::Coin";
class So {
  constructor(t, r, n) {
    fr(this, "_objectId"), fr(this, "_typeArg"), fr(this, "_balance"), fr(this, "_symbol"), this._objectId = t, this._balance = n, this._typeArg = r, this._symbol = En.getCoinSymbol(r);
  }
  get objectId() {
    return this._objectId;
  }
  get typeArg() {
    return this._typeArg;
  }
  get balance() {
    return this._balance;
  }
  get symbol() {
    return this._symbol;
  }
  static fromDto(t) {
    return new So(t.objectId, t.typeArg, t.balance);
  }
  toDto() {
    return {
      objectId: this._objectId,
      balance: this._balance,
      typeArg: this._typeArg,
      symbol: this._symbol
    };
  }
  toString() {
    return JSON.stringify(this.toDto());
  }
}
class En {
  static isCoin(t) {
    return t.type.startsWith(Ds);
  }
  static isSUI(t) {
    const r = En.getCoinTypeArg(t);
    return r ? En.getCoinSymbol(r) === "SUI" : !1;
  }
  static getCoinObject(t) {
    const r = Vi.getCoinTypeArg(t);
    if (!r)
      throw new Error("coin typeArg cannot be null");
    return new So(
      t.fields.id.id,
      r,
      BigInt(t.fields.balance)
    );
  }
  static getBalance(t) {
    return BigInt(t.fields.balance);
  }
  static getCoinTypeArg(t) {
    return Vi.getCoinTypeArg(t);
  }
  static getCoinSymbol(t) {
    return t.substring(t.lastIndexOf(":") + 1);
  }
  static getCoinTypeFromArg(t) {
    return `${Ds}<${t}>`;
  }
}
class Cs {
  static isNft(t) {
    return !!(t.fields.name && t.fields.description && t.fields.url);
  }
  static getNftObject(t, r) {
    return {
      objectId: t.fields.id.id,
      name: t.fields.name,
      description: t.fields.description,
      url: t.fields.url,
      previousTransaction: r,
      objectType: t.type
    };
  }
}
const Q1 = "0x0000000000000000000000000000000000000005";
class cd {
  constructor(t) {
    fr(this, "query"), this.query = new ud(t);
  }
}
class ud {
  constructor(t) {
    fr(this, "provider"), this.provider = new da(new ha({ fullnode: t }));
  }
  async getOwnedObjects(t) {
    let r = !0, n = null, i = [];
    for (; r; ) {
      const o = await this.provider.getOwnedObjects({
        owner: t,
        cursor: n,
        options: {
          showType: !0,
          showDisplay: !0,
          showContent: !0,
          showOwner: !0
        }
      });
      o.data?.forEach((a) => {
        const u = Tu(a);
        u && i.push(u);
      }), r = o.hasNextPage, n = o.nextCursor;
    }
    return i;
  }
  async getOwnedCoins(t) {
    return (await this.getOwnedObjects(t)).map((r) => ({
      id: r.objectId,
      object: as(r)
    })).filter((r) => r.object && Vi.isCoin(r.object)).map((r) => En.getCoinObject(r.object));
  }
  async getOwnedNfts(t) {
    return (await this.getOwnedObjects(t)).map((r) => ({
      id: r.objectId,
      object: as(r),
      previousTransaction: r.previousTransaction
    })).filter((r) => r.object && Cs.isNft(r.object)).map((r) => {
      const n = r.object;
      return Cs.getNftObject(n, r.previousTransaction ?? null);
    });
  }
}
const js = 1e6, Ui = 1e9, Pi = 1e12;
function ld(e, t) {
  return Wa(
    e,
    Object.assign(
      {
        decimals: 9
      },
      t
    )
  );
}
function Wa(e, t) {
  const { decimals: r = 0, withAbbr: n = !0 } = t ?? {};
  if (typeof e == "bigint" && !dd(e))
    return Ha(BigInt(e), {
      decimals: r,
      withAbbr: n
    });
  if (Number(e) === 0)
    return "0";
  if (Number(e) < 0)
    return "-" + Wa(-Number(e), t);
  const i = Number(e) / 10 ** r;
  return i > 0 && i < 1 ? fd(i) : Ya(i, n);
}
function Ya(e, t) {
  if (t) {
    if (e >= js && e < Ui)
      return ki(e, js, "M");
    if (e >= Ui && e < Pi)
      return ki(e, Ui, "B");
    if (e >= Pi)
      return ki(e, Pi, "T");
  }
  return Intl.NumberFormat("en-US").format(e);
}
function ki(e, t, r) {
  let n;
  typeof e == "bigint" ? n = String(e / (BigInt(t) / 1000n)) : n = String(Math.floor(e / (t / 1e3)));
  const i = n.padEnd(4, "0");
  return Intl.NumberFormat("en-US").format(Number(i)).replace(",", ".") + r;
}
function fd(e) {
  if (e <= 0)
    return "0";
  const t = Math.ceil(-Math.log10(e));
  return Number(e) % Math.pow(10, 10 - (t + 2)) === 0 && Number(e) % Math.pow(10, 10 - (t + 1)) === 0 ? _i(e, t) : Number(e) % Math.pow(10, 10 - (t + 2)) === 0 && Number(e) % Math.pow(10, 10 - (t + 1)) !== 0 ? _i(e, t + 1) : _i(e, t + 2);
}
function _i(e, t) {
  function r(n) {
    if (isNaN(n))
      return n.toString();
    const i = "" + n;
    return /e/i.test(i) ? n.toFixed(18).replace(/\.?0+$/, "") : n.toString();
  }
  return t = t || 0, t = Math.pow(10, t), r(Math.floor(e * t) / t);
}
function Ha(e, t) {
  if (e === 0n)
    return "0";
  if (e < 0n)
    return "-" + Ha(-e, t);
  const { decimals: r = 9, withAbbr: n = !0 } = t ?? {}, i = e / 10n ** BigInt(r);
  return Ya(i, n);
}
function dd(e) {
  const t = Number.MIN_SAFE_INTEGER, r = Number.MAX_SAFE_INTEGER;
  return e >= BigInt(t) && e <= BigInt(r);
}
function hd(e) {
  return typeof e != "string" ? "" : !e || !e.startsWith("0x") ? e : e.slice(0, 7) + "...." + e.slice(-4, e.length);
}
function pd(e) {
  var t = e.default;
  if (typeof t == "function") {
    var r = function() {
      return t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var qa = { exports: {} };
function gd(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var n = 0; n < e.length; n++) {
    var i = e.charAt(n), o = i.charCodeAt(0);
    if (t[o] !== 255)
      throw new TypeError(i + " is ambiguous");
    t[o] = n;
  }
  var a = e.length, u = e.charAt(0), f = Math.log(a) / Math.log(256), p = Math.log(256) / Math.log(a);
  function g(S) {
    if (S instanceof Uint8Array || (ArrayBuffer.isView(S) ? S = new Uint8Array(S.buffer, S.byteOffset, S.byteLength) : Array.isArray(S) && (S = Uint8Array.from(S))), !(S instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (S.length === 0)
      return "";
    for (var I = 0, D = 0, L = 0, Y = S.length; L !== Y && S[L] === 0; )
      L++, I++;
    for (var M = (Y - L) * p + 1 >>> 0, N = new Uint8Array(M); L !== Y; ) {
      for (var b = S[L], k = 0, O = M - 1; (b !== 0 || k < D) && O !== -1; O--, k++)
        b += 256 * N[O] >>> 0, N[O] = b % a >>> 0, b = b / a >>> 0;
      if (b !== 0)
        throw new Error("Non-zero carry");
      D = k, L++;
    }
    for (var R = M - D; R !== M && N[R] === 0; )
      R++;
    for (var Q = u.repeat(I); R < M; ++R)
      Q += e.charAt(N[R]);
    return Q;
  }
  function y(S) {
    if (typeof S != "string")
      throw new TypeError("Expected String");
    if (S.length === 0)
      return new Uint8Array();
    for (var I = 0, D = 0, L = 0; S[I] === u; )
      D++, I++;
    for (var Y = (S.length - I) * f + 1 >>> 0, M = new Uint8Array(Y); S[I]; ) {
      var N = t[S.charCodeAt(I)];
      if (N === 255)
        return;
      for (var b = 0, k = Y - 1; (N !== 0 || b < L) && k !== -1; k--, b++)
        N += a * M[k] >>> 0, M[k] = N % 256 >>> 0, N = N / 256 >>> 0;
      if (N !== 0)
        throw new Error("Non-zero carry");
      L = b, I++;
    }
    for (var O = Y - L; O !== Y && M[O] === 0; )
      O++;
    for (var R = new Uint8Array(D + (Y - O)), Q = D; O !== Y; )
      R[Q++] = M[O++];
    return R;
  }
  function A(S) {
    var I = y(S);
    if (I)
      return I;
    throw new Error("Non-base" + a + " character");
  }
  return {
    encode: g,
    decodeUnsafe: y,
    decode: A
  };
}
var yd = gd;
const bd = yd, vd = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var md = bd(vd), wd = Object.create, fi = Object.defineProperty, Ed = Object.getOwnPropertyDescriptor, Ad = Object.getOwnPropertyNames, Md = Object.getPrototypeOf, Sd = Object.prototype.hasOwnProperty, Nd = (e, t) => {
  for (var r in t)
    fi(e, r, { get: t[r], enumerable: !0 });
}, Za = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Ad(t))
      !Sd.call(e, i) && i !== r && fi(e, i, { get: () => t[i], enumerable: !(n = Ed(t, i)) || n.enumerable });
  return e;
}, Td = (e, t, r) => (r = e != null ? wd(Md(e)) : {}, Za(
  t || !e || !e.__esModule ? fi(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), Id = (e) => Za(fi({}, "__esModule", { value: !0 }), e), Ka = {};
Nd(Ka, {
  BCS: () => Je,
  BcsReader: () => $a,
  BcsWriter: () => Xa,
  decodeStr: () => ec,
  encodeStr: () => Ja,
  fromB58: () => To,
  fromB64: () => di,
  fromHEX: () => pi,
  getRustConfig: () => jd,
  getSuiMoveConfig: () => xd,
  registerPrimitives: () => tc,
  splitGenericParameters: () => rc,
  toB58: () => No,
  toB64: () => hi,
  toHEX: () => gi
});
var qt = Id(Ka);
function Od(e) {
  return e > 64 && e < 91 ? e - 65 : e > 96 && e < 123 ? e - 71 : e > 47 && e < 58 ? e + 4 : e === 43 ? 62 : e === 47 ? 63 : 0;
}
function di(e, t) {
  for (var r = e.replace(/[^A-Za-z0-9+/]/g, ""), n = r.length, i = t ? Math.ceil((n * 3 + 1 >> 2) / t) * t : n * 3 + 1 >> 2, o = new Uint8Array(i), a, u, f = 0, p = 0, g = 0; g < n; g++)
    if (u = g & 3, f |= Od(r.charCodeAt(g)) << 6 * (3 - u), u === 3 || n - g === 1) {
      for (a = 0; a < 3 && p < i; a++, p++)
        o[p] = f >>> (16 >>> a & 24) & 255;
      f = 0;
    }
  return o;
}
function Rn(e) {
  return e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : e === 62 ? 43 : e === 63 ? 47 : 65;
}
function hi(e) {
  for (var t = 2, r = "", n = e.length, i = 0, o = 0; o < n; o++)
    t = o % 3, i |= e[o] << (16 >>> t & 24), (t === 2 || e.length - o === 1) && (r += String.fromCodePoint(
      Rn(i >>> 18 & 63),
      Rn(i >>> 12 & 63),
      Rn(i >>> 6 & 63),
      Rn(i & 63)
    ), i = 0);
  return r.slice(0, r.length - 2 + t) + (t === 2 ? "" : t === 1 ? "=" : "==");
}
function pi(e) {
  let t = e.replace("0x", "").match(/.{1,2}/g).map((r) => parseInt(r, 16));
  if (t === null)
    throw new Error(`Unable to parse HEX: ${e}`);
  return Uint8Array.from(t);
}
function gi(e) {
  return e.reduce((t, r) => t + r.toString(16).padStart(2, "0"), "");
}
var Va = Td(md), Ga = 32;
function Fi(e, t) {
  let r = new Uint8Array(t), n = 0;
  for (; e > 0; )
    r[n] = Number(e % BigInt(256)), e = e / BigInt(256), n += 1;
  return r;
}
var No = (e) => Va.default.encode(e), To = (e) => Va.default.decode(e), $a = class {
  constructor(e) {
    this.bytePosition = 0, this.dataView = new DataView(e.buffer);
  }
  shift(e) {
    return this.bytePosition += e, this;
  }
  read8() {
    let e = this.dataView.getUint8(this.bytePosition);
    return this.shift(1), e;
  }
  read16() {
    let e = this.dataView.getUint16(this.bytePosition, !0);
    return this.shift(2), e;
  }
  read32() {
    let e = this.dataView.getUint32(this.bytePosition, !0);
    return this.shift(4), e;
  }
  read64() {
    let e = this.read32(), t = this.read32().toString(16) + e.toString(16).padStart(8, "0");
    return BigInt("0x" + t).toString(10);
  }
  read128() {
    let e = BigInt(this.read64()), t = BigInt(this.read64()).toString(16) + e.toString(16).padStart(16, "0");
    return BigInt("0x" + t).toString(10);
  }
  read256() {
    let e = BigInt(this.read128()), t = BigInt(this.read128()).toString(16) + e.toString(16).padStart(32, "0");
    return BigInt("0x" + t).toString(10);
  }
  readBytes(e) {
    let t = this.bytePosition + this.dataView.byteOffset, r = new Uint8Array(this.dataView.buffer, t, e);
    return this.shift(e), r;
  }
  readULEB() {
    let e = this.bytePosition + this.dataView.byteOffset, t = new Uint8Array(this.dataView.buffer, e), { value: r, length: n } = Cd(t);
    return this.shift(n), r;
  }
  readVec(e) {
    let t = this.readULEB(), r = [];
    for (let n = 0; n < t; n++)
      r.push(e(this, n, t));
    return r;
  }
}, Xa = class {
  constructor({ size: e = 1024, maxSize: t, allocateSize: r = 1024 } = {}) {
    this.bytePosition = 0, this.size = e, this.maxSize = t || e, this.allocateSize = r, this.dataView = new DataView(new ArrayBuffer(e));
  }
  ensureSizeOrGrow(e) {
    const t = this.bytePosition + e;
    if (t > this.size) {
      const r = Math.min(this.maxSize, this.size + this.allocateSize);
      if (t > r)
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`
        );
      this.size = r;
      const n = new ArrayBuffer(this.size);
      new Uint8Array(n).set(new Uint8Array(this.dataView.buffer)), this.dataView = new DataView(n);
    }
  }
  shift(e) {
    return this.bytePosition += e, this;
  }
  write8(e) {
    return this.ensureSizeOrGrow(1), this.dataView.setUint8(this.bytePosition, Number(e)), this.shift(1);
  }
  write16(e) {
    return this.ensureSizeOrGrow(2), this.dataView.setUint16(this.bytePosition, Number(e), !0), this.shift(2);
  }
  write32(e) {
    return this.ensureSizeOrGrow(4), this.dataView.setUint32(this.bytePosition, Number(e), !0), this.shift(4);
  }
  write64(e) {
    return Fi(BigInt(e), 8).forEach((t) => this.write8(t)), this;
  }
  write128(e) {
    return Fi(BigInt(e), 16).forEach((t) => this.write8(t)), this;
  }
  write256(e) {
    return Fi(BigInt(e), 32).forEach((t) => this.write8(t)), this;
  }
  writeULEB(e) {
    return Dd(e).forEach((t) => this.write8(t)), this;
  }
  writeVec(e, t) {
    return this.writeULEB(e.length), Array.from(e).forEach((r, n) => t(this, r, n, e.length)), this;
  }
  *[Symbol.iterator]() {
    for (let e = 0; e < this.bytePosition; e++)
      yield this.dataView.getUint8(e);
    return this.toBytes();
  }
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  toString(e) {
    return Ja(this.toBytes(), e);
  }
};
function Dd(e) {
  let t = [], r = 0;
  if (e === 0)
    return [0];
  for (; e > 0; )
    t[r] = e & 127, (e >>= 7) && (t[r] |= 128), r += 1;
  return t;
}
function Cd(e) {
  let t = 0, r = 0, n = 0;
  for (; ; ) {
    let i = e[n];
    if (n += 1, t |= (i & 127) << r, (i & 128) === 0)
      break;
    r += 7;
  }
  return {
    value: t,
    length: n
  };
}
var yn = class {
  constructor(e) {
    if (this.types = /* @__PURE__ */ new Map(), this.counter = 0, e instanceof yn) {
      this.schema = e.schema, this.types = new Map(e.types);
      return;
    }
    if (this.schema = e, this.registerAddressType(yn.ADDRESS, e.addressLength, e.addressEncoding), this.registerVectorType(e.vectorType), e.types && e.types.structs)
      for (let t of Object.keys(e.types.structs))
        this.registerStructType(t, e.types.structs[t]);
    if (e.types && e.types.enums)
      for (let t of Object.keys(e.types.enums))
        this.registerEnumType(t, e.types.enums[t]);
    if (e.types && e.types.aliases)
      for (let t of Object.keys(e.types.aliases))
        this.registerAlias(t, e.types.aliases[t]);
    e.withPrimitives !== !1 && tc(this);
  }
  tempKey() {
    return `bcs-struct-${++this.counter}`;
  }
  ser(e, t, r) {
    if (typeof e == "string" || Array.isArray(e)) {
      const { name: n, params: i } = this.parseTypeName(e);
      return this.getTypeInterface(n).encode(this, t, r, i);
    }
    if (typeof e == "object") {
      const n = this.tempKey();
      return new yn(this).registerStructType(n, e).ser(n, t, r);
    }
    throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(e)}`);
  }
  de(e, t, r) {
    if (typeof t == "string")
      if (r)
        t = ec(t, r);
      else
        throw new Error("To pass a string to `bcs.de`, specify encoding");
    if (typeof e == "string" || Array.isArray(e)) {
      const { name: n, params: i } = this.parseTypeName(e);
      return this.getTypeInterface(n).decode(this, t, i);
    }
    if (typeof e == "object") {
      const n = new yn(this), i = this.tempKey();
      return n.registerStructType(i, e).de(i, t, r);
    }
    throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(e)}`);
  }
  hasType(e) {
    return this.types.has(e);
  }
  registerAlias(e, t) {
    return this.types.set(e, t), this;
  }
  registerType(e, t, r, n = () => !0) {
    const { name: i, params: o } = this.parseTypeName(e);
    return this.types.set(i, {
      encode(a, u, f, p) {
        const g = o.reduce((y, A, S) => Object.assign(y, { [A]: p[S] }), {});
        return this._encodeRaw.call(a, new Xa(f), u, p, g);
      },
      decode(a, u, f) {
        const p = o.reduce((g, y, A) => Object.assign(g, { [y]: f[A] }), {});
        return this._decodeRaw.call(a, new $a(u), f, p);
      },
      _encodeRaw(a, u, f, p) {
        if (n(u))
          return t.call(this, a, u, f, p);
        throw new Error(`Validation failed for type ${i}, data: ${u}`);
      },
      _decodeRaw(a, u, f) {
        return r.call(this, a, u, f);
      }
    }), this;
  }
  registerAddressType(e, t, r = "hex") {
    switch (r) {
      case "base64":
        return this.registerType(
          e,
          function(n, i) {
            return di(i).reduce((o, a) => o.write8(a), n);
          },
          function(n) {
            return hi(n.readBytes(t));
          }
        );
      case "hex":
        return this.registerType(
          e,
          function(n, i) {
            return pi(i).reduce((o, a) => o.write8(a), n);
          },
          function(n) {
            return gi(n.readBytes(t));
          }
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  registerVectorType(e) {
    let { name: t, params: r } = this.parseTypeName(e);
    if (r.length > 1)
      throw new Error("Vector can have only one type parameter; got " + t);
    return this.registerType(
      e,
      function(n, i, o, a) {
        return n.writeVec(i, (u, f) => {
          let p = o[0];
          if (!p)
            throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);
          let { name: g, params: y } = this.parseTypeName(p);
          if (this.hasType(g))
            return this.getTypeInterface(g)._encodeRaw.call(this, u, f, y, a);
          if (!(g in a))
            throw new Error(
              `Unable to find a matching type definition for ${g} in vector; make sure you passed a generic`
            );
          let { name: A, params: S } = this.parseTypeName(a[g]);
          return this.getTypeInterface(A)._encodeRaw.call(
            this,
            u,
            f,
            S,
            a
          );
        });
      },
      function(n, i, o) {
        return n.readVec((a) => {
          let u = i[0];
          if (!u)
            throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);
          let { name: f, params: p } = this.parseTypeName(u);
          if (this.hasType(f))
            return this.getTypeInterface(f)._decodeRaw.call(this, a, p, o);
          if (!(f in o))
            throw new Error(
              `Unable to find a matching type definition for ${f} in vector; make sure you passed a generic`
            );
          let { name: g, params: y } = this.parseTypeName(o[f]);
          return this.getTypeInterface(g)._decodeRaw.call(
            this,
            a,
            y,
            o
          );
        });
      }
    );
  }
  registerStructType(e, t) {
    for (let a in t) {
      let u = this.tempKey(), f = t[a];
      !Array.isArray(f) && typeof f != "string" && (t[a] = u, this.registerStructType(u, f));
    }
    let r = Object.freeze(t), n = Object.keys(r), { name: i, params: o } = this.parseTypeName(e);
    return this.registerType(
      e,
      function(a, u, f, p) {
        if (!u || u.constructor !== Object)
          throw new Error(`Expected ${i} to be an Object, got: ${u}`);
        if (f.length !== o.length)
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${o.length}, got: ${f.length}`
          );
        for (let g of n) {
          if (!(g in u))
            throw new Error(`Struct ${i} requires field ${g}:${r[g]}`);
          const { name: y, params: A } = this.parseTypeName(
            r[g]
          );
          if (!o.includes(y))
            this.getTypeInterface(y)._encodeRaw.call(
              this,
              a,
              u[g],
              A,
              p
            );
          else {
            const S = o.indexOf(y);
            let { name: I, params: D } = this.parseTypeName(f[S]);
            if (this.hasType(I)) {
              this.getTypeInterface(I)._encodeRaw.call(
                this,
                a,
                u[g],
                D,
                p
              );
              continue;
            }
            if (!(I in p))
              throw new Error(
                `Unable to find a matching type definition for ${I} in ${i}; make sure you passed a generic`
              );
            let { name: L, params: Y } = this.parseTypeName(p[I]);
            this.getTypeInterface(L)._encodeRaw.call(
              this,
              a,
              u[g],
              Y,
              p
            );
          }
        }
        return a;
      },
      function(a, u, f) {
        if (u.length !== o.length)
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${o.length}, got: ${u.length}`
          );
        let p = {};
        for (let g of n) {
          const { name: y, params: A } = this.parseTypeName(
            r[g]
          );
          if (!o.includes(y))
            p[g] = this.getTypeInterface(y)._decodeRaw.call(
              this,
              a,
              A,
              f
            );
          else {
            const S = o.indexOf(y);
            let { name: I, params: D } = this.parseTypeName(u[S]);
            if (this.hasType(I)) {
              p[g] = this.getTypeInterface(I)._decodeRaw.call(
                this,
                a,
                D,
                f
              );
              continue;
            }
            if (!(I in f))
              throw new Error(
                `Unable to find a matching type definition for ${I} in ${i}; make sure you passed a generic`
              );
            let { name: L, params: Y } = this.parseTypeName(f[I]);
            p[g] = this.getTypeInterface(L)._decodeRaw.call(
              this,
              a,
              Y,
              f
            );
          }
        }
        return p;
      }
    );
  }
  registerEnumType(e, t) {
    for (let a in t) {
      let u = this.tempKey(), f = t[a];
      f !== null && !Array.isArray(f) && typeof f != "string" && (t[a] = u, this.registerStructType(u, f));
    }
    let r = Object.freeze(t), n = Object.keys(r), { name: i, params: o } = this.parseTypeName(e);
    return this.registerType(
      e,
      function(a, u, f, p) {
        if (!u)
          throw new Error(`Unable to write enum "${i}", missing data.
Received: "${u}"`);
        if (typeof u != "object")
          throw new Error(
            `Incorrect data passed into enum "${i}", expected object with properties: "${n.join(
              " | "
            )}".
Received: "${JSON.stringify(u)}"`
          );
        let g = Object.keys(u)[0];
        if (g === void 0)
          throw new Error(`Empty object passed as invariant of the enum "${i}"`);
        let y = n.indexOf(g);
        if (y === -1)
          throw new Error(
            `Unknown invariant of the enum "${i}", allowed values: "${n.join(
              " | "
            )}"; received "${g}"`
          );
        let A = n[y], S = r[A];
        if (a.write8(y), S === null)
          return a;
        let I = o.indexOf(S), D = I === -1 ? S : f[I];
        {
          let { name: L, params: Y } = this.parseTypeName(D);
          return this.getTypeInterface(L)._encodeRaw.call(
            this,
            a,
            u[g],
            Y,
            p
          );
        }
      },
      function(a, u, f) {
        let p = a.readULEB(), g = n[p], y = r[g];
        if (p === -1)
          throw new Error(
            `Decoding type mismatch, expected enum "${i}" invariant index, received "${p}"`
          );
        if (y === null)
          return { [g]: !0 };
        let A = o.indexOf(y), S = A === -1 ? y : u[A];
        {
          let { name: I, params: D } = this.parseTypeName(S);
          return {
            [g]: this.getTypeInterface(I)._decodeRaw.call(this, a, D, f)
          };
        }
      }
    );
  }
  getTypeInterface(e) {
    let t = this.types.get(e);
    if (typeof t == "string") {
      let r = [];
      for (; typeof t == "string"; ) {
        if (r.includes(t))
          throw new Error(`Recursive definition found: ${r.join(" -> ")} -> ${t}`);
        r.push(t), t = this.types.get(t);
      }
    }
    if (t === void 0)
      throw new Error(`Type ${e} is not registered`);
    return t;
  }
  parseTypeName(e) {
    if (Array.isArray(e)) {
      let [u, ...f] = e;
      return { name: u, params: f };
    }
    if (typeof e != "string")
      throw new Error(`Illegal type passed as a name of the type: ${e}`);
    let [t, r] = this.schema.genericSeparators || ["<", ">"], n = e.indexOf(t), i = Array.from(e).reverse().indexOf(r);
    if (n === -1 && i === -1)
      return { name: e, params: [] };
    if (n === -1 || i === -1)
      throw new Error(`Unclosed generic in name '${e}'`);
    let o = e.slice(0, n), a = rc(
      e.slice(n + 1, e.length - i - 1),
      this.schema.genericSeparators
    );
    return { name: o, params: a };
  }
}, Je = yn;
Je.U8 = "u8";
Je.U16 = "u16";
Je.U32 = "u32";
Je.U64 = "u64";
Je.U128 = "u128";
Je.U256 = "u256";
Je.BOOL = "bool";
Je.VECTOR = "vector";
Je.ADDRESS = "address";
Je.STRING = "string";
Je.HEX = "hex-string";
Je.BASE58 = "base58-string";
Je.BASE64 = "base64-string";
function Ja(e, t) {
  switch (t) {
    case "base58":
      return No(e);
    case "base64":
      return hi(e);
    case "hex":
      return gi(e);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function ec(e, t) {
  switch (t) {
    case "base58":
      return To(e);
    case "base64":
      return di(e);
    case "hex":
      return pi(e);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function tc(e) {
  e.registerType(
    Je.U8,
    function(t, r) {
      return t.write8(r);
    },
    function(t) {
      return t.read8();
    },
    (t) => t < 256
  ), e.registerType(
    Je.U16,
    function(t, r) {
      return t.write16(r);
    },
    function(t) {
      return t.read16();
    },
    (t) => t < 65536
  ), e.registerType(
    Je.U32,
    function(t, r) {
      return t.write32(r);
    },
    function(t) {
      return t.read32();
    },
    (t) => t <= 4294967296n
  ), e.registerType(
    Je.U64,
    function(t, r) {
      return t.write64(r);
    },
    function(t) {
      return t.read64();
    }
  ), e.registerType(
    Je.U128,
    function(t, r) {
      return t.write128(r);
    },
    function(t) {
      return t.read128();
    }
  ), e.registerType(
    Je.U256,
    function(t, r) {
      return t.write256(r);
    },
    function(t) {
      return t.read256();
    }
  ), e.registerType(
    Je.BOOL,
    function(t, r) {
      return t.write8(r);
    },
    function(t) {
      return t.read8().toString(10) === "1";
    }
  ), e.registerType(
    Je.STRING,
    function(t, r) {
      return t.writeVec(Array.from(r), (n, i) => n.write8(i.charCodeAt(0)));
    },
    function(t) {
      return t.readVec((r) => r.read8()).map((r) => String.fromCharCode(Number(r))).join("");
    },
    (t) => !0
  ), e.registerType(
    Je.HEX,
    function(t, r) {
      return t.writeVec(Array.from(pi(r)), (n, i) => n.write8(i));
    },
    function(t) {
      let r = t.readVec((n) => n.read8());
      return gi(new Uint8Array(r));
    }
  ), e.registerType(
    Je.BASE58,
    function(t, r) {
      return t.writeVec(Array.from(To(r)), (n, i) => n.write8(i));
    },
    function(t) {
      let r = t.readVec((n) => n.read8());
      return No(new Uint8Array(r));
    }
  ), e.registerType(
    Je.BASE64,
    function(t, r) {
      return t.writeVec(Array.from(di(r)), (n, i) => n.write8(i));
    },
    function(t) {
      let r = t.readVec((n) => n.read8());
      return hi(new Uint8Array(r));
    }
  );
}
function jd() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "Vec",
    addressLength: Ga,
    addressEncoding: "hex"
  };
}
function xd() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: Ga,
    addressEncoding: "hex"
  };
}
function rc(e, t = ["<", ">"]) {
  const [r, n] = t, i = [];
  let o = "", a = 0;
  for (let u = 0; u < e.length; u++) {
    const f = e[u];
    if (f === r && a++, f === n && a--, a === 0 && f === ",") {
      i.push(o.trim()), o = "";
      continue;
    }
    o += f;
  }
  return i.push(o.trim()), i;
}
var Io = Object.defineProperty, Ld = Object.getOwnPropertyDescriptor, Bd = Object.getOwnPropertyNames, Rd = Object.prototype.hasOwnProperty, Ud = (e, t) => {
  for (var r in t)
    Io(e, r, { get: t[r], enumerable: !0 });
}, Pd = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Bd(t))
      !Rd.call(e, i) && i !== r && Io(e, i, { get: () => t[i], enumerable: !(n = Ld(t, i)) || n.enumerable });
  return e;
}, kd = (e) => Pd(Io({}, "__esModule", { value: !0 }), e), nc = {};
Ud(nc, {
  bcs: () => Do,
  isPureArg: () => _d
});
var Oo = kd(nc), bt = qt;
function _d(e) {
  return e.Pure !== void 0;
}
const qr = "vector", Fd = {
  kind: "TransactionKind",
  sender: bt.BCS.ADDRESS,
  gasData: "GasData",
  expiration: "TransactionExpiration"
}, zd = {
  enums: {
    "Option<T>": {
      None: null,
      Some: "T"
    },
    ObjectArg: {
      ImmOrOwned: "SuiObjectRef",
      Shared: "SharedObjectRef"
    },
    CallArg: {
      Pure: [qr, bt.BCS.U8],
      Object: "ObjectArg",
      ObjVec: [qr, "ObjectArg"]
    },
    TypeTag: {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: "TypeTag",
      struct: "StructTag",
      u16: null,
      u32: null,
      u256: null
    },
    TransactionKind: {
      ProgrammableTransaction: "ProgrammableTransaction",
      ChangeEpoch: null,
      Genesis: null,
      ConsensusCommitPrologue: null
    },
    TransactionExpiration: {
      None: null,
      Epoch: "unsafe_u64"
    },
    TransactionData: {
      V1: "TransactionDataV1"
    }
  },
  structs: {
    SuiObjectRef: {
      objectId: bt.BCS.ADDRESS,
      version: bt.BCS.U64,
      digest: "ObjectDigest"
    },
    SharedObjectRef: {
      objectId: bt.BCS.ADDRESS,
      initialSharedVersion: bt.BCS.U64,
      mutable: bt.BCS.BOOL
    },
    StructTag: {
      address: bt.BCS.ADDRESS,
      module: bt.BCS.STRING,
      name: bt.BCS.STRING,
      typeParams: [qr, "TypeTag"]
    },
    GasData: {
      payment: [qr, "SuiObjectRef"],
      owner: bt.BCS.ADDRESS,
      price: bt.BCS.U64,
      budget: bt.BCS.U64
    },
    SenderSignedData: {
      data: "TransactionData",
      txSignatures: [qr, [qr, bt.BCS.U8]]
    },
    TransactionDataV1: Fd
  },
  aliases: {
    ObjectDigest: bt.BCS.BASE58
  }
}, Do = new bt.BCS({ ...(0, bt.getSuiMoveConfig)(), types: zd });
Do.registerType(
  "utf8string",
  (e, t) => {
    const r = Array.from(new TextEncoder().encode(t));
    return e.writeVec(r, (n, i) => n.write8(i));
  },
  (e) => {
    let t = e.readVec((r) => r.read8());
    return new TextDecoder().decode(new Uint8Array(t));
  }
);
Do.registerType(
  "unsafe_u64",
  (e, t) => e.write64(t),
  (e) => Number.parseInt(e.read64(), 10)
);
var Co = Object.defineProperty, Qd = Object.getOwnPropertyDescriptor, Wd = Object.getOwnPropertyNames, Yd = Object.prototype.hasOwnProperty, Hd = (e, t) => {
  for (var r in t)
    Co(e, r, { get: t[r], enumerable: !0 });
}, qd = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Wd(t))
      !Yd.call(e, i) && i !== r && Co(e, i, { get: () => t[i], enumerable: !(n = Qd(t, i)) || n.enumerable });
  return e;
}, Zd = (e) => qd(Co({}, "__esModule", { value: !0 }), e), ic = {};
Hd(ic, {
  SUI_ADDRESS_LENGTH: () => jo,
  isValidSuiAddress: () => sc,
  isValidSuiObjectId: () => Gd,
  isValidTransactionDigest: () => Vd,
  normalizeStructTag: () => ac,
  normalizeSuiAddress: () => Lo,
  normalizeSuiObjectId: () => Xd,
  parseStructTag: () => xo
});
var yi = Zd(ic), oc = qt;
const Kd = 32;
function Vd(e) {
  try {
    return (0, oc.fromB58)(e).length === Kd;
  } catch {
    return !1;
  }
}
const jo = 32;
function sc(e) {
  return Jd(e) && eh(e) === jo;
}
function Gd(e) {
  return sc(e);
}
function $d(e) {
  return e.includes("::") ? xo(e) : e;
}
function xo(e) {
  const [t, r] = e.split("::"), n = e.slice(t.length + r.length + 4), i = n.includes("<") ? n.slice(0, n.indexOf("<")) : n, o = n.includes("<") ? (0, oc.splitGenericParameters)(n.slice(n.indexOf("<") + 1, n.lastIndexOf(">"))).map(
    (a) => $d(a.trim())
  ) : [];
  return {
    address: Lo(t),
    module: r,
    name: i,
    typeParams: o
  };
}
function ac(e) {
  const { address: t, module: r, name: n, typeParams: i } = typeof e == "string" ? xo(e) : e, o = i.length > 0 ? `<${i.map(
    (a) => typeof a == "string" ? a : ac(a)
  ).join(",")}>` : "";
  return `${t}::${r}::${n}${o}`;
}
function Lo(e, t = !1) {
  let r = e.toLowerCase();
  return !t && r.startsWith("0x") && (r = r.slice(2)), `0x${r.padStart(jo * 2, "0")}`;
}
function Xd(e, t = !1) {
  return Lo(e, t);
}
function Jd(e) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e) && e.length % 2 === 0;
}
function eh(e) {
  return /^(0x|0X)/.test(e) ? (e.length - 2) / 2 : e.length / 2;
}
var Bo = Object.defineProperty, th = Object.getOwnPropertyDescriptor, rh = Object.getOwnPropertyNames, nh = Object.prototype.hasOwnProperty, ih = (e, t) => {
  for (var r in t)
    Bo(e, r, { get: t[r], enumerable: !0 });
}, oh = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of rh(t))
      !nh.call(e, i) && i !== r && Bo(e, i, { get: () => t[i], enumerable: !(n = th(t, i)) || n.enumerable });
  return e;
}, sh = (e) => oh(Bo({}, "__esModule", { value: !0 }), e), cc = {};
ih(cc, {
  TypeTagSerializer: () => xr
});
var ah = sh(cc), ch = qt, uh = yi;
const lh = /^vector<(.+)>$/, fh = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
class xr {
  static parseFromStr(t, r = !1) {
    if (t === "address")
      return { address: null };
    if (t === "bool")
      return { bool: null };
    if (t === "u8")
      return { u8: null };
    if (t === "u16")
      return { u16: null };
    if (t === "u32")
      return { u32: null };
    if (t === "u64")
      return { u64: null };
    if (t === "u128")
      return { u128: null };
    if (t === "u256")
      return { u256: null };
    if (t === "signer")
      return { signer: null };
    const n = t.match(lh);
    if (n)
      return {
        vector: xr.parseFromStr(n[1], r)
      };
    const i = t.match(fh);
    if (i)
      return {
        struct: {
          address: r ? (0, uh.normalizeSuiAddress)(i[1]) : i[1],
          module: i[2],
          name: i[3],
          typeParams: i[5] === void 0 ? [] : xr.parseStructTypeArgs(i[5], r)
        }
      };
    throw new Error(`Encountered unexpected token when parsing type args for ${t}`);
  }
  static parseStructTypeArgs(t, r = !1) {
    return (0, ch.splitGenericParameters)(t).map(
      (n) => xr.parseFromStr(n, r)
    );
  }
  static tagToString(t) {
    if ("bool" in t)
      return "bool";
    if ("u8" in t)
      return "u8";
    if ("u16" in t)
      return "u16";
    if ("u32" in t)
      return "u32";
    if ("u64" in t)
      return "u64";
    if ("u128" in t)
      return "u128";
    if ("u256" in t)
      return "u256";
    if ("address" in t)
      return "address";
    if ("signer" in t)
      return "signer";
    if ("vector" in t)
      return `vector<${xr.tagToString(t.vector)}>`;
    if ("struct" in t) {
      const r = t.struct, n = r.typeParams.map(xr.tagToString).join(", ");
      return `${r.address}::${r.module}::${r.name}${n ? `<${n}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
}
var Ro = Object.defineProperty, dh = Object.getOwnPropertyDescriptor, hh = Object.getOwnPropertyNames, ph = Object.prototype.hasOwnProperty, gh = (e, t) => {
  for (var r in t)
    Ro(e, r, { get: t[r], enumerable: !0 });
}, yh = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of hh(t))
      !ph.call(e, i) && i !== r && Ro(e, i, { get: () => t[i], enumerable: !(n = dh(t, i)) || n.enumerable });
  return e;
}, bh = (e) => yh(Ro({}, "__esModule", { value: !0 }), e), uc = {};
gh(uc, {
  ARGUMENT: () => er,
  ARGUMENT_INNER: () => Uo,
  CALL_ARG: () => dc,
  COMPRESSED_SIGNATURE: () => so,
  ENUM_KIND: () => bi,
  MULTISIG: () => pc,
  MULTISIG_PK_MAP: () => uo,
  MULTISIG_PUBLIC_KEY: () => co,
  OBJECT_ARG: () => wh,
  OPTION: () => fc,
  PROGRAMMABLE_CALL: () => ko,
  PROGRAMMABLE_CALL_INNER: () => ni,
  PROGRAMMABLE_TX_BLOCK: () => hc,
  PUBLIC_KEY: () => ao,
  TRANSACTION: () => gc,
  TRANSACTION_INNER: () => Po,
  TYPE_TAG: () => oo,
  VECTOR: () => yt,
  builder: () => Ir
});
var lc = bh(uc), At = qt, vh = Oo, xs = ah, mh = yi;
const Uo = "Argument", yt = "vector", fc = "Option", dc = "CallArg", oo = "TypeTag", wh = "ObjectArg", hc = "ProgrammableTransaction", ni = "ProgrammableMoveCall", Po = "Transaction", so = "CompressedSignature", ao = "PublicKey", co = "MultiSigPublicKey", uo = "MultiSigPkMap", pc = "MultiSig", bi = "EnumKind", gc = [bi, Po], er = [bi, Uo], ko = "SimpleProgrammableMoveCall", Ir = new At.BCS(vh.bcs);
_o(Ir, "FixedArray[64]", 64);
_o(Ir, "FixedArray[33]", 33);
_o(Ir, "FixedArray[32]", 32);
Ir.registerStructType(hc, {
  inputs: [yt, dc],
  transactions: [yt, gc]
}).registerEnumType(Uo, {
  GasCoin: null,
  Input: { index: At.BCS.U16 },
  Result: { index: At.BCS.U16 },
  NestedResult: { index: At.BCS.U16, resultIndex: At.BCS.U16 }
}).registerStructType(ni, {
  package: At.BCS.ADDRESS,
  module: At.BCS.STRING,
  function: At.BCS.STRING,
  type_arguments: [yt, oo],
  arguments: [yt, er]
}).registerEnumType(Po, {
  MoveCall: ko,
  TransferObjects: {
    objects: [yt, er],
    address: er
  },
  SplitCoins: { coin: er, amounts: [yt, er] },
  MergeCoins: { destination: er, sources: [yt, er] },
  Publish: {
    modules: [yt, [yt, At.BCS.U8]],
    dependencies: [yt, At.BCS.ADDRESS]
  },
  MakeMoveVec: {
    type: [fc, oo],
    objects: [yt, er]
  },
  Upgrade: {
    modules: [yt, [yt, At.BCS.U8]],
    dependencies: [yt, At.BCS.ADDRESS],
    packageId: At.BCS.ADDRESS,
    ticket: er
  }
}).registerEnumType(so, {
  ED25519: ["FixedArray[64]", "u8"],
  Secp256k1: ["FixedArray[64]", "u8"],
  Secp256r1: ["FixedArray[64]", "u8"]
}).registerEnumType(ao, {
  ED25519: ["FixedArray[32]", "u8"],
  Secp256k1: ["FixedArray[33]", "u8"],
  Secp256r1: ["FixedArray[33]", "u8"]
}).registerStructType(uo, {
  pubKey: ao,
  weight: At.BCS.U8
}).registerStructType(co, {
  pk_map: [yt, uo],
  threshold: At.BCS.U16
}).registerStructType(pc, {
  sigs: [yt, so],
  bitmap: At.BCS.U16,
  multisig_pk: co
});
Ir.registerType(
  [bi, "T"],
  function(e, t, r, n) {
    const i = { [t.kind]: t }, [o] = r;
    return this.getTypeInterface(o)._encodeRaw.call(
      this,
      e,
      i,
      r,
      n
    );
  },
  function(e, t, r) {
    const [n] = t, i = this.getTypeInterface(n)._decodeRaw.call(
      this,
      e,
      t,
      r
    ), o = Object.keys(i)[0];
    return { kind: o, ...i[o] };
  },
  (e) => {
    if (typeof e != "object" && !("kind" in e))
      throw new Error(`EnumKind: Missing property "kind" in the input ${JSON.stringify(e)}`);
    return !0;
  }
);
Ir.registerType(
  ko,
  function(e, t, r, n) {
    const [i, o, a] = t.target.split("::"), u = t.typeArguments.map(
      (f) => xs.TypeTagSerializer.parseFromStr(f, !0)
    );
    return this.getTypeInterface(ni)._encodeRaw.call(
      this,
      e,
      {
        package: (0, mh.normalizeSuiAddress)(i),
        module: o,
        function: a,
        type_arguments: u,
        arguments: t.arguments
      },
      r,
      n
    );
  },
  function(e, t, r) {
    let n = Ir.getTypeInterface(ni)._decodeRaw.call(this, e, t, r);
    return {
      target: [n.package, n.module, n.function].join("::"),
      arguments: n.arguments,
      typeArguments: n.type_arguments.map(xs.TypeTagSerializer.tagToString)
    };
  },
  (e) => e.target.split("::").length === 3
);
function _o(e, t, r) {
  e.registerType(
    t,
    function(n, i, o, a) {
      if (i.length !== r)
        throw new Error(`Expected fixed array of length ${r}, got ${i.length}`);
      if (o.length !== 1)
        throw new Error(`Expected one type parameter in a fixed array, got ${o.length}`);
      let [u] = typeof o[0] == "string" ? [o[0], []] : o[0];
      for (let f of i)
        this.getTypeInterface(u)._encodeRaw.call(this, n, f, o, a);
      return n;
    },
    function(n, i, o) {
      if (i.length !== 1)
        throw new Error(`Expected one type parameter in a fixed array, got ${i.length}`);
      let a = [], [u] = typeof i[0] == "string" ? [i[0], []] : i[0];
      for (let f = 0; f < r; f++)
        a.push(this.getTypeInterface(u)._decodeRaw.call(this, n, i, o));
      return a;
    }
  );
}
var Fo = Object.defineProperty, Eh = Object.getOwnPropertyDescriptor, Ah = Object.getOwnPropertyNames, Mh = Object.prototype.hasOwnProperty, Sh = (e, t) => {
  for (var r in t)
    Fo(e, r, { get: t[r], enumerable: !0 });
}, Nh = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Ah(t))
      !Mh.call(e, i) && i !== r && Fo(e, i, { get: () => t[i], enumerable: !(n = Eh(t, i)) || n.enumerable });
  return e;
}, Th = (e) => Nh(Fo({}, "__esModule", { value: !0 }), e), yc = {};
Sh(yc, {
  SIGNATURE_FLAG_TO_SCHEME: () => mc,
  SIGNATURE_SCHEME_TO_FLAG: () => vc,
  SIGNATURE_SCHEME_TO_SIZE: () => lo,
  parseSerializedSignature: () => Dh,
  toSerializedSignature: () => Oh
});
var rn = Th(yc), bc = qt, Ih = lc;
const vc = {
  ED25519: 0,
  Secp256k1: 1,
  Secp256r1: 2,
  MultiSig: 3,
  Zk: 5
}, lo = {
  ED25519: 32,
  Secp256k1: 33,
  Secp256r1: 33
}, mc = {
  0: "ED25519",
  1: "Secp256k1",
  2: "Secp256r1",
  3: "MultiSig",
  5: "Zk"
};
function Oh({
  signature: e,
  signatureScheme: t,
  pubKey: r,
  publicKey: n = r
}) {
  if (!n)
    throw new Error("`publicKey` is required");
  const i = n.toBytes(), o = new Uint8Array(1 + e.length + i.length);
  return o.set([vc[t]]), o.set(e, 1), o.set(i, 1 + e.length), (0, bc.toB64)(o);
}
function Dh(e) {
  const t = (0, bc.fromB64)(e), r = mc[t[0]];
  if (r === "MultiSig") {
    const a = Ih.builder.de("MultiSig", t.slice(1));
    return {
      serializedSignature: e,
      signatureScheme: r,
      multisig: a,
      bytes: t
    };
  }
  if (r === "Zk")
    throw new Error("Unable to parse a zk signature. (not implemented yet)");
  if (!(r in lo))
    throw new Error("Unsupported signature scheme");
  const n = lo[r], i = t.slice(1, t.length - n), o = t.slice(1 + i.length);
  return {
    serializedSignature: e,
    signatureScheme: r,
    signature: i,
    publicKey: o,
    bytes: t
  };
}
var Lt = {}, ft = {};
Object.defineProperty(ft, "__esModule", { value: !0 });
ft.output = ft.exists = ft.hash = ft.bytes = ft.bool = ft.number = void 0;
function ii(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
ft.number = ii;
function wc(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
ft.bool = wc;
function zo(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
ft.bytes = zo;
function Ec(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  ii(e.outputLen), ii(e.blockLen);
}
ft.hash = Ec;
function Ac(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
ft.exists = Ac;
function Mc(e, t) {
  zo(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
ft.output = Mc;
const Ch = {
  number: ii,
  bool: wc,
  bytes: zo,
  hash: Ec,
  exists: Ac,
  output: Mc
};
ft.default = Ch;
var $r = {}, Qo = {}, Pt = {}, vi = {};
Object.defineProperty(vi, "__esModule", { value: !0 });
vi.crypto = void 0;
vi.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
  const t = vi, r = (O) => O instanceof Uint8Array, n = (O) => new Uint8Array(O.buffer, O.byteOffset, O.byteLength);
  e.u8 = n;
  const i = (O) => new Uint32Array(O.buffer, O.byteOffset, Math.floor(O.byteLength / 4));
  e.u32 = i;
  const o = (O) => new DataView(O.buffer, O.byteOffset, O.byteLength);
  e.createView = o;
  const a = (O, R) => O << 32 - R | O >>> R;
  if (e.rotr = a, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !e.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const u = Array.from({ length: 256 }, (O, R) => R.toString(16).padStart(2, "0"));
  function f(O) {
    if (!r(O))
      throw new Error("Uint8Array expected");
    let R = "";
    for (let Q = 0; Q < O.length; Q++)
      R += u[O[Q]];
    return R;
  }
  e.bytesToHex = f;
  function p(O) {
    if (typeof O != "string")
      throw new Error("hex string expected, got " + typeof O);
    const R = O.length;
    if (R % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + R);
    const Q = new Uint8Array(R / 2);
    for (let G = 0; G < Q.length; G++) {
      const B = G * 2, E = O.slice(B, B + 2), T = Number.parseInt(E, 16);
      if (Number.isNaN(T) || T < 0)
        throw new Error("Invalid byte sequence");
      Q[G] = T;
    }
    return Q;
  }
  e.hexToBytes = p;
  const g = async () => {
  };
  e.nextTick = g;
  async function y(O, R, Q) {
    let G = Date.now();
    for (let B = 0; B < O; B++) {
      Q(B);
      const E = Date.now() - G;
      E >= 0 && E < R || (await (0, e.nextTick)(), G += E);
    }
  }
  e.asyncLoop = y;
  function A(O) {
    if (typeof O != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof O}`);
    return new Uint8Array(new TextEncoder().encode(O));
  }
  e.utf8ToBytes = A;
  function S(O) {
    if (typeof O == "string" && (O = A(O)), !r(O))
      throw new Error(`expected Uint8Array, got ${typeof O}`);
    return O;
  }
  e.toBytes = S;
  function I(...O) {
    const R = new Uint8Array(O.reduce((G, B) => G + B.length, 0));
    let Q = 0;
    return O.forEach((G) => {
      if (!r(G))
        throw new Error("Uint8Array expected");
      R.set(G, Q), Q += G.length;
    }), R;
  }
  e.concatBytes = I;
  class D {
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = D;
  const L = (O) => Object.prototype.toString.call(O) === "[object Object]" && O.constructor === Object;
  function Y(O, R) {
    if (R !== void 0 && (typeof R != "object" || !L(R)))
      throw new Error("Options should be object or undefined");
    return Object.assign(O, R);
  }
  e.checkOpts = Y;
  function M(O) {
    const R = (G) => O().update(S(G)).digest(), Q = O();
    return R.outputLen = Q.outputLen, R.blockLen = Q.blockLen, R.create = () => O(), R;
  }
  e.wrapConstructor = M;
  function N(O) {
    const R = (G, B) => O(B).update(S(G)).digest(), Q = O({});
    return R.outputLen = Q.outputLen, R.blockLen = Q.blockLen, R.create = (G) => O(G), R;
  }
  e.wrapConstructorWithOpts = N;
  function b(O) {
    const R = (G, B) => O(B).update(S(G)).digest(), Q = O({});
    return R.outputLen = Q.outputLen, R.blockLen = Q.blockLen, R.create = (G) => O(G), R;
  }
  e.wrapXOFConstructorWithOpts = b;
  function k(O = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(O));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = k;
})(Pt);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = ft, r = Pt;
  class n extends r.Hash {
    constructor(a, u) {
      super(), this.finished = !1, this.destroyed = !1, t.default.hash(a);
      const f = (0, r.toBytes)(u);
      if (this.iHash = a.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const p = this.blockLen, g = new Uint8Array(p);
      g.set(f.length > p ? a.create().update(f).digest() : f);
      for (let y = 0; y < g.length; y++)
        g[y] ^= 54;
      this.iHash.update(g), this.oHash = a.create();
      for (let y = 0; y < g.length; y++)
        g[y] ^= 106;
      this.oHash.update(g), g.fill(0);
    }
    update(a) {
      return t.default.exists(this), this.iHash.update(a), this;
    }
    digestInto(a) {
      t.default.exists(this), t.default.bytes(a, this.outputLen), this.finished = !0, this.iHash.digestInto(a), this.oHash.update(a), this.oHash.digestInto(a), this.destroy();
    }
    digest() {
      const a = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(a), a;
    }
    _cloneInto(a) {
      a || (a = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: u, iHash: f, finished: p, destroyed: g, blockLen: y, outputLen: A } = this;
      return a = a, a.finished = p, a.destroyed = g, a.blockLen = y, a.outputLen = A, a.oHash = u._cloneInto(a.oHash), a.iHash = f._cloneInto(a.iHash), a;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = n;
  const i = (o, a, u) => new n(o, a).update(u).digest();
  e.hmac = i, e.hmac.create = (o, a) => new n(o, a);
})(Qo);
Object.defineProperty($r, "__esModule", { value: !0 });
$r.pbkdf2Async = $r.pbkdf2 = void 0;
const Un = ft, jh = Qo, Gr = Pt;
function Sc(e, t, r, n) {
  Un.default.hash(e);
  const i = (0, Gr.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: o, dkLen: a, asyncTick: u } = i;
  if (Un.default.number(o), Un.default.number(a), Un.default.number(u), o < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const f = (0, Gr.toBytes)(t), p = (0, Gr.toBytes)(r), g = new Uint8Array(a), y = jh.hmac.create(e, f), A = y._cloneInto().update(p);
  return { c: o, dkLen: a, asyncTick: u, DK: g, PRF: y, PRFSalt: A };
}
function Nc(e, t, r, n, i) {
  return e.destroy(), t.destroy(), n && n.destroy(), i.fill(0), r;
}
function xh(e, t, r, n) {
  const { c: i, dkLen: o, DK: a, PRF: u, PRFSalt: f } = Sc(e, t, r, n);
  let p;
  const g = new Uint8Array(4), y = (0, Gr.createView)(g), A = new Uint8Array(u.outputLen);
  for (let S = 1, I = 0; I < o; S++, I += u.outputLen) {
    const D = a.subarray(I, I + u.outputLen);
    y.setInt32(0, S, !1), (p = f._cloneInto(p)).update(g).digestInto(A), D.set(A.subarray(0, D.length));
    for (let L = 1; L < i; L++) {
      u._cloneInto(p).update(A).digestInto(A);
      for (let Y = 0; Y < D.length; Y++)
        D[Y] ^= A[Y];
    }
  }
  return Nc(u, f, a, p, A);
}
$r.pbkdf2 = xh;
async function Lh(e, t, r, n) {
  const { c: i, dkLen: o, asyncTick: a, DK: u, PRF: f, PRFSalt: p } = Sc(e, t, r, n);
  let g;
  const y = new Uint8Array(4), A = (0, Gr.createView)(y), S = new Uint8Array(f.outputLen);
  for (let I = 1, D = 0; D < o; I++, D += f.outputLen) {
    const L = u.subarray(D, D + f.outputLen);
    A.setInt32(0, I, !1), (g = p._cloneInto(g)).update(y).digestInto(S), L.set(S.subarray(0, L.length)), await (0, Gr.asyncLoop)(i - 1, a, (Y) => {
      f._cloneInto(g).update(S).digestInto(S);
      for (let M = 0; M < L.length; M++)
        L[M] ^= S[M];
    });
  }
  return Nc(f, p, u, g, S);
}
$r.pbkdf2Async = Lh;
var nr = {}, In = {};
Object.defineProperty(In, "__esModule", { value: !0 });
In.SHA2 = void 0;
const zi = ft, hn = Pt;
function Bh(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), a = Number(r >> i & o), u = Number(r & o), f = n ? 4 : 0, p = n ? 0 : 4;
  e.setUint32(t + f, a, n), e.setUint32(t + p, u, n);
}
class Rh extends hn.Hash {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, hn.createView)(this.buffer);
  }
  update(t) {
    zi.default.exists(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = (0, hn.toBytes)(t);
    const o = t.length;
    for (let a = 0; a < o; ) {
      const u = Math.min(i - this.pos, o - a);
      if (u === i) {
        const f = (0, hn.createView)(t);
        for (; i <= o - a; a += i)
          this.process(f, a);
        continue;
      }
      n.set(t.subarray(a, a + u), this.pos), this.pos += u, a += u, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    zi.default.exists(this), zi.default.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    r[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(n, 0), a = 0);
    for (let y = a; y < i; y++)
      r[y] = 0;
    Bh(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const u = (0, hn.createView)(t), f = this.outputLen;
    if (f % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const p = f / 4, g = this.get();
    if (p > g.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let y = 0; y < p; y++)
      u.setUint32(4 * y, g[y], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: a, pos: u } = this;
    return t.length = i, t.pos = u, t.finished = o, t.destroyed = a, i % r && t.buffer.set(n), t;
  }
}
In.SHA2 = Rh;
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.sha224 = nr.sha256 = void 0;
const Uh = In, Wt = Pt, Ph = (e, t, r) => e & t ^ ~e & r, kh = (e, t, r) => e & t ^ e & r ^ t & r, _h = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), pr = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), gr = new Uint32Array(64);
class Tc extends Uh.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = pr[0] | 0, this.B = pr[1] | 0, this.C = pr[2] | 0, this.D = pr[3] | 0, this.E = pr[4] | 0, this.F = pr[5] | 0, this.G = pr[6] | 0, this.H = pr[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: a, G: u, H: f } = this;
    return [t, r, n, i, o, a, u, f];
  }
  set(t, r, n, i, o, a, u, f) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = a | 0, this.G = u | 0, this.H = f | 0;
  }
  process(t, r) {
    for (let y = 0; y < 16; y++, r += 4)
      gr[y] = t.getUint32(r, !1);
    for (let y = 16; y < 64; y++) {
      const A = gr[y - 15], S = gr[y - 2], I = (0, Wt.rotr)(A, 7) ^ (0, Wt.rotr)(A, 18) ^ A >>> 3, D = (0, Wt.rotr)(S, 17) ^ (0, Wt.rotr)(S, 19) ^ S >>> 10;
      gr[y] = D + gr[y - 7] + I + gr[y - 16] | 0;
    }
    let { A: n, B: i, C: o, D: a, E: u, F: f, G: p, H: g } = this;
    for (let y = 0; y < 64; y++) {
      const A = (0, Wt.rotr)(u, 6) ^ (0, Wt.rotr)(u, 11) ^ (0, Wt.rotr)(u, 25), S = g + A + Ph(u, f, p) + _h[y] + gr[y] | 0, I = ((0, Wt.rotr)(n, 2) ^ (0, Wt.rotr)(n, 13) ^ (0, Wt.rotr)(n, 22)) + kh(n, i, o) | 0;
      g = p, p = f, f = u, u = a + S | 0, a = o, o = i, i = n, n = S + I | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, u = u + this.E | 0, f = f + this.F | 0, p = p + this.G | 0, g = g + this.H | 0, this.set(n, i, o, a, u, f, p, g);
  }
  roundClean() {
    gr.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class Fh extends Tc {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
nr.sha256 = (0, Wt.wrapConstructor)(() => new Tc());
nr.sha224 = (0, Wt.wrapConstructor)(() => new Fh());
var Ht = {}, Wo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.add = e.toBig = e.split = e.fromBig = void 0;
  const t = BigInt(2 ** 32 - 1), r = BigInt(32);
  function n(B, E = !1) {
    return E ? { h: Number(B & t), l: Number(B >> r & t) } : { h: Number(B >> r & t) | 0, l: Number(B & t) | 0 };
  }
  e.fromBig = n;
  function i(B, E = !1) {
    let T = new Uint32Array(B.length), C = new Uint32Array(B.length);
    for (let K = 0; K < B.length; K++) {
      const { h: $, l: W } = n(B[K], E);
      [T[K], C[K]] = [$, W];
    }
    return [T, C];
  }
  e.split = i;
  const o = (B, E) => BigInt(B >>> 0) << r | BigInt(E >>> 0);
  e.toBig = o;
  const a = (B, E, T) => B >>> T, u = (B, E, T) => B << 32 - T | E >>> T, f = (B, E, T) => B >>> T | E << 32 - T, p = (B, E, T) => B << 32 - T | E >>> T, g = (B, E, T) => B << 64 - T | E >>> T - 32, y = (B, E, T) => B >>> T - 32 | E << 64 - T, A = (B, E) => E, S = (B, E) => B, I = (B, E, T) => B << T | E >>> 32 - T, D = (B, E, T) => E << T | B >>> 32 - T, L = (B, E, T) => E << T - 32 | B >>> 64 - T, Y = (B, E, T) => B << T - 32 | E >>> 64 - T;
  function M(B, E, T, C) {
    const K = (E >>> 0) + (C >>> 0);
    return { h: B + T + (K / 2 ** 32 | 0) | 0, l: K | 0 };
  }
  e.add = M;
  const N = (B, E, T) => (B >>> 0) + (E >>> 0) + (T >>> 0), b = (B, E, T, C) => E + T + C + (B / 2 ** 32 | 0) | 0, k = (B, E, T, C) => (B >>> 0) + (E >>> 0) + (T >>> 0) + (C >>> 0), O = (B, E, T, C, K) => E + T + C + K + (B / 2 ** 32 | 0) | 0, R = (B, E, T, C, K) => (B >>> 0) + (E >>> 0) + (T >>> 0) + (C >>> 0) + (K >>> 0), Q = (B, E, T, C, K, $) => E + T + C + K + $ + (B / 2 ** 32 | 0) | 0, G = {
    fromBig: n,
    split: i,
    toBig: e.toBig,
    shrSH: a,
    shrSL: u,
    rotrSH: f,
    rotrSL: p,
    rotrBH: g,
    rotrBL: y,
    rotr32H: A,
    rotr32L: S,
    rotlSH: I,
    rotlSL: D,
    rotlBH: L,
    rotlBL: Y,
    add: M,
    add3L: N,
    add3H: b,
    add4L: k,
    add4H: O,
    add5H: Q,
    add5L: R
  };
  e.default = G;
})(Wo);
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.sha384 = Ht.sha512_256 = Ht.sha512_224 = Ht.sha512 = Ht.SHA512 = void 0;
const zh = In, Ue = Wo, mi = Pt, [Qh, Wh] = Ue.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), yr = new Uint32Array(80), br = new Uint32Array(80);
class On extends zh.SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: a, Dh: u, Dl: f, Eh: p, El: g, Fh: y, Fl: A, Gh: S, Gl: I, Hh: D, Hl: L } = this;
    return [t, r, n, i, o, a, u, f, p, g, y, A, S, I, D, L];
  }
  set(t, r, n, i, o, a, u, f, p, g, y, A, S, I, D, L) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = a | 0, this.Dh = u | 0, this.Dl = f | 0, this.Eh = p | 0, this.El = g | 0, this.Fh = y | 0, this.Fl = A | 0, this.Gh = S | 0, this.Gl = I | 0, this.Hh = D | 0, this.Hl = L | 0;
  }
  process(t, r) {
    for (let N = 0; N < 16; N++, r += 4)
      yr[N] = t.getUint32(r), br[N] = t.getUint32(r += 4);
    for (let N = 16; N < 80; N++) {
      const b = yr[N - 15] | 0, k = br[N - 15] | 0, O = Ue.default.rotrSH(b, k, 1) ^ Ue.default.rotrSH(b, k, 8) ^ Ue.default.shrSH(b, k, 7), R = Ue.default.rotrSL(b, k, 1) ^ Ue.default.rotrSL(b, k, 8) ^ Ue.default.shrSL(b, k, 7), Q = yr[N - 2] | 0, G = br[N - 2] | 0, B = Ue.default.rotrSH(Q, G, 19) ^ Ue.default.rotrBH(Q, G, 61) ^ Ue.default.shrSH(Q, G, 6), E = Ue.default.rotrSL(Q, G, 19) ^ Ue.default.rotrBL(Q, G, 61) ^ Ue.default.shrSL(Q, G, 6), T = Ue.default.add4L(R, E, br[N - 7], br[N - 16]), C = Ue.default.add4H(T, O, B, yr[N - 7], yr[N - 16]);
      yr[N] = C | 0, br[N] = T | 0;
    }
    let { Ah: n, Al: i, Bh: o, Bl: a, Ch: u, Cl: f, Dh: p, Dl: g, Eh: y, El: A, Fh: S, Fl: I, Gh: D, Gl: L, Hh: Y, Hl: M } = this;
    for (let N = 0; N < 80; N++) {
      const b = Ue.default.rotrSH(y, A, 14) ^ Ue.default.rotrSH(y, A, 18) ^ Ue.default.rotrBH(y, A, 41), k = Ue.default.rotrSL(y, A, 14) ^ Ue.default.rotrSL(y, A, 18) ^ Ue.default.rotrBL(y, A, 41), O = y & S ^ ~y & D, R = A & I ^ ~A & L, Q = Ue.default.add5L(M, k, R, Wh[N], br[N]), G = Ue.default.add5H(Q, Y, b, O, Qh[N], yr[N]), B = Q | 0, E = Ue.default.rotrSH(n, i, 28) ^ Ue.default.rotrBH(n, i, 34) ^ Ue.default.rotrBH(n, i, 39), T = Ue.default.rotrSL(n, i, 28) ^ Ue.default.rotrBL(n, i, 34) ^ Ue.default.rotrBL(n, i, 39), C = n & o ^ n & u ^ o & u, K = i & a ^ i & f ^ a & f;
      Y = D | 0, M = L | 0, D = S | 0, L = I | 0, S = y | 0, I = A | 0, { h: y, l: A } = Ue.default.add(p | 0, g | 0, G | 0, B | 0), p = u | 0, g = f | 0, u = o | 0, f = a | 0, o = n | 0, a = i | 0;
      const $ = Ue.default.add3L(B, T, K);
      n = Ue.default.add3H($, G, E, C), i = $ | 0;
    }
    ({ h: n, l: i } = Ue.default.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: o, l: a } = Ue.default.add(this.Bh | 0, this.Bl | 0, o | 0, a | 0), { h: u, l: f } = Ue.default.add(this.Ch | 0, this.Cl | 0, u | 0, f | 0), { h: p, l: g } = Ue.default.add(this.Dh | 0, this.Dl | 0, p | 0, g | 0), { h: y, l: A } = Ue.default.add(this.Eh | 0, this.El | 0, y | 0, A | 0), { h: S, l: I } = Ue.default.add(this.Fh | 0, this.Fl | 0, S | 0, I | 0), { h: D, l: L } = Ue.default.add(this.Gh | 0, this.Gl | 0, D | 0, L | 0), { h: Y, l: M } = Ue.default.add(this.Hh | 0, this.Hl | 0, Y | 0, M | 0), this.set(n, i, o, a, u, f, p, g, y, A, S, I, D, L, Y, M);
  }
  roundClean() {
    yr.fill(0), br.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
Ht.SHA512 = On;
class Yh extends On {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
class Hh extends On {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class qh extends On {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
Ht.sha512 = (0, mi.wrapConstructor)(() => new On());
Ht.sha512_224 = (0, mi.wrapConstructor)(() => new Yh());
Ht.sha512_256 = (0, mi.wrapConstructor)(() => new Hh());
Ht.sha384 = (0, mi.wrapConstructor)(() => new qh());
var Ic = {};
(function(e) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64url = e.base64 = e.base32crockford = e.base32hex = e.base32 = e.base16 = e.utils = e.assertNumber = void 0;
  function t(E) {
    if (!Number.isSafeInteger(E))
      throw new Error(`Wrong integer: ${E}`);
  }
  e.assertNumber = t;
  function r(...E) {
    const T = ($, W) => (_) => $(W(_)), C = Array.from(E).reverse().reduce(($, W) => $ ? T($, W.encode) : W.encode, void 0), K = E.reduce(($, W) => $ ? T($, W.decode) : W.decode, void 0);
    return { encode: C, decode: K };
  }
  function n(E) {
    return {
      encode: (T) => {
        if (!Array.isArray(T) || T.length && typeof T[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return T.map((C) => {
          if (t(C), C < 0 || C >= E.length)
            throw new Error(`Digit index outside alphabet: ${C} (alphabet: ${E.length})`);
          return E[C];
        });
      },
      decode: (T) => {
        if (!Array.isArray(T) || T.length && typeof T[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return T.map((C) => {
          if (typeof C != "string")
            throw new Error(`alphabet.decode: not string element=${C}`);
          const K = E.indexOf(C);
          if (K === -1)
            throw new Error(`Unknown letter: "${C}". Allowed: ${E}`);
          return K;
        });
      }
    };
  }
  function i(E = "") {
    if (typeof E != "string")
      throw new Error("join separator should be string");
    return {
      encode: (T) => {
        if (!Array.isArray(T) || T.length && typeof T[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let C of T)
          if (typeof C != "string")
            throw new Error(`join.encode: non-string input=${C}`);
        return T.join(E);
      },
      decode: (T) => {
        if (typeof T != "string")
          throw new Error("join.decode input should be string");
        return T.split(E);
      }
    };
  }
  function o(E, T = "=") {
    if (t(E), typeof T != "string")
      throw new Error("padding chr should be string");
    return {
      encode(C) {
        if (!Array.isArray(C) || C.length && typeof C[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let K of C)
          if (typeof K != "string")
            throw new Error(`padding.encode: non-string input=${K}`);
        for (; C.length * E % 8; )
          C.push(T);
        return C;
      },
      decode(C) {
        if (!Array.isArray(C) || C.length && typeof C[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let $ of C)
          if (typeof $ != "string")
            throw new Error(`padding.decode: non-string input=${$}`);
        let K = C.length;
        if (K * E % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; K > 0 && C[K - 1] === T; K--)
          if (!((K - 1) * E % 8))
            throw new Error("Invalid padding: string has too much padding");
        return C.slice(0, K);
      }
    };
  }
  function a(E) {
    if (typeof E != "function")
      throw new Error("normalize fn should be function");
    return { encode: (T) => T, decode: (T) => E(T) };
  }
  function u(E, T, C) {
    if (T < 2)
      throw new Error(`convertRadix: wrong from=${T}, base cannot be less than 2`);
    if (C < 2)
      throw new Error(`convertRadix: wrong to=${C}, base cannot be less than 2`);
    if (!Array.isArray(E))
      throw new Error("convertRadix: data should be array");
    if (!E.length)
      return [];
    let K = 0;
    const $ = [], W = Array.from(E);
    for (W.forEach((_) => {
      if (t(_), _ < 0 || _ >= T)
        throw new Error(`Wrong integer: ${_}`);
    }); ; ) {
      let _ = 0, ee = !0;
      for (let x = K; x < W.length; x++) {
        const F = W[x], H = T * _ + F;
        if (!Number.isSafeInteger(H) || T * _ / T !== _ || H - F !== T * _)
          throw new Error("convertRadix: carry overflow");
        if (_ = H % C, W[x] = Math.floor(H / C), !Number.isSafeInteger(W[x]) || W[x] * C + _ !== H)
          throw new Error("convertRadix: carry overflow");
        if (ee)
          W[x] ? ee = !1 : K = x;
        else
          continue;
      }
      if ($.push(_), ee)
        break;
    }
    for (let _ = 0; _ < E.length - 1 && E[_] === 0; _++)
      $.push(0);
    return $.reverse();
  }
  const f = (E, T) => T ? f(T, E % T) : E, p = (E, T) => E + (T - f(E, T));
  function g(E, T, C, K) {
    if (!Array.isArray(E))
      throw new Error("convertRadix2: data should be array");
    if (T <= 0 || T > 32)
      throw new Error(`convertRadix2: wrong from=${T}`);
    if (C <= 0 || C > 32)
      throw new Error(`convertRadix2: wrong to=${C}`);
    if (p(T, C) > 32)
      throw new Error(`convertRadix2: carry overflow from=${T} to=${C} carryBits=${p(T, C)}`);
    let $ = 0, W = 0;
    const _ = 2 ** C - 1, ee = [];
    for (const x of E) {
      if (t(x), x >= 2 ** T)
        throw new Error(`convertRadix2: invalid data word=${x} from=${T}`);
      if ($ = $ << T | x, W + T > 32)
        throw new Error(`convertRadix2: carry overflow pos=${W} from=${T}`);
      for (W += T; W >= C; W -= C)
        ee.push(($ >> W - C & _) >>> 0);
      $ &= 2 ** W - 1;
    }
    if ($ = $ << C - W & _, !K && W >= T)
      throw new Error("Excess padding");
    if (!K && $)
      throw new Error(`Non-zero padding: ${$}`);
    return K && W > 0 && ee.push($ >>> 0), ee;
  }
  function y(E) {
    return t(E), {
      encode: (T) => {
        if (!(T instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return u(Array.from(T), 2 ** 8, E);
      },
      decode: (T) => {
        if (!Array.isArray(T) || T.length && typeof T[0] != "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(u(T, E, 2 ** 8));
      }
    };
  }
  function A(E, T = !1) {
    if (t(E), E <= 0 || E > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (p(8, E) > 32 || p(E, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (C) => {
        if (!(C instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return g(Array.from(C), 8, E, !T);
      },
      decode: (C) => {
        if (!Array.isArray(C) || C.length && typeof C[0] != "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(g(C, E, 8, T));
      }
    };
  }
  function S(E) {
    if (typeof E != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...T) {
      try {
        return E.apply(null, T);
      } catch {
      }
    };
  }
  function I(E, T) {
    if (t(E), typeof T != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(C) {
        if (!(C instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const K = T(C).slice(0, E), $ = new Uint8Array(C.length + E);
        return $.set(C), $.set(K, C.length), $;
      },
      decode(C) {
        if (!(C instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const K = C.slice(0, -E), $ = T(K).slice(0, E), W = C.slice(-E);
        for (let _ = 0; _ < E; _++)
          if ($[_] !== W[_])
            throw new Error("Invalid checksum");
        return K;
      }
    };
  }
  e.utils = { alphabet: n, chain: r, checksum: I, radix: y, radix2: A, join: i, padding: o }, e.base16 = r(A(4), n("0123456789ABCDEF"), i("")), e.base32 = r(A(5), n("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), o(5), i("")), e.base32hex = r(A(5), n("0123456789ABCDEFGHIJKLMNOPQRSTUV"), o(5), i("")), e.base32crockford = r(A(5), n("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), i(""), a((E) => E.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), e.base64 = r(A(6), n("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), o(6), i("")), e.base64url = r(A(6), n("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), o(6), i(""));
  const D = (E) => r(y(58), n(E), i(""));
  e.base58 = D("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = D("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = D("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const L = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  e.base58xmr = {
    encode(E) {
      let T = "";
      for (let C = 0; C < E.length; C += 8) {
        const K = E.subarray(C, C + 8);
        T += e.base58.encode(K).padStart(L[K.length], "1");
      }
      return T;
    },
    decode(E) {
      let T = [];
      for (let C = 0; C < E.length; C += 11) {
        const K = E.slice(C, C + 11), $ = L.indexOf(K.length), W = e.base58.decode(K);
        for (let _ = 0; _ < W.length - $; _++)
          if (W[_] !== 0)
            throw new Error("base58xmr: wrong padding");
        T = T.concat(Array.from(W.slice(W.length - $)));
      }
      return Uint8Array.from(T);
    }
  };
  const Y = (E) => r(I(4, (T) => E(E(T))), e.base58);
  e.base58check = Y;
  const M = r(n("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), i("")), N = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function b(E) {
    const T = E >> 25;
    let C = (E & 33554431) << 5;
    for (let K = 0; K < N.length; K++)
      (T >> K & 1) === 1 && (C ^= N[K]);
    return C;
  }
  function k(E, T, C = 1) {
    const K = E.length;
    let $ = 1;
    for (let W = 0; W < K; W++) {
      const _ = E.charCodeAt(W);
      if (_ < 33 || _ > 126)
        throw new Error(`Invalid prefix (${E})`);
      $ = b($) ^ _ >> 5;
    }
    $ = b($);
    for (let W = 0; W < K; W++)
      $ = b($) ^ E.charCodeAt(W) & 31;
    for (let W of T)
      $ = b($) ^ W;
    for (let W = 0; W < 6; W++)
      $ = b($);
    return $ ^= C, M.encode(g([$ % 2 ** 30], 30, 5, !1));
  }
  function O(E) {
    const T = E === "bech32" ? 1 : 734539939, C = A(5), K = C.decode, $ = C.encode, W = S(K);
    function _(H, oe, ae = 90) {
      if (typeof H != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof H}`);
      if (!Array.isArray(oe) || oe.length && typeof oe[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof oe}`);
      const ne = H.length + 7 + oe.length;
      if (ae !== !1 && ne > ae)
        throw new TypeError(`Length ${ne} exceeds limit ${ae}`);
      return H = H.toLowerCase(), `${H}1${M.encode(oe)}${k(H, oe, T)}`;
    }
    function ee(H, oe = 90) {
      if (typeof H != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof H}`);
      if (H.length < 8 || oe !== !1 && H.length > oe)
        throw new TypeError(`Wrong string length: ${H.length} (${H}). Expected (8..${oe})`);
      const ae = H.toLowerCase();
      if (H !== ae && H !== H.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      H = ae;
      const ne = H.lastIndexOf("1");
      if (ne === 0 || ne === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const J = H.slice(0, ne), ce = H.slice(ne + 1);
      if (ce.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const _e = M.decode(ce).slice(0, -6), Ne = k(J, _e, T);
      if (!ce.endsWith(Ne))
        throw new Error(`Invalid checksum in ${H}: expected "${Ne}"`);
      return { prefix: J, words: _e };
    }
    const x = S(ee);
    function F(H) {
      const { prefix: oe, words: ae } = ee(H, !1);
      return { prefix: oe, words: ae, bytes: K(ae) };
    }
    return { encode: _, decode: ee, decodeToBytes: F, decodeUnsafe: x, fromWords: K, fromWordsUnsafe: W, toWords: $ };
  }
  e.bech32 = O("bech32"), e.bech32m = O("bech32m"), e.utf8 = {
    encode: (E) => new TextDecoder().decode(E),
    decode: (E) => new TextEncoder().encode(E)
  }, e.hex = r(A(4), n("0123456789abcdef"), i(""), a((E) => {
    if (typeof E != "string" || E.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof E} with length ${E.length}`);
    return E.toLowerCase();
  }));
  const R = {
    utf8: e.utf8,
    hex: e.hex,
    base16: e.base16,
    base32: e.base32,
    base64: e.base64,
    base64url: e.base64url,
    base58: e.base58,
    base58xmr: e.base58xmr
  }, Q = `Invalid encoding type. Available types: ${Object.keys(R).join(", ")}`, G = (E, T) => {
    if (typeof E != "string" || !R.hasOwnProperty(E))
      throw new TypeError(Q);
    if (!(T instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return R[E].encode(T);
  };
  e.bytesToString = G, e.str = e.bytesToString;
  const B = (E, T) => {
    if (!R.hasOwnProperty(E))
      throw new TypeError(Q);
    if (typeof T != "string")
      throw new TypeError("stringToBytes() expects string");
    return R[E].decode(T);
  };
  e.stringToBytes = B, e.bytes = e.stringToBytes;
})(Ic);
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.mnemonicToSeedSync = Lt.mnemonicToSeed = Lt.validateMnemonic = Lt.entropyToMnemonic = Lt.mnemonicToEntropy = Lt.generateMnemonic = void 0;
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const Oc = ft, Dc = $r, Zh = nr, Cc = Ht, Kh = Pt, Pn = Ic, Vh = (e) => e[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
function jc(e) {
  if (typeof e != "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof e}`);
  return e.normalize("NFKD");
}
function Yo(e) {
  const t = jc(e), r = t.split(" ");
  if (![12, 15, 18, 21, 24].includes(r.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: t, words: r };
}
function xc(e) {
  Oc.default.bytes(e, 16, 20, 24, 28, 32);
}
function Gh(e, t = 128) {
  if (Oc.default.number(t), t % 32 !== 0 || t > 256)
    throw new TypeError("Invalid entropy");
  return Rc((0, Kh.randomBytes)(t / 8), e);
}
Lt.generateMnemonic = Gh;
const $h = (e) => {
  const t = 8 - e.length / 4;
  return new Uint8Array([(0, Zh.sha256)(e)[0] >> t << t]);
};
function Lc(e) {
  if (!Array.isArray(e) || e.length !== 2048 || typeof e[0] != "string")
    throw new Error("Worlist: expected array of 2048 strings");
  return e.forEach((t) => {
    if (typeof t != "string")
      throw new Error(`Wordlist: non-string element: ${t}`);
  }), Pn.utils.chain(Pn.utils.checksum(1, $h), Pn.utils.radix2(11, !0), Pn.utils.alphabet(e));
}
function Bc(e, t) {
  const { words: r } = Yo(e), n = Lc(t).decode(r);
  return xc(n), n;
}
Lt.mnemonicToEntropy = Bc;
function Rc(e, t) {
  return xc(e), Lc(t).encode(e).join(Vh(t) ? "\u3000" : " ");
}
Lt.entropyToMnemonic = Rc;
function Xh(e, t) {
  try {
    Bc(e, t);
  } catch {
    return !1;
  }
  return !0;
}
Lt.validateMnemonic = Xh;
const Uc = (e) => jc(`mnemonic${e}`);
function Jh(e, t = "") {
  return (0, Dc.pbkdf2Async)(Cc.sha512, Yo(e).nfkd, Uc(t), { c: 2048, dkLen: 64 });
}
Lt.mnemonicToSeed = Jh;
function e0(e, t = "") {
  return (0, Dc.pbkdf2)(Cc.sha512, Yo(e).nfkd, Uc(t), { c: 2048, dkLen: 64 });
}
Lt.mnemonicToSeedSync = e0;
var Ho = Object.defineProperty, t0 = Object.getOwnPropertyDescriptor, r0 = Object.getOwnPropertyNames, n0 = Object.prototype.hasOwnProperty, i0 = (e, t) => {
  for (var r in t)
    Ho(e, r, { get: t[r], enumerable: !0 });
}, o0 = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of r0(t))
      !n0.call(e, i) && i !== r && Ho(e, i, { get: () => t[i], enumerable: !(n = t0(t, i)) || n.enumerable });
  return e;
}, s0 = (e) => o0(Ho({}, "__esModule", { value: !0 }), e), Pc = {};
i0(Pc, {
  isValidBIP32Path: () => f0,
  isValidHardenedPath: () => l0,
  mnemonicToSeed: () => kc,
  mnemonicToSeedHex: () => d0
});
var a0 = s0(Pc), c0 = qt, u0 = Lt;
function l0(e) {
  return !!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(e);
}
function f0(e) {
  return !!new RegExp("^m\\/(54|74)'\\/784'\\/[0-9]+'\\/[0-9]+\\/[0-9]+$").test(e);
}
function kc(e) {
  return (0, u0.mnemonicToSeedSync)(e, "");
}
function d0(e) {
  return (0, c0.toHEX)(kc(e));
}
var qo = Object.defineProperty, h0 = Object.getOwnPropertyDescriptor, p0 = Object.getOwnPropertyNames, g0 = Object.prototype.hasOwnProperty, y0 = (e, t) => {
  for (var r in t)
    qo(e, r, { get: t[r], enumerable: !0 });
}, b0 = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of p0(t))
      !g0.call(e, i) && i !== r && qo(e, i, { get: () => t[i], enumerable: !(n = h0(t, i)) || n.enumerable });
  return e;
}, v0 = (e) => b0(qo({}, "__esModule", { value: !0 }), e), _c = {};
y0(_c, {
  AppId: () => Fc,
  IntentScope: () => Qc,
  IntentVersion: () => zc,
  messageWithIntent: () => w0
});
var Zo = v0(_c), Fc = /* @__PURE__ */ ((e) => (e[e.Sui = 0] = "Sui", e))(Fc || {}), zc = /* @__PURE__ */ ((e) => (e[e.V0 = 0] = "V0", e))(zc || {}), Qc = /* @__PURE__ */ ((e) => (e[e.TransactionData = 0] = "TransactionData", e[e.TransactionEffects = 1] = "TransactionEffects", e[e.CheckpointSummary = 2] = "CheckpointSummary", e[e.PersonalMessage = 3] = "PersonalMessage", e))(Qc || {});
function m0(e) {
  return [e, 0, 0];
}
function w0(e, t) {
  const r = m0(e), n = new Uint8Array(r.length + t.length);
  return n.set(r), n.set(t, r.length), n;
}
var nn = {}, Xr = {};
Object.defineProperty(Xr, "__esModule", { value: !0 });
Xr.BLAKE2 = Xr.SIGMA = void 0;
const Zr = ft, kn = Pt;
Xr.SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
class E0 extends kn.Hash {
  constructor(t, r, n = {}, i, o, a) {
    if (super(), this.blockLen = t, this.outputLen = r, this.length = 0, this.pos = 0, this.finished = !1, this.destroyed = !1, Zr.default.number(t), Zr.default.number(r), Zr.default.number(i), r < 0 || r > i)
      throw new Error("outputLen bigger than keyLen");
    if (n.key !== void 0 && (n.key.length < 1 || n.key.length > i))
      throw new Error(`key must be up 1..${i} byte long or undefined`);
    if (n.salt !== void 0 && n.salt.length !== o)
      throw new Error(`salt must be ${o} byte long or undefined`);
    if (n.personalization !== void 0 && n.personalization.length !== a)
      throw new Error(`personalization must be ${a} byte long or undefined`);
    this.buffer32 = (0, kn.u32)(this.buffer = new Uint8Array(t));
  }
  update(t) {
    Zr.default.exists(this);
    const { blockLen: r, buffer: n, buffer32: i } = this;
    t = (0, kn.toBytes)(t);
    const o = t.length, a = t.byteOffset, u = t.buffer;
    for (let f = 0; f < o; ) {
      this.pos === r && (this.compress(i, 0, !1), this.pos = 0);
      const p = Math.min(r - this.pos, o - f), g = a + f;
      if (p === r && !(g % 4) && f + p < o) {
        const y = new Uint32Array(u, g, Math.floor((o - f) / 4));
        for (let A = 0; f + r < o; A += i.length, f += r)
          this.length += r, this.compress(y, A, !1);
        continue;
      }
      n.set(t.subarray(f, f + p), this.pos), this.pos += p, this.length += p, f += p;
    }
    return this;
  }
  digestInto(t) {
    Zr.default.exists(this), Zr.default.output(t, this);
    const { pos: r, buffer32: n } = this;
    this.finished = !0, this.buffer.subarray(r).fill(0), this.compress(n, 0, !0);
    const i = (0, kn.u32)(t);
    this.get().forEach((o, a) => i[a] = o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    const { buffer: r, length: n, finished: i, destroyed: o, outputLen: a, pos: u } = this;
    return t || (t = new this.constructor({ dkLen: a })), t.set(...this.get()), t.length = n, t.finished = i, t.destroyed = o, t.outputLen = a, t.buffer.set(r), t.pos = u, t;
  }
}
Xr.BLAKE2 = E0;
Object.defineProperty(nn, "__esModule", { value: !0 });
nn.blake2b = void 0;
const Ls = Xr, Dt = Wo, Kr = Pt, lt = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), le = new Uint32Array(32);
function vr(e, t, r, n, i, o) {
  const a = i[o], u = i[o + 1];
  let f = le[2 * e], p = le[2 * e + 1], g = le[2 * t], y = le[2 * t + 1], A = le[2 * r], S = le[2 * r + 1], I = le[2 * n], D = le[2 * n + 1], L = Dt.default.add3L(f, g, a);
  p = Dt.default.add3H(L, p, y, u), f = L | 0, { Dh: D, Dl: I } = { Dh: D ^ p, Dl: I ^ f }, { Dh: D, Dl: I } = { Dh: Dt.default.rotr32H(D, I), Dl: Dt.default.rotr32L(D, I) }, { h: S, l: A } = Dt.default.add(S, A, D, I), { Bh: y, Bl: g } = { Bh: y ^ S, Bl: g ^ A }, { Bh: y, Bl: g } = { Bh: Dt.default.rotrSH(y, g, 24), Bl: Dt.default.rotrSL(y, g, 24) }, le[2 * e] = f, le[2 * e + 1] = p, le[2 * t] = g, le[2 * t + 1] = y, le[2 * r] = A, le[2 * r + 1] = S, le[2 * n] = I, le[2 * n + 1] = D;
}
function mr(e, t, r, n, i, o) {
  const a = i[o], u = i[o + 1];
  let f = le[2 * e], p = le[2 * e + 1], g = le[2 * t], y = le[2 * t + 1], A = le[2 * r], S = le[2 * r + 1], I = le[2 * n], D = le[2 * n + 1], L = Dt.default.add3L(f, g, a);
  p = Dt.default.add3H(L, p, y, u), f = L | 0, { Dh: D, Dl: I } = { Dh: D ^ p, Dl: I ^ f }, { Dh: D, Dl: I } = { Dh: Dt.default.rotrSH(D, I, 16), Dl: Dt.default.rotrSL(D, I, 16) }, { h: S, l: A } = Dt.default.add(S, A, D, I), { Bh: y, Bl: g } = { Bh: y ^ S, Bl: g ^ A }, { Bh: y, Bl: g } = { Bh: Dt.default.rotrBH(y, g, 63), Bl: Dt.default.rotrBL(y, g, 63) }, le[2 * e] = f, le[2 * e + 1] = p, le[2 * t] = g, le[2 * t + 1] = y, le[2 * r] = A, le[2 * r + 1] = S, le[2 * n] = I, le[2 * n + 1] = D;
}
class A0 extends Ls.BLAKE2 {
  constructor(t = {}) {
    super(128, t.dkLen === void 0 ? 64 : t.dkLen, t, 64, 16, 16), this.v0l = lt[0] | 0, this.v0h = lt[1] | 0, this.v1l = lt[2] | 0, this.v1h = lt[3] | 0, this.v2l = lt[4] | 0, this.v2h = lt[5] | 0, this.v3l = lt[6] | 0, this.v3h = lt[7] | 0, this.v4l = lt[8] | 0, this.v4h = lt[9] | 0, this.v5l = lt[10] | 0, this.v5h = lt[11] | 0, this.v6l = lt[12] | 0, this.v6h = lt[13] | 0, this.v7l = lt[14] | 0, this.v7h = lt[15] | 0;
    const r = t.key ? t.key.length : 0;
    if (this.v0l ^= this.outputLen | r << 8 | 1 << 16 | 1 << 24, t.salt) {
      const n = (0, Kr.u32)((0, Kr.toBytes)(t.salt));
      this.v4l ^= n[0], this.v4h ^= n[1], this.v5l ^= n[2], this.v5h ^= n[3];
    }
    if (t.personalization) {
      const n = (0, Kr.u32)((0, Kr.toBytes)(t.personalization));
      this.v6l ^= n[0], this.v6h ^= n[1], this.v7l ^= n[2], this.v7h ^= n[3];
    }
    if (t.key) {
      const n = new Uint8Array(this.blockLen);
      n.set((0, Kr.toBytes)(t.key)), this.update(n);
    }
  }
  get() {
    let { v0l: t, v0h: r, v1l: n, v1h: i, v2l: o, v2h: a, v3l: u, v3h: f, v4l: p, v4h: g, v5l: y, v5h: A, v6l: S, v6h: I, v7l: D, v7h: L } = this;
    return [t, r, n, i, o, a, u, f, p, g, y, A, S, I, D, L];
  }
  set(t, r, n, i, o, a, u, f, p, g, y, A, S, I, D, L) {
    this.v0l = t | 0, this.v0h = r | 0, this.v1l = n | 0, this.v1h = i | 0, this.v2l = o | 0, this.v2h = a | 0, this.v3l = u | 0, this.v3h = f | 0, this.v4l = p | 0, this.v4h = g | 0, this.v5l = y | 0, this.v5h = A | 0, this.v6l = S | 0, this.v6h = I | 0, this.v7l = D | 0, this.v7h = L | 0;
  }
  compress(t, r, n) {
    this.get().forEach((f, p) => le[p] = f), le.set(lt, 16);
    let { h: i, l: o } = Dt.default.fromBig(BigInt(this.length));
    le[24] = lt[8] ^ o, le[25] = lt[9] ^ i, n && (le[28] = ~le[28], le[29] = ~le[29]);
    let a = 0;
    const u = Ls.SIGMA;
    for (let f = 0; f < 12; f++)
      vr(0, 4, 8, 12, t, r + 2 * u[a++]), mr(0, 4, 8, 12, t, r + 2 * u[a++]), vr(1, 5, 9, 13, t, r + 2 * u[a++]), mr(1, 5, 9, 13, t, r + 2 * u[a++]), vr(2, 6, 10, 14, t, r + 2 * u[a++]), mr(2, 6, 10, 14, t, r + 2 * u[a++]), vr(3, 7, 11, 15, t, r + 2 * u[a++]), mr(3, 7, 11, 15, t, r + 2 * u[a++]), vr(0, 5, 10, 15, t, r + 2 * u[a++]), mr(0, 5, 10, 15, t, r + 2 * u[a++]), vr(1, 6, 11, 12, t, r + 2 * u[a++]), mr(1, 6, 11, 12, t, r + 2 * u[a++]), vr(2, 7, 8, 13, t, r + 2 * u[a++]), mr(2, 7, 8, 13, t, r + 2 * u[a++]), vr(3, 4, 9, 14, t, r + 2 * u[a++]), mr(3, 4, 9, 14, t, r + 2 * u[a++]);
    this.v0l ^= le[0] ^ le[16], this.v0h ^= le[1] ^ le[17], this.v1l ^= le[2] ^ le[18], this.v1h ^= le[3] ^ le[19], this.v2l ^= le[4] ^ le[20], this.v2h ^= le[5] ^ le[21], this.v3l ^= le[6] ^ le[22], this.v3h ^= le[7] ^ le[23], this.v4l ^= le[8] ^ le[24], this.v4h ^= le[9] ^ le[25], this.v5l ^= le[10] ^ le[26], this.v5h ^= le[11] ^ le[27], this.v6l ^= le[12] ^ le[28], this.v6h ^= le[13] ^ le[29], this.v7l ^= le[14] ^ le[30], this.v7h ^= le[15] ^ le[31], le.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer32.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
nn.blake2b = (0, Kr.wrapConstructorWithOpts)((e) => new A0(e));
var Ko = Object.defineProperty, M0 = Object.getOwnPropertyDescriptor, S0 = Object.getOwnPropertyNames, N0 = Object.prototype.hasOwnProperty, T0 = (e, t) => {
  for (var r in t)
    Ko(e, r, { get: t[r], enumerable: !0 });
}, I0 = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of S0(t))
      !N0.call(e, i) && i !== r && Ko(e, i, { get: () => t[i], enumerable: !(n = M0(t, i)) || n.enumerable });
  return e;
}, O0 = (e) => I0(Ko({}, "__esModule", { value: !0 }), e), Wc = {};
T0(Wc, {
  PublicKey: () => j0,
  bytesEqual: () => Yc
});
var Dn = O0(Wc), Bs = qt, Qi = Zo, Rs = nn, D0 = Oo, Us = yi, C0 = Pt;
function Yc(e, t) {
  if (e === t)
    return !0;
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
class j0 {
  equals(t) {
    return Yc(this.toRawBytes(), t.toRawBytes());
  }
  toBase64() {
    return (0, Bs.toB64)(this.toRawBytes());
  }
  toString() {
    return this.toBase64();
  }
  toSuiPublicKey() {
    const t = this.toSuiBytes();
    return (0, Bs.toB64)(t);
  }
  verifyWithIntent(t, r, n) {
    const i = (0, Qi.messageWithIntent)(n, t), o = (0, Rs.blake2b)(i, { dkLen: 32 });
    return this.verify(o, r);
  }
  verifyPersonalMessage(t, r) {
    return this.verifyWithIntent(
      D0.bcs.ser(["vector", "u8"], t).toBytes(),
      r,
      Qi.IntentScope.PersonalMessage
    );
  }
  verifyTransactionBlock(t, r) {
    return this.verifyWithIntent(t, r, Qi.IntentScope.TransactionData);
  }
  toSuiBytes() {
    const t = this.toRawBytes(), r = new Uint8Array(t.length + 1);
    return r.set([this.flag()]), r.set(t, 1), r;
  }
  toBytes() {
    return this.toRawBytes();
  }
  toSuiAddress() {
    return (0, Us.normalizeSuiAddress)(
      (0, C0.bytesToHex)((0, Rs.blake2b)(this.toSuiBytes(), { dkLen: 32 })).slice(0, Us.SUI_ADDRESS_LENGTH * 2)
    );
  }
}
var Vo = Object.defineProperty, x0 = Object.getOwnPropertyDescriptor, L0 = Object.getOwnPropertyNames, B0 = Object.prototype.hasOwnProperty, R0 = (e, t) => {
  for (var r in t)
    Vo(e, r, { get: t[r], enumerable: !0 });
}, U0 = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of L0(t))
      !B0.call(e, i) && i !== r && Vo(e, i, { get: () => t[i], enumerable: !(n = x0(t, i)) || n.enumerable });
  return e;
}, P0 = (e) => U0(Vo({}, "__esModule", { value: !0 }), e), Hc = {};
R0(Hc, {
  BaseSigner: () => qc,
  Keypair: () => H0,
  LEGACY_PRIVATE_KEY_SIZE: () => Y0,
  PRIVATE_KEY_SIZE: () => W0
});
var k0 = P0(Hc), _0 = rn, Wi = Zo, F0 = nn, z0 = Oo, Q0 = qt;
const W0 = 32, Y0 = 64;
class qc {
  async signWithIntent(t, r) {
    const n = (0, Wi.messageWithIntent)(r, t), i = (0, F0.blake2b)(n, { dkLen: 32 });
    return {
      signature: (0, _0.toSerializedSignature)({
        signature: await this.sign(i),
        signatureScheme: this.getKeyScheme(),
        pubKey: this.getPublicKey()
      }),
      bytes: (0, Q0.toB64)(t)
    };
  }
  async signTransactionBlock(t) {
    return this.signWithIntent(t, Wi.IntentScope.TransactionData);
  }
  async signPersonalMessage(t) {
    return this.signWithIntent(
      z0.bcs.ser(["vector", "u8"], t).toBytes(),
      Wi.IntentScope.PersonalMessage
    );
  }
  async signMessage(t) {
    return this.signPersonalMessage(t);
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress();
  }
}
class H0 extends qc {
}
(function(e) {
  var t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, n = Object.getOwnPropertyNames, i = Object.prototype.hasOwnProperty, o = (A, S) => {
    for (var I in S)
      t(A, I, { get: S[I], enumerable: !0 });
  }, a = (A, S, I, D) => {
    if (S && typeof S == "object" || typeof S == "function")
      for (let L of n(S))
        !i.call(A, L) && L !== I && t(A, L, { get: () => S[L], enumerable: !(D = r(S, L)) || D.enumerable });
    return A;
  }, u = (A, S, I) => (a(A, S, "default"), I && a(I, S, "default")), f = (A) => a(t({}, "__esModule", { value: !0 }), A), p = {};
  o(p, {
    Keypair: () => y.Keypair,
    PublicKey: () => g.PublicKey,
    Signer: () => y.BaseSigner
  }), e.exports = f(p), u(p, rn, e.exports), u(p, a0, e.exports), u(p, Zo, e.exports);
  var g = Dn, y = k0;
})(qa);
function q0(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Zc = { exports: {} };
const Z0 = {}, K0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Z0
}, Symbol.toStringTag, { value: "Module" })), V0 = /* @__PURE__ */ pd(K0);
(function(e) {
  (function(t) {
    var r = function(l) {
      var h, d = new Float64Array(16);
      if (l)
        for (h = 0; h < l.length; h++)
          d[h] = l[h];
      return d;
    }, n = function() {
      throw new Error("no PRNG");
    }, i = new Uint8Array(16), o = new Uint8Array(32);
    o[0] = 9;
    var a = r(), u = r([1]), f = r([56129, 1]), p = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), g = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), y = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), A = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), S = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function I(l, h, d, s) {
      l[h] = d >> 24 & 255, l[h + 1] = d >> 16 & 255, l[h + 2] = d >> 8 & 255, l[h + 3] = d & 255, l[h + 4] = s >> 24 & 255, l[h + 5] = s >> 16 & 255, l[h + 6] = s >> 8 & 255, l[h + 7] = s & 255;
    }
    function D(l, h, d, s, c) {
      var v, m = 0;
      for (v = 0; v < c; v++)
        m |= l[h + v] ^ d[s + v];
      return (1 & m - 1 >>> 8) - 1;
    }
    function L(l, h, d, s) {
      return D(l, h, d, s, 16);
    }
    function Y(l, h, d, s) {
      return D(l, h, d, s, 32);
    }
    function M(l, h, d, s) {
      for (var c = s[0] & 255 | (s[1] & 255) << 8 | (s[2] & 255) << 16 | (s[3] & 255) << 24, v = d[0] & 255 | (d[1] & 255) << 8 | (d[2] & 255) << 16 | (d[3] & 255) << 24, m = d[4] & 255 | (d[5] & 255) << 8 | (d[6] & 255) << 16 | (d[7] & 255) << 24, j = d[8] & 255 | (d[9] & 255) << 8 | (d[10] & 255) << 16 | (d[11] & 255) << 24, z = d[12] & 255 | (d[13] & 255) << 8 | (d[14] & 255) << 16 | (d[15] & 255) << 24, re = s[4] & 255 | (s[5] & 255) << 8 | (s[6] & 255) << 16 | (s[7] & 255) << 24, V = h[0] & 255 | (h[1] & 255) << 8 | (h[2] & 255) << 16 | (h[3] & 255) << 24, fe = h[4] & 255 | (h[5] & 255) << 8 | (h[6] & 255) << 16 | (h[7] & 255) << 24, ie = h[8] & 255 | (h[9] & 255) << 8 | (h[10] & 255) << 16 | (h[11] & 255) << 24, pe = h[12] & 255 | (h[13] & 255) << 8 | (h[14] & 255) << 16 | (h[15] & 255) << 24, ye = s[8] & 255 | (s[9] & 255) << 8 | (s[10] & 255) << 16 | (s[11] & 255) << 24, Ae = d[16] & 255 | (d[17] & 255) << 8 | (d[18] & 255) << 16 | (d[19] & 255) << 24, Te = d[20] & 255 | (d[21] & 255) << 8 | (d[22] & 255) << 16 | (d[23] & 255) << 24, Ie = d[24] & 255 | (d[25] & 255) << 8 | (d[26] & 255) << 16 | (d[27] & 255) << 24, Me = d[28] & 255 | (d[29] & 255) << 8 | (d[30] & 255) << 16 | (d[31] & 255) << 24, De = s[12] & 255 | (s[13] & 255) << 8 | (s[14] & 255) << 16 | (s[15] & 255) << 24, be = c, we = v, de = m, ve = j, me = z, ue = re, U = V, P = fe, X = ie, q = pe, Z = ye, te = Ae, Se = Te, je = Ie, Le = Me, xe = De, w, ke = 0; ke < 20; ke += 2)
        w = be + Se | 0, me ^= w << 7 | w >>> 32 - 7, w = me + be | 0, X ^= w << 9 | w >>> 32 - 9, w = X + me | 0, Se ^= w << 13 | w >>> 32 - 13, w = Se + X | 0, be ^= w << 18 | w >>> 32 - 18, w = ue + we | 0, q ^= w << 7 | w >>> 32 - 7, w = q + ue | 0, je ^= w << 9 | w >>> 32 - 9, w = je + q | 0, we ^= w << 13 | w >>> 32 - 13, w = we + je | 0, ue ^= w << 18 | w >>> 32 - 18, w = Z + U | 0, Le ^= w << 7 | w >>> 32 - 7, w = Le + Z | 0, de ^= w << 9 | w >>> 32 - 9, w = de + Le | 0, U ^= w << 13 | w >>> 32 - 13, w = U + de | 0, Z ^= w << 18 | w >>> 32 - 18, w = xe + te | 0, ve ^= w << 7 | w >>> 32 - 7, w = ve + xe | 0, P ^= w << 9 | w >>> 32 - 9, w = P + ve | 0, te ^= w << 13 | w >>> 32 - 13, w = te + P | 0, xe ^= w << 18 | w >>> 32 - 18, w = be + ve | 0, we ^= w << 7 | w >>> 32 - 7, w = we + be | 0, de ^= w << 9 | w >>> 32 - 9, w = de + we | 0, ve ^= w << 13 | w >>> 32 - 13, w = ve + de | 0, be ^= w << 18 | w >>> 32 - 18, w = ue + me | 0, U ^= w << 7 | w >>> 32 - 7, w = U + ue | 0, P ^= w << 9 | w >>> 32 - 9, w = P + U | 0, me ^= w << 13 | w >>> 32 - 13, w = me + P | 0, ue ^= w << 18 | w >>> 32 - 18, w = Z + q | 0, te ^= w << 7 | w >>> 32 - 7, w = te + Z | 0, X ^= w << 9 | w >>> 32 - 9, w = X + te | 0, q ^= w << 13 | w >>> 32 - 13, w = q + X | 0, Z ^= w << 18 | w >>> 32 - 18, w = xe + Le | 0, Se ^= w << 7 | w >>> 32 - 7, w = Se + xe | 0, je ^= w << 9 | w >>> 32 - 9, w = je + Se | 0, Le ^= w << 13 | w >>> 32 - 13, w = Le + je | 0, xe ^= w << 18 | w >>> 32 - 18;
      be = be + c | 0, we = we + v | 0, de = de + m | 0, ve = ve + j | 0, me = me + z | 0, ue = ue + re | 0, U = U + V | 0, P = P + fe | 0, X = X + ie | 0, q = q + pe | 0, Z = Z + ye | 0, te = te + Ae | 0, Se = Se + Te | 0, je = je + Ie | 0, Le = Le + Me | 0, xe = xe + De | 0, l[0] = be >>> 0 & 255, l[1] = be >>> 8 & 255, l[2] = be >>> 16 & 255, l[3] = be >>> 24 & 255, l[4] = we >>> 0 & 255, l[5] = we >>> 8 & 255, l[6] = we >>> 16 & 255, l[7] = we >>> 24 & 255, l[8] = de >>> 0 & 255, l[9] = de >>> 8 & 255, l[10] = de >>> 16 & 255, l[11] = de >>> 24 & 255, l[12] = ve >>> 0 & 255, l[13] = ve >>> 8 & 255, l[14] = ve >>> 16 & 255, l[15] = ve >>> 24 & 255, l[16] = me >>> 0 & 255, l[17] = me >>> 8 & 255, l[18] = me >>> 16 & 255, l[19] = me >>> 24 & 255, l[20] = ue >>> 0 & 255, l[21] = ue >>> 8 & 255, l[22] = ue >>> 16 & 255, l[23] = ue >>> 24 & 255, l[24] = U >>> 0 & 255, l[25] = U >>> 8 & 255, l[26] = U >>> 16 & 255, l[27] = U >>> 24 & 255, l[28] = P >>> 0 & 255, l[29] = P >>> 8 & 255, l[30] = P >>> 16 & 255, l[31] = P >>> 24 & 255, l[32] = X >>> 0 & 255, l[33] = X >>> 8 & 255, l[34] = X >>> 16 & 255, l[35] = X >>> 24 & 255, l[36] = q >>> 0 & 255, l[37] = q >>> 8 & 255, l[38] = q >>> 16 & 255, l[39] = q >>> 24 & 255, l[40] = Z >>> 0 & 255, l[41] = Z >>> 8 & 255, l[42] = Z >>> 16 & 255, l[43] = Z >>> 24 & 255, l[44] = te >>> 0 & 255, l[45] = te >>> 8 & 255, l[46] = te >>> 16 & 255, l[47] = te >>> 24 & 255, l[48] = Se >>> 0 & 255, l[49] = Se >>> 8 & 255, l[50] = Se >>> 16 & 255, l[51] = Se >>> 24 & 255, l[52] = je >>> 0 & 255, l[53] = je >>> 8 & 255, l[54] = je >>> 16 & 255, l[55] = je >>> 24 & 255, l[56] = Le >>> 0 & 255, l[57] = Le >>> 8 & 255, l[58] = Le >>> 16 & 255, l[59] = Le >>> 24 & 255, l[60] = xe >>> 0 & 255, l[61] = xe >>> 8 & 255, l[62] = xe >>> 16 & 255, l[63] = xe >>> 24 & 255;
    }
    function N(l, h, d, s) {
      for (var c = s[0] & 255 | (s[1] & 255) << 8 | (s[2] & 255) << 16 | (s[3] & 255) << 24, v = d[0] & 255 | (d[1] & 255) << 8 | (d[2] & 255) << 16 | (d[3] & 255) << 24, m = d[4] & 255 | (d[5] & 255) << 8 | (d[6] & 255) << 16 | (d[7] & 255) << 24, j = d[8] & 255 | (d[9] & 255) << 8 | (d[10] & 255) << 16 | (d[11] & 255) << 24, z = d[12] & 255 | (d[13] & 255) << 8 | (d[14] & 255) << 16 | (d[15] & 255) << 24, re = s[4] & 255 | (s[5] & 255) << 8 | (s[6] & 255) << 16 | (s[7] & 255) << 24, V = h[0] & 255 | (h[1] & 255) << 8 | (h[2] & 255) << 16 | (h[3] & 255) << 24, fe = h[4] & 255 | (h[5] & 255) << 8 | (h[6] & 255) << 16 | (h[7] & 255) << 24, ie = h[8] & 255 | (h[9] & 255) << 8 | (h[10] & 255) << 16 | (h[11] & 255) << 24, pe = h[12] & 255 | (h[13] & 255) << 8 | (h[14] & 255) << 16 | (h[15] & 255) << 24, ye = s[8] & 255 | (s[9] & 255) << 8 | (s[10] & 255) << 16 | (s[11] & 255) << 24, Ae = d[16] & 255 | (d[17] & 255) << 8 | (d[18] & 255) << 16 | (d[19] & 255) << 24, Te = d[20] & 255 | (d[21] & 255) << 8 | (d[22] & 255) << 16 | (d[23] & 255) << 24, Ie = d[24] & 255 | (d[25] & 255) << 8 | (d[26] & 255) << 16 | (d[27] & 255) << 24, Me = d[28] & 255 | (d[29] & 255) << 8 | (d[30] & 255) << 16 | (d[31] & 255) << 24, De = s[12] & 255 | (s[13] & 255) << 8 | (s[14] & 255) << 16 | (s[15] & 255) << 24, be = c, we = v, de = m, ve = j, me = z, ue = re, U = V, P = fe, X = ie, q = pe, Z = ye, te = Ae, Se = Te, je = Ie, Le = Me, xe = De, w, ke = 0; ke < 20; ke += 2)
        w = be + Se | 0, me ^= w << 7 | w >>> 32 - 7, w = me + be | 0, X ^= w << 9 | w >>> 32 - 9, w = X + me | 0, Se ^= w << 13 | w >>> 32 - 13, w = Se + X | 0, be ^= w << 18 | w >>> 32 - 18, w = ue + we | 0, q ^= w << 7 | w >>> 32 - 7, w = q + ue | 0, je ^= w << 9 | w >>> 32 - 9, w = je + q | 0, we ^= w << 13 | w >>> 32 - 13, w = we + je | 0, ue ^= w << 18 | w >>> 32 - 18, w = Z + U | 0, Le ^= w << 7 | w >>> 32 - 7, w = Le + Z | 0, de ^= w << 9 | w >>> 32 - 9, w = de + Le | 0, U ^= w << 13 | w >>> 32 - 13, w = U + de | 0, Z ^= w << 18 | w >>> 32 - 18, w = xe + te | 0, ve ^= w << 7 | w >>> 32 - 7, w = ve + xe | 0, P ^= w << 9 | w >>> 32 - 9, w = P + ve | 0, te ^= w << 13 | w >>> 32 - 13, w = te + P | 0, xe ^= w << 18 | w >>> 32 - 18, w = be + ve | 0, we ^= w << 7 | w >>> 32 - 7, w = we + be | 0, de ^= w << 9 | w >>> 32 - 9, w = de + we | 0, ve ^= w << 13 | w >>> 32 - 13, w = ve + de | 0, be ^= w << 18 | w >>> 32 - 18, w = ue + me | 0, U ^= w << 7 | w >>> 32 - 7, w = U + ue | 0, P ^= w << 9 | w >>> 32 - 9, w = P + U | 0, me ^= w << 13 | w >>> 32 - 13, w = me + P | 0, ue ^= w << 18 | w >>> 32 - 18, w = Z + q | 0, te ^= w << 7 | w >>> 32 - 7, w = te + Z | 0, X ^= w << 9 | w >>> 32 - 9, w = X + te | 0, q ^= w << 13 | w >>> 32 - 13, w = q + X | 0, Z ^= w << 18 | w >>> 32 - 18, w = xe + Le | 0, Se ^= w << 7 | w >>> 32 - 7, w = Se + xe | 0, je ^= w << 9 | w >>> 32 - 9, w = je + Se | 0, Le ^= w << 13 | w >>> 32 - 13, w = Le + je | 0, xe ^= w << 18 | w >>> 32 - 18;
      l[0] = be >>> 0 & 255, l[1] = be >>> 8 & 255, l[2] = be >>> 16 & 255, l[3] = be >>> 24 & 255, l[4] = ue >>> 0 & 255, l[5] = ue >>> 8 & 255, l[6] = ue >>> 16 & 255, l[7] = ue >>> 24 & 255, l[8] = Z >>> 0 & 255, l[9] = Z >>> 8 & 255, l[10] = Z >>> 16 & 255, l[11] = Z >>> 24 & 255, l[12] = xe >>> 0 & 255, l[13] = xe >>> 8 & 255, l[14] = xe >>> 16 & 255, l[15] = xe >>> 24 & 255, l[16] = U >>> 0 & 255, l[17] = U >>> 8 & 255, l[18] = U >>> 16 & 255, l[19] = U >>> 24 & 255, l[20] = P >>> 0 & 255, l[21] = P >>> 8 & 255, l[22] = P >>> 16 & 255, l[23] = P >>> 24 & 255, l[24] = X >>> 0 & 255, l[25] = X >>> 8 & 255, l[26] = X >>> 16 & 255, l[27] = X >>> 24 & 255, l[28] = q >>> 0 & 255, l[29] = q >>> 8 & 255, l[30] = q >>> 16 & 255, l[31] = q >>> 24 & 255;
    }
    function b(l, h, d, s) {
      M(l, h, d, s);
    }
    function k(l, h, d, s) {
      N(l, h, d, s);
    }
    var O = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function R(l, h, d, s, c, v, m) {
      var j = new Uint8Array(16), z = new Uint8Array(64), re, V;
      for (V = 0; V < 16; V++)
        j[V] = 0;
      for (V = 0; V < 8; V++)
        j[V] = v[V];
      for (; c >= 64; ) {
        for (b(z, j, m, O), V = 0; V < 64; V++)
          l[h + V] = d[s + V] ^ z[V];
        for (re = 1, V = 8; V < 16; V++)
          re = re + (j[V] & 255) | 0, j[V] = re & 255, re >>>= 8;
        c -= 64, h += 64, s += 64;
      }
      if (c > 0)
        for (b(z, j, m, O), V = 0; V < c; V++)
          l[h + V] = d[s + V] ^ z[V];
      return 0;
    }
    function Q(l, h, d, s, c) {
      var v = new Uint8Array(16), m = new Uint8Array(64), j, z;
      for (z = 0; z < 16; z++)
        v[z] = 0;
      for (z = 0; z < 8; z++)
        v[z] = s[z];
      for (; d >= 64; ) {
        for (b(m, v, c, O), z = 0; z < 64; z++)
          l[h + z] = m[z];
        for (j = 1, z = 8; z < 16; z++)
          j = j + (v[z] & 255) | 0, v[z] = j & 255, j >>>= 8;
        d -= 64, h += 64;
      }
      if (d > 0)
        for (b(m, v, c, O), z = 0; z < d; z++)
          l[h + z] = m[z];
      return 0;
    }
    function G(l, h, d, s, c) {
      var v = new Uint8Array(32);
      k(v, s, c, O);
      for (var m = new Uint8Array(8), j = 0; j < 8; j++)
        m[j] = s[j + 16];
      return Q(l, h, d, m, v);
    }
    function B(l, h, d, s, c, v, m) {
      var j = new Uint8Array(32);
      k(j, v, m, O);
      for (var z = new Uint8Array(8), re = 0; re < 8; re++)
        z[re] = v[re + 16];
      return R(l, h, d, s, c, z, j);
    }
    var E = function(l) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var h, d, s, c, v, m, j, z;
      h = l[0] & 255 | (l[1] & 255) << 8, this.r[0] = h & 8191, d = l[2] & 255 | (l[3] & 255) << 8, this.r[1] = (h >>> 13 | d << 3) & 8191, s = l[4] & 255 | (l[5] & 255) << 8, this.r[2] = (d >>> 10 | s << 6) & 7939, c = l[6] & 255 | (l[7] & 255) << 8, this.r[3] = (s >>> 7 | c << 9) & 8191, v = l[8] & 255 | (l[9] & 255) << 8, this.r[4] = (c >>> 4 | v << 12) & 255, this.r[5] = v >>> 1 & 8190, m = l[10] & 255 | (l[11] & 255) << 8, this.r[6] = (v >>> 14 | m << 2) & 8191, j = l[12] & 255 | (l[13] & 255) << 8, this.r[7] = (m >>> 11 | j << 5) & 8065, z = l[14] & 255 | (l[15] & 255) << 8, this.r[8] = (j >>> 8 | z << 8) & 8191, this.r[9] = z >>> 5 & 127, this.pad[0] = l[16] & 255 | (l[17] & 255) << 8, this.pad[1] = l[18] & 255 | (l[19] & 255) << 8, this.pad[2] = l[20] & 255 | (l[21] & 255) << 8, this.pad[3] = l[22] & 255 | (l[23] & 255) << 8, this.pad[4] = l[24] & 255 | (l[25] & 255) << 8, this.pad[5] = l[26] & 255 | (l[27] & 255) << 8, this.pad[6] = l[28] & 255 | (l[29] & 255) << 8, this.pad[7] = l[30] & 255 | (l[31] & 255) << 8;
    };
    E.prototype.blocks = function(l, h, d) {
      for (var s = this.fin ? 0 : 2048, c, v, m, j, z, re, V, fe, ie, pe, ye, Ae, Te, Ie, Me, De, be, we, de, ve = this.h[0], me = this.h[1], ue = this.h[2], U = this.h[3], P = this.h[4], X = this.h[5], q = this.h[6], Z = this.h[7], te = this.h[8], Se = this.h[9], je = this.r[0], Le = this.r[1], xe = this.r[2], w = this.r[3], ke = this.r[4], Ye = this.r[5], He = this.r[6], Re = this.r[7], ze = this.r[8], Qe = this.r[9]; d >= 16; )
        c = l[h + 0] & 255 | (l[h + 1] & 255) << 8, ve += c & 8191, v = l[h + 2] & 255 | (l[h + 3] & 255) << 8, me += (c >>> 13 | v << 3) & 8191, m = l[h + 4] & 255 | (l[h + 5] & 255) << 8, ue += (v >>> 10 | m << 6) & 8191, j = l[h + 6] & 255 | (l[h + 7] & 255) << 8, U += (m >>> 7 | j << 9) & 8191, z = l[h + 8] & 255 | (l[h + 9] & 255) << 8, P += (j >>> 4 | z << 12) & 8191, X += z >>> 1 & 8191, re = l[h + 10] & 255 | (l[h + 11] & 255) << 8, q += (z >>> 14 | re << 2) & 8191, V = l[h + 12] & 255 | (l[h + 13] & 255) << 8, Z += (re >>> 11 | V << 5) & 8191, fe = l[h + 14] & 255 | (l[h + 15] & 255) << 8, te += (V >>> 8 | fe << 8) & 8191, Se += fe >>> 5 | s, ie = 0, pe = ie, pe += ve * je, pe += me * (5 * Qe), pe += ue * (5 * ze), pe += U * (5 * Re), pe += P * (5 * He), ie = pe >>> 13, pe &= 8191, pe += X * (5 * Ye), pe += q * (5 * ke), pe += Z * (5 * w), pe += te * (5 * xe), pe += Se * (5 * Le), ie += pe >>> 13, pe &= 8191, ye = ie, ye += ve * Le, ye += me * je, ye += ue * (5 * Qe), ye += U * (5 * ze), ye += P * (5 * Re), ie = ye >>> 13, ye &= 8191, ye += X * (5 * He), ye += q * (5 * Ye), ye += Z * (5 * ke), ye += te * (5 * w), ye += Se * (5 * xe), ie += ye >>> 13, ye &= 8191, Ae = ie, Ae += ve * xe, Ae += me * Le, Ae += ue * je, Ae += U * (5 * Qe), Ae += P * (5 * ze), ie = Ae >>> 13, Ae &= 8191, Ae += X * (5 * Re), Ae += q * (5 * He), Ae += Z * (5 * Ye), Ae += te * (5 * ke), Ae += Se * (5 * w), ie += Ae >>> 13, Ae &= 8191, Te = ie, Te += ve * w, Te += me * xe, Te += ue * Le, Te += U * je, Te += P * (5 * Qe), ie = Te >>> 13, Te &= 8191, Te += X * (5 * ze), Te += q * (5 * Re), Te += Z * (5 * He), Te += te * (5 * Ye), Te += Se * (5 * ke), ie += Te >>> 13, Te &= 8191, Ie = ie, Ie += ve * ke, Ie += me * w, Ie += ue * xe, Ie += U * Le, Ie += P * je, ie = Ie >>> 13, Ie &= 8191, Ie += X * (5 * Qe), Ie += q * (5 * ze), Ie += Z * (5 * Re), Ie += te * (5 * He), Ie += Se * (5 * Ye), ie += Ie >>> 13, Ie &= 8191, Me = ie, Me += ve * Ye, Me += me * ke, Me += ue * w, Me += U * xe, Me += P * Le, ie = Me >>> 13, Me &= 8191, Me += X * je, Me += q * (5 * Qe), Me += Z * (5 * ze), Me += te * (5 * Re), Me += Se * (5 * He), ie += Me >>> 13, Me &= 8191, De = ie, De += ve * He, De += me * Ye, De += ue * ke, De += U * w, De += P * xe, ie = De >>> 13, De &= 8191, De += X * Le, De += q * je, De += Z * (5 * Qe), De += te * (5 * ze), De += Se * (5 * Re), ie += De >>> 13, De &= 8191, be = ie, be += ve * Re, be += me * He, be += ue * Ye, be += U * ke, be += P * w, ie = be >>> 13, be &= 8191, be += X * xe, be += q * Le, be += Z * je, be += te * (5 * Qe), be += Se * (5 * ze), ie += be >>> 13, be &= 8191, we = ie, we += ve * ze, we += me * Re, we += ue * He, we += U * Ye, we += P * ke, ie = we >>> 13, we &= 8191, we += X * w, we += q * xe, we += Z * Le, we += te * je, we += Se * (5 * Qe), ie += we >>> 13, we &= 8191, de = ie, de += ve * Qe, de += me * ze, de += ue * Re, de += U * He, de += P * Ye, ie = de >>> 13, de &= 8191, de += X * ke, de += q * w, de += Z * xe, de += te * Le, de += Se * je, ie += de >>> 13, de &= 8191, ie = (ie << 2) + ie | 0, ie = ie + pe | 0, pe = ie & 8191, ie = ie >>> 13, ye += ie, ve = pe, me = ye, ue = Ae, U = Te, P = Ie, X = Me, q = De, Z = be, te = we, Se = de, h += 16, d -= 16;
      this.h[0] = ve, this.h[1] = me, this.h[2] = ue, this.h[3] = U, this.h[4] = P, this.h[5] = X, this.h[6] = q, this.h[7] = Z, this.h[8] = te, this.h[9] = Se;
    }, E.prototype.finish = function(l, h) {
      var d = new Uint16Array(10), s, c, v, m;
      if (this.leftover) {
        for (m = this.leftover, this.buffer[m++] = 1; m < 16; m++)
          this.buffer[m] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (s = this.h[1] >>> 13, this.h[1] &= 8191, m = 2; m < 10; m++)
        this.h[m] += s, s = this.h[m] >>> 13, this.h[m] &= 8191;
      for (this.h[0] += s * 5, s = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += s, s = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += s, d[0] = this.h[0] + 5, s = d[0] >>> 13, d[0] &= 8191, m = 1; m < 10; m++)
        d[m] = this.h[m] + s, s = d[m] >>> 13, d[m] &= 8191;
      for (d[9] -= 1 << 13, c = (s ^ 1) - 1, m = 0; m < 10; m++)
        d[m] &= c;
      for (c = ~c, m = 0; m < 10; m++)
        this.h[m] = this.h[m] & c | d[m];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, v = this.h[0] + this.pad[0], this.h[0] = v & 65535, m = 1; m < 8; m++)
        v = (this.h[m] + this.pad[m] | 0) + (v >>> 16) | 0, this.h[m] = v & 65535;
      l[h + 0] = this.h[0] >>> 0 & 255, l[h + 1] = this.h[0] >>> 8 & 255, l[h + 2] = this.h[1] >>> 0 & 255, l[h + 3] = this.h[1] >>> 8 & 255, l[h + 4] = this.h[2] >>> 0 & 255, l[h + 5] = this.h[2] >>> 8 & 255, l[h + 6] = this.h[3] >>> 0 & 255, l[h + 7] = this.h[3] >>> 8 & 255, l[h + 8] = this.h[4] >>> 0 & 255, l[h + 9] = this.h[4] >>> 8 & 255, l[h + 10] = this.h[5] >>> 0 & 255, l[h + 11] = this.h[5] >>> 8 & 255, l[h + 12] = this.h[6] >>> 0 & 255, l[h + 13] = this.h[6] >>> 8 & 255, l[h + 14] = this.h[7] >>> 0 & 255, l[h + 15] = this.h[7] >>> 8 & 255;
    }, E.prototype.update = function(l, h, d) {
      var s, c;
      if (this.leftover) {
        for (c = 16 - this.leftover, c > d && (c = d), s = 0; s < c; s++)
          this.buffer[this.leftover + s] = l[h + s];
        if (d -= c, h += c, this.leftover += c, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (d >= 16 && (c = d - d % 16, this.blocks(l, h, c), h += c, d -= c), d) {
        for (s = 0; s < d; s++)
          this.buffer[this.leftover + s] = l[h + s];
        this.leftover += d;
      }
    };
    function T(l, h, d, s, c, v) {
      var m = new E(v);
      return m.update(d, s, c), m.finish(l, h), 0;
    }
    function C(l, h, d, s, c, v) {
      var m = new Uint8Array(16);
      return T(m, 0, d, s, c, v), L(l, h, m, 0);
    }
    function K(l, h, d, s, c) {
      var v;
      if (d < 32)
        return -1;
      for (B(l, 0, h, 0, d, s, c), T(l, 16, l, 32, d - 32, l), v = 0; v < 16; v++)
        l[v] = 0;
      return 0;
    }
    function $(l, h, d, s, c) {
      var v, m = new Uint8Array(32);
      if (d < 32 || (G(m, 0, 32, s, c), C(h, 16, h, 32, d - 32, m) !== 0))
        return -1;
      for (B(l, 0, h, 0, d, s, c), v = 0; v < 32; v++)
        l[v] = 0;
      return 0;
    }
    function W(l, h) {
      var d;
      for (d = 0; d < 16; d++)
        l[d] = h[d] | 0;
    }
    function _(l) {
      var h, d, s = 1;
      for (h = 0; h < 16; h++)
        d = l[h] + s + 65535, s = Math.floor(d / 65536), l[h] = d - s * 65536;
      l[0] += s - 1 + 37 * (s - 1);
    }
    function ee(l, h, d) {
      for (var s, c = ~(d - 1), v = 0; v < 16; v++)
        s = c & (l[v] ^ h[v]), l[v] ^= s, h[v] ^= s;
    }
    function x(l, h) {
      var d, s, c, v = r(), m = r();
      for (d = 0; d < 16; d++)
        m[d] = h[d];
      for (_(m), _(m), _(m), s = 0; s < 2; s++) {
        for (v[0] = m[0] - 65517, d = 1; d < 15; d++)
          v[d] = m[d] - 65535 - (v[d - 1] >> 16 & 1), v[d - 1] &= 65535;
        v[15] = m[15] - 32767 - (v[14] >> 16 & 1), c = v[15] >> 16 & 1, v[14] &= 65535, ee(m, v, 1 - c);
      }
      for (d = 0; d < 16; d++)
        l[2 * d] = m[d] & 255, l[2 * d + 1] = m[d] >> 8;
    }
    function F(l, h) {
      var d = new Uint8Array(32), s = new Uint8Array(32);
      return x(d, l), x(s, h), Y(d, 0, s, 0);
    }
    function H(l) {
      var h = new Uint8Array(32);
      return x(h, l), h[0] & 1;
    }
    function oe(l, h) {
      var d;
      for (d = 0; d < 16; d++)
        l[d] = h[2 * d] + (h[2 * d + 1] << 8);
      l[15] &= 32767;
    }
    function ae(l, h, d) {
      for (var s = 0; s < 16; s++)
        l[s] = h[s] + d[s];
    }
    function ne(l, h, d) {
      for (var s = 0; s < 16; s++)
        l[s] = h[s] - d[s];
    }
    function J(l, h, d) {
      var s, c, v = 0, m = 0, j = 0, z = 0, re = 0, V = 0, fe = 0, ie = 0, pe = 0, ye = 0, Ae = 0, Te = 0, Ie = 0, Me = 0, De = 0, be = 0, we = 0, de = 0, ve = 0, me = 0, ue = 0, U = 0, P = 0, X = 0, q = 0, Z = 0, te = 0, Se = 0, je = 0, Le = 0, xe = 0, w = d[0], ke = d[1], Ye = d[2], He = d[3], Re = d[4], ze = d[5], Qe = d[6], at = d[7], Ze = d[8], nt = d[9], it = d[10], ot = d[11], ut = d[12], mt = d[13], wt = d[14], Et = d[15];
      s = h[0], v += s * w, m += s * ke, j += s * Ye, z += s * He, re += s * Re, V += s * ze, fe += s * Qe, ie += s * at, pe += s * Ze, ye += s * nt, Ae += s * it, Te += s * ot, Ie += s * ut, Me += s * mt, De += s * wt, be += s * Et, s = h[1], m += s * w, j += s * ke, z += s * Ye, re += s * He, V += s * Re, fe += s * ze, ie += s * Qe, pe += s * at, ye += s * Ze, Ae += s * nt, Te += s * it, Ie += s * ot, Me += s * ut, De += s * mt, be += s * wt, we += s * Et, s = h[2], j += s * w, z += s * ke, re += s * Ye, V += s * He, fe += s * Re, ie += s * ze, pe += s * Qe, ye += s * at, Ae += s * Ze, Te += s * nt, Ie += s * it, Me += s * ot, De += s * ut, be += s * mt, we += s * wt, de += s * Et, s = h[3], z += s * w, re += s * ke, V += s * Ye, fe += s * He, ie += s * Re, pe += s * ze, ye += s * Qe, Ae += s * at, Te += s * Ze, Ie += s * nt, Me += s * it, De += s * ot, be += s * ut, we += s * mt, de += s * wt, ve += s * Et, s = h[4], re += s * w, V += s * ke, fe += s * Ye, ie += s * He, pe += s * Re, ye += s * ze, Ae += s * Qe, Te += s * at, Ie += s * Ze, Me += s * nt, De += s * it, be += s * ot, we += s * ut, de += s * mt, ve += s * wt, me += s * Et, s = h[5], V += s * w, fe += s * ke, ie += s * Ye, pe += s * He, ye += s * Re, Ae += s * ze, Te += s * Qe, Ie += s * at, Me += s * Ze, De += s * nt, be += s * it, we += s * ot, de += s * ut, ve += s * mt, me += s * wt, ue += s * Et, s = h[6], fe += s * w, ie += s * ke, pe += s * Ye, ye += s * He, Ae += s * Re, Te += s * ze, Ie += s * Qe, Me += s * at, De += s * Ze, be += s * nt, we += s * it, de += s * ot, ve += s * ut, me += s * mt, ue += s * wt, U += s * Et, s = h[7], ie += s * w, pe += s * ke, ye += s * Ye, Ae += s * He, Te += s * Re, Ie += s * ze, Me += s * Qe, De += s * at, be += s * Ze, we += s * nt, de += s * it, ve += s * ot, me += s * ut, ue += s * mt, U += s * wt, P += s * Et, s = h[8], pe += s * w, ye += s * ke, Ae += s * Ye, Te += s * He, Ie += s * Re, Me += s * ze, De += s * Qe, be += s * at, we += s * Ze, de += s * nt, ve += s * it, me += s * ot, ue += s * ut, U += s * mt, P += s * wt, X += s * Et, s = h[9], ye += s * w, Ae += s * ke, Te += s * Ye, Ie += s * He, Me += s * Re, De += s * ze, be += s * Qe, we += s * at, de += s * Ze, ve += s * nt, me += s * it, ue += s * ot, U += s * ut, P += s * mt, X += s * wt, q += s * Et, s = h[10], Ae += s * w, Te += s * ke, Ie += s * Ye, Me += s * He, De += s * Re, be += s * ze, we += s * Qe, de += s * at, ve += s * Ze, me += s * nt, ue += s * it, U += s * ot, P += s * ut, X += s * mt, q += s * wt, Z += s * Et, s = h[11], Te += s * w, Ie += s * ke, Me += s * Ye, De += s * He, be += s * Re, we += s * ze, de += s * Qe, ve += s * at, me += s * Ze, ue += s * nt, U += s * it, P += s * ot, X += s * ut, q += s * mt, Z += s * wt, te += s * Et, s = h[12], Ie += s * w, Me += s * ke, De += s * Ye, be += s * He, we += s * Re, de += s * ze, ve += s * Qe, me += s * at, ue += s * Ze, U += s * nt, P += s * it, X += s * ot, q += s * ut, Z += s * mt, te += s * wt, Se += s * Et, s = h[13], Me += s * w, De += s * ke, be += s * Ye, we += s * He, de += s * Re, ve += s * ze, me += s * Qe, ue += s * at, U += s * Ze, P += s * nt, X += s * it, q += s * ot, Z += s * ut, te += s * mt, Se += s * wt, je += s * Et, s = h[14], De += s * w, be += s * ke, we += s * Ye, de += s * He, ve += s * Re, me += s * ze, ue += s * Qe, U += s * at, P += s * Ze, X += s * nt, q += s * it, Z += s * ot, te += s * ut, Se += s * mt, je += s * wt, Le += s * Et, s = h[15], be += s * w, we += s * ke, de += s * Ye, ve += s * He, me += s * Re, ue += s * ze, U += s * Qe, P += s * at, X += s * Ze, q += s * nt, Z += s * it, te += s * ot, Se += s * ut, je += s * mt, Le += s * wt, xe += s * Et, v += 38 * we, m += 38 * de, j += 38 * ve, z += 38 * me, re += 38 * ue, V += 38 * U, fe += 38 * P, ie += 38 * X, pe += 38 * q, ye += 38 * Z, Ae += 38 * te, Te += 38 * Se, Ie += 38 * je, Me += 38 * Le, De += 38 * xe, c = 1, s = v + c + 65535, c = Math.floor(s / 65536), v = s - c * 65536, s = m + c + 65535, c = Math.floor(s / 65536), m = s - c * 65536, s = j + c + 65535, c = Math.floor(s / 65536), j = s - c * 65536, s = z + c + 65535, c = Math.floor(s / 65536), z = s - c * 65536, s = re + c + 65535, c = Math.floor(s / 65536), re = s - c * 65536, s = V + c + 65535, c = Math.floor(s / 65536), V = s - c * 65536, s = fe + c + 65535, c = Math.floor(s / 65536), fe = s - c * 65536, s = ie + c + 65535, c = Math.floor(s / 65536), ie = s - c * 65536, s = pe + c + 65535, c = Math.floor(s / 65536), pe = s - c * 65536, s = ye + c + 65535, c = Math.floor(s / 65536), ye = s - c * 65536, s = Ae + c + 65535, c = Math.floor(s / 65536), Ae = s - c * 65536, s = Te + c + 65535, c = Math.floor(s / 65536), Te = s - c * 65536, s = Ie + c + 65535, c = Math.floor(s / 65536), Ie = s - c * 65536, s = Me + c + 65535, c = Math.floor(s / 65536), Me = s - c * 65536, s = De + c + 65535, c = Math.floor(s / 65536), De = s - c * 65536, s = be + c + 65535, c = Math.floor(s / 65536), be = s - c * 65536, v += c - 1 + 37 * (c - 1), c = 1, s = v + c + 65535, c = Math.floor(s / 65536), v = s - c * 65536, s = m + c + 65535, c = Math.floor(s / 65536), m = s - c * 65536, s = j + c + 65535, c = Math.floor(s / 65536), j = s - c * 65536, s = z + c + 65535, c = Math.floor(s / 65536), z = s - c * 65536, s = re + c + 65535, c = Math.floor(s / 65536), re = s - c * 65536, s = V + c + 65535, c = Math.floor(s / 65536), V = s - c * 65536, s = fe + c + 65535, c = Math.floor(s / 65536), fe = s - c * 65536, s = ie + c + 65535, c = Math.floor(s / 65536), ie = s - c * 65536, s = pe + c + 65535, c = Math.floor(s / 65536), pe = s - c * 65536, s = ye + c + 65535, c = Math.floor(s / 65536), ye = s - c * 65536, s = Ae + c + 65535, c = Math.floor(s / 65536), Ae = s - c * 65536, s = Te + c + 65535, c = Math.floor(s / 65536), Te = s - c * 65536, s = Ie + c + 65535, c = Math.floor(s / 65536), Ie = s - c * 65536, s = Me + c + 65535, c = Math.floor(s / 65536), Me = s - c * 65536, s = De + c + 65535, c = Math.floor(s / 65536), De = s - c * 65536, s = be + c + 65535, c = Math.floor(s / 65536), be = s - c * 65536, v += c - 1 + 37 * (c - 1), l[0] = v, l[1] = m, l[2] = j, l[3] = z, l[4] = re, l[5] = V, l[6] = fe, l[7] = ie, l[8] = pe, l[9] = ye, l[10] = Ae, l[11] = Te, l[12] = Ie, l[13] = Me, l[14] = De, l[15] = be;
    }
    function ce(l, h) {
      J(l, h, h);
    }
    function _e(l, h) {
      var d = r(), s;
      for (s = 0; s < 16; s++)
        d[s] = h[s];
      for (s = 253; s >= 0; s--)
        ce(d, d), s !== 2 && s !== 4 && J(d, d, h);
      for (s = 0; s < 16; s++)
        l[s] = d[s];
    }
    function Ne(l, h) {
      var d = r(), s;
      for (s = 0; s < 16; s++)
        d[s] = h[s];
      for (s = 250; s >= 0; s--)
        ce(d, d), s !== 1 && J(d, d, h);
      for (s = 0; s < 16; s++)
        l[s] = d[s];
    }
    function Ee(l, h, d) {
      var s = new Uint8Array(32), c = new Float64Array(80), v, m, j = r(), z = r(), re = r(), V = r(), fe = r(), ie = r();
      for (m = 0; m < 31; m++)
        s[m] = h[m];
      for (s[31] = h[31] & 127 | 64, s[0] &= 248, oe(c, d), m = 0; m < 16; m++)
        z[m] = c[m], V[m] = j[m] = re[m] = 0;
      for (j[0] = V[0] = 1, m = 254; m >= 0; --m)
        v = s[m >>> 3] >>> (m & 7) & 1, ee(j, z, v), ee(re, V, v), ae(fe, j, re), ne(j, j, re), ae(re, z, V), ne(z, z, V), ce(V, fe), ce(ie, j), J(j, re, j), J(re, z, fe), ae(fe, j, re), ne(j, j, re), ce(z, j), ne(re, V, ie), J(j, re, f), ae(j, j, V), J(re, re, j), J(j, V, ie), J(V, z, c), ce(z, fe), ee(j, z, v), ee(re, V, v);
      for (m = 0; m < 16; m++)
        c[m + 16] = j[m], c[m + 32] = re[m], c[m + 48] = z[m], c[m + 64] = V[m];
      var pe = c.subarray(32), ye = c.subarray(16);
      return _e(pe, pe), J(ye, ye, pe), x(l, ye), 0;
    }
    function qe(l, h) {
      return Ee(l, h, o);
    }
    function $e(l, h) {
      return n(h, 32), qe(l, h);
    }
    function et(l, h, d) {
      var s = new Uint8Array(32);
      return Ee(s, d, h), k(l, i, s, O);
    }
    var se = K, he = $;
    function Oe(l, h, d, s, c, v) {
      var m = new Uint8Array(32);
      return et(m, c, v), se(l, h, d, s, m);
    }
    function We(l, h, d, s, c, v) {
      var m = new Uint8Array(32);
      return et(m, c, v), he(l, h, d, s, m);
    }
    var Fe = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function Ge(l, h, d, s) {
      for (var c = new Int32Array(16), v = new Int32Array(16), m, j, z, re, V, fe, ie, pe, ye, Ae, Te, Ie, Me, De, be, we, de, ve, me, ue, U, P, X, q, Z, te, Se = l[0], je = l[1], Le = l[2], xe = l[3], w = l[4], ke = l[5], Ye = l[6], He = l[7], Re = h[0], ze = h[1], Qe = h[2], at = h[3], Ze = h[4], nt = h[5], it = h[6], ot = h[7], ut = 0; s >= 128; ) {
        for (me = 0; me < 16; me++)
          ue = 8 * me + ut, c[me] = d[ue + 0] << 24 | d[ue + 1] << 16 | d[ue + 2] << 8 | d[ue + 3], v[me] = d[ue + 4] << 24 | d[ue + 5] << 16 | d[ue + 6] << 8 | d[ue + 7];
        for (me = 0; me < 80; me++)
          if (m = Se, j = je, z = Le, re = xe, V = w, fe = ke, ie = Ye, pe = He, ye = Re, Ae = ze, Te = Qe, Ie = at, Me = Ze, De = nt, be = it, we = ot, U = He, P = ot, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = (w >>> 14 | Ze << 32 - 14) ^ (w >>> 18 | Ze << 32 - 18) ^ (Ze >>> 41 - 32 | w << 32 - (41 - 32)), P = (Ze >>> 14 | w << 32 - 14) ^ (Ze >>> 18 | w << 32 - 18) ^ (w >>> 41 - 32 | Ze << 32 - (41 - 32)), X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, U = w & ke ^ ~w & Ye, P = Ze & nt ^ ~Ze & it, X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, U = Fe[me * 2], P = Fe[me * 2 + 1], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, U = c[me % 16], P = v[me % 16], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, de = Z & 65535 | te << 16, ve = X & 65535 | q << 16, U = de, P = ve, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = (Se >>> 28 | Re << 32 - 28) ^ (Re >>> 34 - 32 | Se << 32 - (34 - 32)) ^ (Re >>> 39 - 32 | Se << 32 - (39 - 32)), P = (Re >>> 28 | Se << 32 - 28) ^ (Se >>> 34 - 32 | Re << 32 - (34 - 32)) ^ (Se >>> 39 - 32 | Re << 32 - (39 - 32)), X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, U = Se & je ^ Se & Le ^ je & Le, P = Re & ze ^ Re & Qe ^ ze & Qe, X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, pe = Z & 65535 | te << 16, we = X & 65535 | q << 16, U = re, P = Ie, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = de, P = ve, X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, re = Z & 65535 | te << 16, Ie = X & 65535 | q << 16, je = m, Le = j, xe = z, w = re, ke = V, Ye = fe, He = ie, Se = pe, ze = ye, Qe = Ae, at = Te, Ze = Ie, nt = Me, it = De, ot = be, Re = we, me % 16 === 15)
            for (ue = 0; ue < 16; ue++)
              U = c[ue], P = v[ue], X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = c[(ue + 9) % 16], P = v[(ue + 9) % 16], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, de = c[(ue + 1) % 16], ve = v[(ue + 1) % 16], U = (de >>> 1 | ve << 32 - 1) ^ (de >>> 8 | ve << 32 - 8) ^ de >>> 7, P = (ve >>> 1 | de << 32 - 1) ^ (ve >>> 8 | de << 32 - 8) ^ (ve >>> 7 | de << 32 - 7), X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, de = c[(ue + 14) % 16], ve = v[(ue + 14) % 16], U = (de >>> 19 | ve << 32 - 19) ^ (ve >>> 61 - 32 | de << 32 - (61 - 32)) ^ de >>> 6, P = (ve >>> 19 | de << 32 - 19) ^ (de >>> 61 - 32 | ve << 32 - (61 - 32)) ^ (ve >>> 6 | de << 32 - 6), X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, c[ue] = Z & 65535 | te << 16, v[ue] = X & 65535 | q << 16;
        U = Se, P = Re, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[0], P = h[0], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[0] = Se = Z & 65535 | te << 16, h[0] = Re = X & 65535 | q << 16, U = je, P = ze, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[1], P = h[1], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[1] = je = Z & 65535 | te << 16, h[1] = ze = X & 65535 | q << 16, U = Le, P = Qe, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[2], P = h[2], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[2] = Le = Z & 65535 | te << 16, h[2] = Qe = X & 65535 | q << 16, U = xe, P = at, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[3], P = h[3], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[3] = xe = Z & 65535 | te << 16, h[3] = at = X & 65535 | q << 16, U = w, P = Ze, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[4], P = h[4], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[4] = w = Z & 65535 | te << 16, h[4] = Ze = X & 65535 | q << 16, U = ke, P = nt, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[5], P = h[5], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[5] = ke = Z & 65535 | te << 16, h[5] = nt = X & 65535 | q << 16, U = Ye, P = it, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[6], P = h[6], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[6] = Ye = Z & 65535 | te << 16, h[6] = it = X & 65535 | q << 16, U = He, P = ot, X = P & 65535, q = P >>> 16, Z = U & 65535, te = U >>> 16, U = l[7], P = h[7], X += P & 65535, q += P >>> 16, Z += U & 65535, te += U >>> 16, q += X >>> 16, Z += q >>> 16, te += Z >>> 16, l[7] = He = Z & 65535 | te << 16, h[7] = ot = X & 65535 | q << 16, ut += 128, s -= 128;
      }
      return s;
    }
    function Ke(l, h, d) {
      var s = new Int32Array(8), c = new Int32Array(8), v = new Uint8Array(256), m, j = d;
      for (s[0] = 1779033703, s[1] = 3144134277, s[2] = 1013904242, s[3] = 2773480762, s[4] = 1359893119, s[5] = 2600822924, s[6] = 528734635, s[7] = 1541459225, c[0] = 4089235720, c[1] = 2227873595, c[2] = 4271175723, c[3] = 1595750129, c[4] = 2917565137, c[5] = 725511199, c[6] = 4215389547, c[7] = 327033209, Ge(s, c, h, d), d %= 128, m = 0; m < d; m++)
        v[m] = h[j - d + m];
      for (v[d] = 128, d = 256 - 128 * (d < 112 ? 1 : 0), v[d - 9] = 0, I(v, d - 8, j / 536870912 | 0, j << 3), Ge(s, c, v, d), m = 0; m < 8; m++)
        I(l, 8 * m, s[m], c[m]);
      return 0;
    }
    function rt(l, h) {
      var d = r(), s = r(), c = r(), v = r(), m = r(), j = r(), z = r(), re = r(), V = r();
      ne(d, l[1], l[0]), ne(V, h[1], h[0]), J(d, d, V), ae(s, l[0], l[1]), ae(V, h[0], h[1]), J(s, s, V), J(c, l[3], h[3]), J(c, c, g), J(v, l[2], h[2]), ae(v, v, v), ne(m, s, d), ne(j, v, c), ae(z, v, c), ae(re, s, d), J(l[0], m, j), J(l[1], re, z), J(l[2], z, j), J(l[3], m, re);
    }
    function Nt(l, h, d) {
      var s;
      for (s = 0; s < 4; s++)
        ee(l[s], h[s], d);
    }
    function vt(l, h) {
      var d = r(), s = r(), c = r();
      _e(c, h[2]), J(d, h[0], c), J(s, h[1], c), x(l, s), l[31] ^= H(d) << 7;
    }
    function kt(l, h, d) {
      var s, c;
      for (W(l[0], a), W(l[1], u), W(l[2], u), W(l[3], a), c = 255; c >= 0; --c)
        s = d[c / 8 | 0] >> (c & 7) & 1, Nt(l, h, s), rt(h, l), rt(l, l), Nt(l, h, s);
    }
    function _t(l, h) {
      var d = [r(), r(), r(), r()];
      W(d[0], y), W(d[1], A), W(d[2], u), J(d[3], y, A), kt(l, d, h);
    }
    function Tt(l, h, d) {
      var s = new Uint8Array(64), c = [r(), r(), r(), r()], v;
      for (d || n(h, 32), Ke(s, h, 32), s[0] &= 248, s[31] &= 127, s[31] |= 64, _t(c, s), vt(l, c), v = 0; v < 32; v++)
        h[v + 32] = l[v];
      return 0;
    }
    var Zt = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function gt(l, h) {
      var d, s, c, v;
      for (s = 63; s >= 32; --s) {
        for (d = 0, c = s - 32, v = s - 12; c < v; ++c)
          h[c] += d - 16 * h[s] * Zt[c - (s - 32)], d = Math.floor((h[c] + 128) / 256), h[c] -= d * 256;
        h[c] += d, h[s] = 0;
      }
      for (d = 0, c = 0; c < 32; c++)
        h[c] += d - (h[31] >> 4) * Zt[c], d = h[c] >> 8, h[c] &= 255;
      for (c = 0; c < 32; c++)
        h[c] -= d * Zt[c];
      for (s = 0; s < 32; s++)
        h[s + 1] += h[s] >> 8, l[s] = h[s] & 255;
    }
    function Ft(l) {
      var h = new Float64Array(64), d;
      for (d = 0; d < 64; d++)
        h[d] = l[d];
      for (d = 0; d < 64; d++)
        l[d] = 0;
      gt(l, h);
    }
    function xt(l, h, d, s) {
      var c = new Uint8Array(64), v = new Uint8Array(64), m = new Uint8Array(64), j, z, re = new Float64Array(64), V = [r(), r(), r(), r()];
      Ke(c, s, 32), c[0] &= 248, c[31] &= 127, c[31] |= 64;
      var fe = d + 64;
      for (j = 0; j < d; j++)
        l[64 + j] = h[j];
      for (j = 0; j < 32; j++)
        l[32 + j] = c[32 + j];
      for (Ke(m, l.subarray(32), d + 32), Ft(m), _t(V, m), vt(l, V), j = 32; j < 64; j++)
        l[j] = s[j];
      for (Ke(v, l, d + 64), Ft(v), j = 0; j < 64; j++)
        re[j] = 0;
      for (j = 0; j < 32; j++)
        re[j] = m[j];
      for (j = 0; j < 32; j++)
        for (z = 0; z < 32; z++)
          re[j + z] += v[j] * c[z];
      return gt(l.subarray(32), re), fe;
    }
    function $t(l, h) {
      var d = r(), s = r(), c = r(), v = r(), m = r(), j = r(), z = r();
      return W(l[2], u), oe(l[1], h), ce(c, l[1]), J(v, c, p), ne(c, c, l[2]), ae(v, l[2], v), ce(m, v), ce(j, m), J(z, j, m), J(d, z, c), J(d, d, v), Ne(d, d), J(d, d, c), J(d, d, v), J(d, d, v), J(l[0], d, v), ce(s, l[0]), J(s, s, v), F(s, c) && J(l[0], l[0], S), ce(s, l[0]), J(s, s, v), F(s, c) ? -1 : (H(l[0]) === h[31] >> 7 && ne(l[0], a, l[0]), J(l[3], l[0], l[1]), 0);
    }
    function zt(l, h, d, s) {
      var c, v = new Uint8Array(32), m = new Uint8Array(64), j = [r(), r(), r(), r()], z = [r(), r(), r(), r()];
      if (d < 64 || $t(z, s))
        return -1;
      for (c = 0; c < d; c++)
        l[c] = h[c];
      for (c = 0; c < 32; c++)
        l[c + 32] = s[c];
      if (Ke(m, l, d), Ft(m), kt(j, z, m), _t(z, h.subarray(32)), rt(j, z), vt(v, j), d -= 64, Y(h, 0, v, 0)) {
        for (c = 0; c < d; c++)
          l[c] = 0;
        return -1;
      }
      for (c = 0; c < d; c++)
        l[c] = h[c + 64];
      return d;
    }
    var Xt = 32, or = 24, Jt = 32, dr = 16, Or = 32, Fr = 32, Dr = 32, sr = 32, zr = 32, ar = or, sn = Jt, an = dr, Qt = 64, cr = 32, ur = 64, cn = 32, Qr = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: k,
      crypto_stream_xor: B,
      crypto_stream: G,
      crypto_stream_salsa20_xor: R,
      crypto_stream_salsa20: Q,
      crypto_onetimeauth: T,
      crypto_onetimeauth_verify: C,
      crypto_verify_16: L,
      crypto_verify_32: Y,
      crypto_secretbox: K,
      crypto_secretbox_open: $,
      crypto_scalarmult: Ee,
      crypto_scalarmult_base: qe,
      crypto_box_beforenm: et,
      crypto_box_afternm: se,
      crypto_box: Oe,
      crypto_box_open: We,
      crypto_box_keypair: $e,
      crypto_hash: Ke,
      crypto_sign: xt,
      crypto_sign_keypair: Tt,
      crypto_sign_open: zt,
      crypto_secretbox_KEYBYTES: Xt,
      crypto_secretbox_NONCEBYTES: or,
      crypto_secretbox_ZEROBYTES: Jt,
      crypto_secretbox_BOXZEROBYTES: dr,
      crypto_scalarmult_BYTES: Or,
      crypto_scalarmult_SCALARBYTES: Fr,
      crypto_box_PUBLICKEYBYTES: Dr,
      crypto_box_SECRETKEYBYTES: sr,
      crypto_box_BEFORENMBYTES: zr,
      crypto_box_NONCEBYTES: ar,
      crypto_box_ZEROBYTES: sn,
      crypto_box_BOXZEROBYTES: an,
      crypto_sign_BYTES: Qt,
      crypto_sign_PUBLICKEYBYTES: cr,
      crypto_sign_SECRETKEYBYTES: ur,
      crypto_sign_SEEDBYTES: cn,
      crypto_hash_BYTES: Qr,
      gf: r,
      D: p,
      L: Zt,
      pack25519: x,
      unpack25519: oe,
      M: J,
      A: ae,
      S: ce,
      Z: ne,
      pow2523: Ne,
      add: rt,
      set25519: W,
      modL: gt,
      scalarmult: kt,
      scalarbase: _t
    };
    function un(l, h) {
      if (l.length !== Xt)
        throw new Error("bad key size");
      if (h.length !== or)
        throw new Error("bad nonce size");
    }
    function Oi(l, h) {
      if (l.length !== Dr)
        throw new Error("bad public key size");
      if (h.length !== sr)
        throw new Error("bad secret key size");
    }
    function It() {
      for (var l = 0; l < arguments.length; l++)
        if (!(arguments[l] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function ln(l) {
      for (var h = 0; h < l.length; h++)
        l[h] = 0;
    }
    t.randomBytes = function(l) {
      var h = new Uint8Array(l);
      return n(h, l), h;
    }, t.secretbox = function(l, h, d) {
      It(l, h, d), un(d, h);
      for (var s = new Uint8Array(Jt + l.length), c = new Uint8Array(s.length), v = 0; v < l.length; v++)
        s[v + Jt] = l[v];
      return K(c, s, s.length, h, d), c.subarray(dr);
    }, t.secretbox.open = function(l, h, d) {
      It(l, h, d), un(d, h);
      for (var s = new Uint8Array(dr + l.length), c = new Uint8Array(s.length), v = 0; v < l.length; v++)
        s[v + dr] = l[v];
      return s.length < 32 || $(c, s, s.length, h, d) !== 0 ? null : c.subarray(Jt);
    }, t.secretbox.keyLength = Xt, t.secretbox.nonceLength = or, t.secretbox.overheadLength = dr, t.scalarMult = function(l, h) {
      if (It(l, h), l.length !== Fr)
        throw new Error("bad n size");
      if (h.length !== Or)
        throw new Error("bad p size");
      var d = new Uint8Array(Or);
      return Ee(d, l, h), d;
    }, t.scalarMult.base = function(l) {
      if (It(l), l.length !== Fr)
        throw new Error("bad n size");
      var h = new Uint8Array(Or);
      return qe(h, l), h;
    }, t.scalarMult.scalarLength = Fr, t.scalarMult.groupElementLength = Or, t.box = function(l, h, d, s) {
      var c = t.box.before(d, s);
      return t.secretbox(l, h, c);
    }, t.box.before = function(l, h) {
      It(l, h), Oi(l, h);
      var d = new Uint8Array(zr);
      return et(d, l, h), d;
    }, t.box.after = t.secretbox, t.box.open = function(l, h, d, s) {
      var c = t.box.before(d, s);
      return t.secretbox.open(l, h, c);
    }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
      var l = new Uint8Array(Dr), h = new Uint8Array(sr);
      return $e(l, h), { publicKey: l, secretKey: h };
    }, t.box.keyPair.fromSecretKey = function(l) {
      if (It(l), l.length !== sr)
        throw new Error("bad secret key size");
      var h = new Uint8Array(Dr);
      return qe(h, l), { publicKey: h, secretKey: new Uint8Array(l) };
    }, t.box.publicKeyLength = Dr, t.box.secretKeyLength = sr, t.box.sharedKeyLength = zr, t.box.nonceLength = ar, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(l, h) {
      if (It(l, h), h.length !== ur)
        throw new Error("bad secret key size");
      var d = new Uint8Array(Qt + l.length);
      return xt(d, l, l.length, h), d;
    }, t.sign.open = function(l, h) {
      if (It(l, h), h.length !== cr)
        throw new Error("bad public key size");
      var d = new Uint8Array(l.length), s = zt(d, l, l.length, h);
      if (s < 0)
        return null;
      for (var c = new Uint8Array(s), v = 0; v < c.length; v++)
        c[v] = d[v];
      return c;
    }, t.sign.detached = function(l, h) {
      for (var d = t.sign(l, h), s = new Uint8Array(Qt), c = 0; c < s.length; c++)
        s[c] = d[c];
      return s;
    }, t.sign.detached.verify = function(l, h, d) {
      if (It(l, h, d), h.length !== Qt)
        throw new Error("bad signature size");
      if (d.length !== cr)
        throw new Error("bad public key size");
      var s = new Uint8Array(Qt + l.length), c = new Uint8Array(Qt + l.length), v;
      for (v = 0; v < Qt; v++)
        s[v] = h[v];
      for (v = 0; v < l.length; v++)
        s[v + Qt] = l[v];
      return zt(c, s, s.length, d) >= 0;
    }, t.sign.keyPair = function() {
      var l = new Uint8Array(cr), h = new Uint8Array(ur);
      return Tt(l, h), { publicKey: l, secretKey: h };
    }, t.sign.keyPair.fromSecretKey = function(l) {
      if (It(l), l.length !== ur)
        throw new Error("bad secret key size");
      for (var h = new Uint8Array(cr), d = 0; d < h.length; d++)
        h[d] = l[32 + d];
      return { publicKey: h, secretKey: new Uint8Array(l) };
    }, t.sign.keyPair.fromSeed = function(l) {
      if (It(l), l.length !== cn)
        throw new Error("bad seed size");
      for (var h = new Uint8Array(cr), d = new Uint8Array(ur), s = 0; s < 32; s++)
        d[s] = l[s];
      return Tt(h, d, !0), { publicKey: h, secretKey: d };
    }, t.sign.publicKeyLength = cr, t.sign.secretKeyLength = ur, t.sign.seedLength = cn, t.sign.signatureLength = Qt, t.hash = function(l) {
      It(l);
      var h = new Uint8Array(Qr);
      return Ke(h, l, l.length), h;
    }, t.hash.hashLength = Qr, t.verify = function(l, h) {
      return It(l, h), l.length === 0 || h.length === 0 || l.length !== h.length ? !1 : D(l, 0, h, 0, l.length) === 0;
    }, t.setPRNG = function(l) {
      n = l;
    }, function() {
      var l = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (l && l.getRandomValues) {
        var h = 65536;
        t.setPRNG(function(d, s) {
          var c, v = new Uint8Array(s);
          for (c = 0; c < s; c += h)
            l.getRandomValues(v.subarray(c, c + Math.min(s - c, h)));
          for (c = 0; c < s; c++)
            d[c] = v[c];
          ln(v);
        });
      } else
        typeof q0 < "u" && (l = V0, l && l.randomBytes && t.setPRNG(function(d, s) {
          var c, v = l.randomBytes(s);
          for (c = 0; c < s; c++)
            d[c] = v[c];
          ln(v);
        }));
    }();
  })(e.exports ? e.exports : self.nacl = self.nacl || {});
})(Zc);
var G0 = Object.create, wi = Object.defineProperty, $0 = Object.getOwnPropertyDescriptor, X0 = Object.getOwnPropertyNames, J0 = Object.getPrototypeOf, ep = Object.prototype.hasOwnProperty, tp = (e, t) => {
  for (var r in t)
    wi(e, r, { get: t[r], enumerable: !0 });
}, Kc = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of X0(t))
      !ep.call(e, i) && i !== r && wi(e, i, { get: () => t[i], enumerable: !(n = $0(t, i)) || n.enumerable });
  return e;
}, rp = (e, t, r) => (r = e != null ? G0(J0(e)) : {}, Kc(
  t || !e || !e.__esModule ? wi(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), np = (e) => Kc(wi({}, "__esModule", { value: !0 }), e), Vc = {};
tp(Vc, {
  Ed25519PublicKey: () => Gc
});
var ip = np(Vc), op = qt, Ps = Dn, ks = rn, sp = rp(Zc.exports);
const fo = 32;
class Gc extends Ps.PublicKey {
  constructor(t) {
    if (super(), typeof t == "string" ? this.data = (0, op.fromB64)(t) : t instanceof Uint8Array ? this.data = t : this.data = Uint8Array.from(t), this.data.length !== fo)
      throw new Error(
        `Invalid public key input. Expected ${fo} bytes, got ${this.data.length}`
      );
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return ks.SIGNATURE_SCHEME_TO_FLAG.ED25519;
  }
  async verify(t, r) {
    let n;
    if (typeof r == "string") {
      const i = (0, ks.parseSerializedSignature)(r);
      if (i.signatureScheme !== "ED25519")
        throw new Error("Invalid signature scheme");
      if (!(0, Ps.bytesEqual)(this.toRawBytes(), i.publicKey))
        throw new Error("Signature does not match public key");
      n = i.signature;
    } else
      n = r;
    return sp.default.sign.detached.verify(t, n, this.toRawBytes());
  }
}
Gc.SIZE = fo;
var $c = {}, Pe = {}, Ce = {};
Object.defineProperty(Ce, "__esModule", { value: !0 });
Ce.validateObject = Ce.createHmacDrbg = Ce.bitMask = Ce.bitSet = Ce.bitGet = Ce.bitLen = Ce.utf8ToBytes = Ce.equalBytes = Ce.concatBytes = Ce.ensureBytes = Ce.numberToVarBytesBE = Ce.numberToBytesLE = Ce.numberToBytesBE = Ce.bytesToNumberLE = Ce.bytesToNumberBE = Ce.hexToBytes = Ce.hexToNumber = Ce.numberToHexUnpadded = Ce.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Xc = BigInt(0), Ei = BigInt(1), ap = BigInt(2), Ai = (e) => e instanceof Uint8Array, cp = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Go(e) {
  if (!Ai(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += cp[e[r]];
  return t;
}
Ce.bytesToHex = Go;
function Jc(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
Ce.numberToHexUnpadded = Jc;
function $o(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
Ce.hexToNumber = $o;
function Mi(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(t / 2);
  for (let n = 0; n < r.length; n++) {
    const i = n * 2, o = e.slice(i, i + 2), a = Number.parseInt(o, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("Invalid byte sequence");
    r[n] = a;
  }
  return r;
}
Ce.hexToBytes = Mi;
function up(e) {
  return $o(Go(e));
}
Ce.bytesToNumberBE = up;
function lp(e) {
  if (!Ai(e))
    throw new Error("Uint8Array expected");
  return $o(Go(Uint8Array.from(e).reverse()));
}
Ce.bytesToNumberLE = lp;
function eu(e, t) {
  return Mi(e.toString(16).padStart(t * 2, "0"));
}
Ce.numberToBytesBE = eu;
function fp(e, t) {
  return eu(e, t).reverse();
}
Ce.numberToBytesLE = fp;
function dp(e) {
  return Mi(Jc(e));
}
Ce.numberToVarBytesBE = dp;
function hp(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = Mi(t);
    } catch (o) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
  else if (Ai(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const i = n.length;
  if (typeof r == "number" && i !== r)
    throw new Error(`${e} expected ${r} bytes, got ${i}`);
  return n;
}
Ce.ensureBytes = hp;
function tu(...e) {
  const t = new Uint8Array(e.reduce((n, i) => n + i.length, 0));
  let r = 0;
  return e.forEach((n) => {
    if (!Ai(n))
      throw new Error("Uint8Array expected");
    t.set(n, r), r += n.length;
  }), t;
}
Ce.concatBytes = tu;
function pp(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
Ce.equalBytes = pp;
function gp(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
Ce.utf8ToBytes = gp;
function yp(e) {
  let t;
  for (t = 0; e > Xc; e >>= Ei, t += 1)
    ;
  return t;
}
Ce.bitLen = yp;
function bp(e, t) {
  return e >> BigInt(t) & Ei;
}
Ce.bitGet = bp;
const vp = (e, t, r) => e | (r ? Ei : Xc) << BigInt(t);
Ce.bitSet = vp;
const mp = (e) => (ap << BigInt(e - 1)) - Ei;
Ce.bitMask = mp;
const Yi = (e) => new Uint8Array(e), _s = (e) => Uint8Array.from(e);
function wp(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = Yi(e), i = Yi(e), o = 0;
  const a = () => {
    n.fill(1), i.fill(0), o = 0;
  }, u = (...g) => r(i, n, ...g), f = (g = Yi()) => {
    i = u(_s([0]), g), n = u(), g.length !== 0 && (i = u(_s([1]), g), n = u());
  }, p = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let g = 0;
    const y = [];
    for (; g < t; ) {
      n = u();
      const A = n.slice();
      y.push(A), g += n.length;
    }
    return tu(...y);
  };
  return (g, y) => {
    a(), f(g);
    let A;
    for (; !(A = y(p())); )
      f();
    return a(), A;
  };
}
Ce.createHmacDrbg = wp;
const Ep = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Ap(e, t, r = {}) {
  const n = (i, o, a) => {
    const u = Ep[o];
    if (typeof u != "function")
      throw new Error(`Invalid validator "${o}", expected function`);
    const f = e[i];
    if (!(a && f === void 0) && !u(f, e))
      throw new Error(`Invalid param ${String(i)}=${f} (${typeof f}), expected ${o}`);
  };
  for (const [i, o] of Object.entries(t))
    n(i, o, !1);
  for (const [i, o] of Object.entries(r))
    n(i, o, !0);
  return e;
}
Ce.validateObject = Ap;
Object.defineProperty(Pe, "__esModule", { value: !0 });
Pe.hashToPrivateScalar = Pe.FpSqrtEven = Pe.FpSqrtOdd = Pe.Field = Pe.nLength = Pe.FpIsSquare = Pe.FpDiv = Pe.FpInvertBatch = Pe.FpPow = Pe.validateField = Pe.isNegativeLE = Pe.FpSqrt = Pe.tonelliShanks = Pe.invert = Pe.pow2 = Pe.pow = Pe.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const lr = Ce, dt = BigInt(0), tt = BigInt(1), Sr = BigInt(2), Mp = BigInt(3), ho = BigInt(4), Fs = BigInt(5), zs = BigInt(8);
BigInt(9);
BigInt(16);
function Yt(e, t) {
  const r = e % t;
  return r >= dt ? r : t + r;
}
Pe.mod = Yt;
function ru(e, t, r) {
  if (r <= dt || t < dt)
    throw new Error("Expected power/modulo > 0");
  if (r === tt)
    return dt;
  let n = tt;
  for (; t > dt; )
    t & tt && (n = n * e % r), e = e * e % r, t >>= tt;
  return n;
}
Pe.pow = ru;
function Sp(e, t, r) {
  let n = e;
  for (; t-- > dt; )
    n *= n, n %= r;
  return n;
}
Pe.pow2 = Sp;
function oi(e, t) {
  if (e === dt || t <= dt)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Yt(e, t), n = t, i = dt, o = tt;
  for (; r !== dt; ) {
    const a = n / r, u = n % r, f = i - o * a;
    n = r, r = u, i = o, o = f;
  }
  if (n !== tt)
    throw new Error("invert: does not exist");
  return Yt(i, t);
}
Pe.invert = oi;
function nu(e) {
  const t = (e - tt) / Sr;
  let r, n, i;
  for (r = e - tt, n = 0; r % Sr === dt; r /= Sr, n++)
    ;
  for (i = Sr; i < e && ru(i, t, e) !== e - tt; i++)
    ;
  if (n === 1) {
    const a = (e + tt) / ho;
    return function(u, f) {
      const p = u.pow(f, a);
      if (!u.eql(u.sqr(p), f))
        throw new Error("Cannot find square root");
      return p;
    };
  }
  const o = (r + tt) / Sr;
  return function(a, u) {
    if (a.pow(u, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let f = n, p = a.pow(a.mul(a.ONE, i), r), g = a.pow(u, o), y = a.pow(u, r);
    for (; !a.eql(y, a.ONE); ) {
      if (a.eql(y, a.ZERO))
        return a.ZERO;
      let A = 1;
      for (let I = a.sqr(y); A < f && !a.eql(I, a.ONE); A++)
        I = a.sqr(I);
      const S = a.pow(p, tt << BigInt(f - A - 1));
      p = a.sqr(S), g = a.mul(g, S), y = a.mul(y, p), f = A;
    }
    return g;
  };
}
Pe.tonelliShanks = nu;
function iu(e) {
  if (e % ho === Mp) {
    const t = (e + tt) / ho;
    return function(r, n) {
      const i = r.pow(n, t);
      if (!r.eql(r.sqr(i), n))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (e % zs === Fs) {
    const t = (e - Fs) / zs;
    return function(r, n) {
      const i = r.mul(n, Sr), o = r.pow(i, t), a = r.mul(n, o), u = r.mul(r.mul(a, Sr), o), f = r.mul(a, r.sub(u, r.ONE));
      if (!r.eql(r.sqr(f), n))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  return nu(e);
}
Pe.FpSqrt = iu;
const Np = (e, t) => (Yt(e, t) & tt) === tt;
Pe.isNegativeLE = Np;
const Tp = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Ip(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = Tp.reduce((n, i) => (n[i] = "function", n), t);
  return (0, lr.validateObject)(e, r);
}
Pe.validateField = Ip;
function ou(e, t, r) {
  if (r < dt)
    throw new Error("Expected power > 0");
  if (r === dt)
    return e.ONE;
  if (r === tt)
    return t;
  let n = e.ONE, i = t;
  for (; r > dt; )
    r & tt && (n = e.mul(n, i)), i = e.sqr(i), r >>= tt;
  return n;
}
Pe.FpPow = ou;
function su(e, t) {
  const r = new Array(t.length), n = t.reduce((o, a, u) => e.is0(a) ? o : (r[u] = o, e.mul(o, a)), e.ONE), i = e.inv(n);
  return t.reduceRight((o, a, u) => e.is0(a) ? o : (r[u] = e.mul(o, r[u]), e.mul(o, a)), i), r;
}
Pe.FpInvertBatch = su;
function Op(e, t, r) {
  return e.mul(t, typeof r == "bigint" ? oi(r, e.ORDER) : e.inv(r));
}
Pe.FpDiv = Op;
function Dp(e) {
  const t = (e.ORDER - tt) / Sr;
  return (r) => {
    const n = e.pow(r, t);
    return e.eql(n, e.ZERO) || e.eql(n, e.ONE);
  };
}
Pe.FpIsSquare = Dp;
function Xo(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
Pe.nLength = Xo;
function Cp(e, t, r = !1, n = {}) {
  if (e <= dt)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: o } = Xo(e, t);
  if (o > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const a = iu(e), u = Object.freeze({
    ORDER: e,
    BITS: i,
    BYTES: o,
    MASK: (0, lr.bitMask)(i),
    ZERO: dt,
    ONE: tt,
    create: (f) => Yt(f, e),
    isValid: (f) => {
      if (typeof f != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);
      return dt <= f && f < e;
    },
    is0: (f) => f === dt,
    isOdd: (f) => (f & tt) === tt,
    neg: (f) => Yt(-f, e),
    eql: (f, p) => f === p,
    sqr: (f) => Yt(f * f, e),
    add: (f, p) => Yt(f + p, e),
    sub: (f, p) => Yt(f - p, e),
    mul: (f, p) => Yt(f * p, e),
    pow: (f, p) => ou(u, f, p),
    div: (f, p) => Yt(f * oi(p, e), e),
    sqrN: (f) => f * f,
    addN: (f, p) => f + p,
    subN: (f, p) => f - p,
    mulN: (f, p) => f * p,
    inv: (f) => oi(f, e),
    sqrt: n.sqrt || ((f) => a(u, f)),
    invertBatch: (f) => su(u, f),
    cmov: (f, p, g) => g ? p : f,
    toBytes: (f) => r ? (0, lr.numberToBytesLE)(f, o) : (0, lr.numberToBytesBE)(f, o),
    fromBytes: (f) => {
      if (f.length !== o)
        throw new Error(`Fp.fromBytes: expected ${o}, got ${f.length}`);
      return r ? (0, lr.bytesToNumberLE)(f) : (0, lr.bytesToNumberBE)(f);
    }
  });
  return Object.freeze(u);
}
Pe.Field = Cp;
function jp(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? r : e.neg(r);
}
Pe.FpSqrtOdd = jp;
function xp(e, t) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const r = e.sqrt(t);
  return e.isOdd(r) ? e.neg(r) : r;
}
Pe.FpSqrtEven = xp;
function Lp(e, t, r = !1) {
  e = (0, lr.ensureBytes)("privateHash", e);
  const n = e.length, i = Xo(t).nByteLength + 8;
  if (i < 24 || n < i || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);
  const o = r ? (0, lr.bytesToNumberLE)(e) : (0, lr.bytesToNumberBE)(e);
  return Yt(o, t - tt) + tt;
}
Pe.hashToPrivateScalar = Lp;
var Si = {}, Jr = {};
Object.defineProperty(Jr, "__esModule", { value: !0 });
Jr.validateBasic = Jr.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Qs = Pe, Bp = Ce, Rp = BigInt(0), Hi = BigInt(1);
function Up(e, t) {
  const r = (i, o) => {
    const a = o.negate();
    return i ? a : o;
  }, n = (i) => {
    const o = Math.ceil(t / i) + 1, a = 2 ** (i - 1);
    return { windows: o, windowSize: a };
  };
  return {
    constTimeNegate: r,
    unsafeLadder(i, o) {
      let a = e.ZERO, u = i;
      for (; o > Rp; )
        o & Hi && (a = a.add(u)), u = u.double(), o >>= Hi;
      return a;
    },
    precomputeWindow(i, o) {
      const { windows: a, windowSize: u } = n(o), f = [];
      let p = i, g = p;
      for (let y = 0; y < a; y++) {
        g = p, f.push(g);
        for (let A = 1; A < u; A++)
          g = g.add(p), f.push(g);
        p = g.double();
      }
      return f;
    },
    wNAF(i, o, a) {
      const { windows: u, windowSize: f } = n(i);
      let p = e.ZERO, g = e.BASE;
      const y = BigInt(2 ** i - 1), A = 2 ** i, S = BigInt(i);
      for (let I = 0; I < u; I++) {
        const D = I * f;
        let L = Number(a & y);
        a >>= S, L > f && (L -= A, a += Hi);
        const Y = D, M = D + Math.abs(L) - 1, N = I % 2 !== 0, b = L < 0;
        L === 0 ? g = g.add(r(N, o[Y])) : p = p.add(r(b, o[M]));
      }
      return { p, f: g };
    },
    wNAFCached(i, o, a, u) {
      const f = i._WINDOW_SIZE || 1;
      let p = o.get(i);
      return p || (p = this.precomputeWindow(i, f), f !== 1 && o.set(i, u(p))), this.wNAF(f, p, a);
    }
  };
}
Jr.wNAF = Up;
function Pp(e) {
  return (0, Qs.validateField)(e.Fp), (0, Bp.validateObject)(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, Qs.nLength)(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
Jr.validateBasic = Pp;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.mapToCurveSimpleSWU = e.SWUFpSqrtRatio = e.weierstrass = e.weierstrassPoints = e.DER = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = Pe, r = Ce, n = Ce, i = Jr;
  function o(M) {
    const N = (0, i.validateBasic)(M);
    r.validateObject(N, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: b, Fp: k, a: O } = N;
    if (b) {
      if (!k.eql(O, k.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof b != "object" || typeof b.beta != "bigint" || typeof b.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...N });
  }
  const { bytesToNumberBE: a, hexToBytes: u } = r;
  e.DER = {
    Err: class extends Error {
      constructor(M = "") {
        super(M);
      }
    },
    _parseInt(M) {
      const { Err: N } = e.DER;
      if (M.length < 2 || M[0] !== 2)
        throw new N("Invalid signature integer tag");
      const b = M[1], k = M.subarray(2, b + 2);
      if (!b || k.length !== b)
        throw new N("Invalid signature integer: wrong length");
      if (k[0] & 128)
        throw new N("Invalid signature integer: negative");
      if (k[0] === 0 && !(k[1] & 128))
        throw new N("Invalid signature integer: unnecessary leading zero");
      return { d: a(k), l: M.subarray(b + 2) };
    },
    toSig(M) {
      const { Err: N } = e.DER, b = typeof M == "string" ? u(M) : M;
      if (!(b instanceof Uint8Array))
        throw new Error("ui8a expected");
      let k = b.length;
      if (k < 2 || b[0] != 48)
        throw new N("Invalid signature tag");
      if (b[1] !== k - 2)
        throw new N("Invalid signature: incorrect length");
      const { d: O, l: R } = e.DER._parseInt(b.subarray(2)), { d: Q, l: G } = e.DER._parseInt(R);
      if (G.length)
        throw new N("Invalid signature: left bytes after parsing");
      return { r: O, s: Q };
    },
    hexFromSig(M) {
      const N = (E) => Number.parseInt(E[0], 16) & 8 ? "00" + E : E, b = (E) => {
        const T = E.toString(16);
        return T.length & 1 ? `0${T}` : T;
      }, k = N(b(M.s)), O = N(b(M.r)), R = k.length / 2, Q = O.length / 2, G = b(R), B = b(Q);
      return `30${b(Q + R + 4)}02${B}${O}02${G}${k}`;
    }
  };
  const f = BigInt(0), p = BigInt(1), g = BigInt(2), y = BigInt(3), A = BigInt(4);
  function S(M) {
    const N = o(M), { Fp: b } = N, k = N.toBytes || ((W, _, ee) => {
      const x = _.toAffine();
      return r.concatBytes(Uint8Array.from([4]), b.toBytes(x.x), b.toBytes(x.y));
    }), O = N.fromBytes || ((W) => {
      const _ = W.subarray(1), ee = b.fromBytes(_.subarray(0, b.BYTES)), x = b.fromBytes(_.subarray(b.BYTES, 2 * b.BYTES));
      return { x: ee, y: x };
    });
    function R(W) {
      const { a: _, b: ee } = N, x = b.sqr(W), F = b.mul(x, W);
      return b.add(b.add(F, b.mul(W, _)), ee);
    }
    if (!b.eql(b.sqr(N.Gy), R(N.Gx)))
      throw new Error("bad generator point: equation left != right");
    function Q(W) {
      return typeof W == "bigint" && f < W && W < N.n;
    }
    function G(W) {
      if (!Q(W))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function B(W) {
      const { allowedPrivateKeyLengths: _, nByteLength: ee, wrapPrivateKey: x, n: F } = N;
      if (_ && typeof W != "bigint") {
        if (W instanceof Uint8Array && (W = r.bytesToHex(W)), typeof W != "string" || !_.includes(W.length))
          throw new Error("Invalid key");
        W = W.padStart(ee * 2, "0");
      }
      let H;
      try {
        H = typeof W == "bigint" ? W : r.bytesToNumberBE((0, n.ensureBytes)("private key", W, ee));
      } catch {
        throw new Error(`private key must be ${ee} bytes, hex or bigint, not ${typeof W}`);
      }
      return x && (H = t.mod(H, F)), G(H), H;
    }
    const E = /* @__PURE__ */ new Map();
    function T(W) {
      if (!(W instanceof C))
        throw new Error("ProjectivePoint expected");
    }
    class C {
      constructor(_, ee, x) {
        if (this.px = _, this.py = ee, this.pz = x, _ == null || !b.isValid(_))
          throw new Error("x required");
        if (ee == null || !b.isValid(ee))
          throw new Error("y required");
        if (x == null || !b.isValid(x))
          throw new Error("z required");
      }
      static fromAffine(_) {
        const { x: ee, y: x } = _ || {};
        if (!_ || !b.isValid(ee) || !b.isValid(x))
          throw new Error("invalid affine point");
        if (_ instanceof C)
          throw new Error("projective point not allowed");
        const F = (H) => b.eql(H, b.ZERO);
        return F(ee) && F(x) ? C.ZERO : new C(ee, x, b.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(_) {
        const ee = b.invertBatch(_.map((x) => x.pz));
        return _.map((x, F) => x.toAffine(ee[F])).map(C.fromAffine);
      }
      static fromHex(_) {
        const ee = C.fromAffine(O((0, n.ensureBytes)("pointHex", _)));
        return ee.assertValidity(), ee;
      }
      static fromPrivateKey(_) {
        return C.BASE.multiply(B(_));
      }
      _setWindowSize(_) {
        this._WINDOW_SIZE = _, E.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (N.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: _, y: ee } = this.toAffine();
        if (!b.isValid(_) || !b.isValid(ee))
          throw new Error("bad point: x or y not FE");
        const x = b.sqr(ee), F = R(_);
        if (!b.eql(x, F))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: _ } = this.toAffine();
        if (b.isOdd)
          return !b.isOdd(_);
        throw new Error("Field doesn't support isOdd");
      }
      equals(_) {
        T(_);
        const { px: ee, py: x, pz: F } = this, { px: H, py: oe, pz: ae } = _, ne = b.eql(b.mul(ee, ae), b.mul(H, F)), J = b.eql(b.mul(x, ae), b.mul(oe, F));
        return ne && J;
      }
      negate() {
        return new C(this.px, b.neg(this.py), this.pz);
      }
      double() {
        const { a: _, b: ee } = N, x = b.mul(ee, y), { px: F, py: H, pz: oe } = this;
        let ae = b.ZERO, ne = b.ZERO, J = b.ZERO, ce = b.mul(F, F), _e = b.mul(H, H), Ne = b.mul(oe, oe), Ee = b.mul(F, H);
        return Ee = b.add(Ee, Ee), J = b.mul(F, oe), J = b.add(J, J), ae = b.mul(_, J), ne = b.mul(x, Ne), ne = b.add(ae, ne), ae = b.sub(_e, ne), ne = b.add(_e, ne), ne = b.mul(ae, ne), ae = b.mul(Ee, ae), J = b.mul(x, J), Ne = b.mul(_, Ne), Ee = b.sub(ce, Ne), Ee = b.mul(_, Ee), Ee = b.add(Ee, J), J = b.add(ce, ce), ce = b.add(J, ce), ce = b.add(ce, Ne), ce = b.mul(ce, Ee), ne = b.add(ne, ce), Ne = b.mul(H, oe), Ne = b.add(Ne, Ne), ce = b.mul(Ne, Ee), ae = b.sub(ae, ce), J = b.mul(Ne, _e), J = b.add(J, J), J = b.add(J, J), new C(ae, ne, J);
      }
      add(_) {
        T(_);
        const { px: ee, py: x, pz: F } = this, { px: H, py: oe, pz: ae } = _;
        let ne = b.ZERO, J = b.ZERO, ce = b.ZERO;
        const _e = N.a, Ne = b.mul(N.b, y);
        let Ee = b.mul(ee, H), qe = b.mul(x, oe), $e = b.mul(F, ae), et = b.add(ee, x), se = b.add(H, oe);
        et = b.mul(et, se), se = b.add(Ee, qe), et = b.sub(et, se), se = b.add(ee, F);
        let he = b.add(H, ae);
        return se = b.mul(se, he), he = b.add(Ee, $e), se = b.sub(se, he), he = b.add(x, F), ne = b.add(oe, ae), he = b.mul(he, ne), ne = b.add(qe, $e), he = b.sub(he, ne), ce = b.mul(_e, se), ne = b.mul(Ne, $e), ce = b.add(ne, ce), ne = b.sub(qe, ce), ce = b.add(qe, ce), J = b.mul(ne, ce), qe = b.add(Ee, Ee), qe = b.add(qe, Ee), $e = b.mul(_e, $e), se = b.mul(Ne, se), qe = b.add(qe, $e), $e = b.sub(Ee, $e), $e = b.mul(_e, $e), se = b.add(se, $e), Ee = b.mul(qe, se), J = b.add(J, Ee), Ee = b.mul(he, se), ne = b.mul(et, ne), ne = b.sub(ne, Ee), Ee = b.mul(et, qe), ce = b.mul(he, ce), ce = b.add(ce, Ee), new C(ne, J, ce);
      }
      subtract(_) {
        return this.add(_.negate());
      }
      is0() {
        return this.equals(C.ZERO);
      }
      wNAF(_) {
        return $.wNAFCached(this, E, _, (ee) => {
          const x = b.invertBatch(ee.map((F) => F.pz));
          return ee.map((F, H) => F.toAffine(x[H])).map(C.fromAffine);
        });
      }
      multiplyUnsafe(_) {
        const ee = C.ZERO;
        if (_ === f)
          return ee;
        if (G(_), _ === p)
          return this;
        const { endo: x } = N;
        if (!x)
          return $.unsafeLadder(this, _);
        let { k1neg: F, k1: H, k2neg: oe, k2: ae } = x.splitScalar(_), ne = ee, J = ee, ce = this;
        for (; H > f || ae > f; )
          H & p && (ne = ne.add(ce)), ae & p && (J = J.add(ce)), ce = ce.double(), H >>= p, ae >>= p;
        return F && (ne = ne.negate()), oe && (J = J.negate()), J = new C(b.mul(J.px, x.beta), J.py, J.pz), ne.add(J);
      }
      multiply(_) {
        G(_);
        let ee = _, x, F;
        const { endo: H } = N;
        if (H) {
          const { k1neg: oe, k1: ae, k2neg: ne, k2: J } = H.splitScalar(ee);
          let { p: ce, f: _e } = this.wNAF(ae), { p: Ne, f: Ee } = this.wNAF(J);
          ce = $.constTimeNegate(oe, ce), Ne = $.constTimeNegate(ne, Ne), Ne = new C(b.mul(Ne.px, H.beta), Ne.py, Ne.pz), x = ce.add(Ne), F = _e.add(Ee);
        } else {
          const { p: oe, f: ae } = this.wNAF(ee);
          x = oe, F = ae;
        }
        return C.normalizeZ([x, F])[0];
      }
      multiplyAndAddUnsafe(_, ee, x) {
        const F = C.BASE, H = (ae, ne) => ne === f || ne === p || !ae.equals(F) ? ae.multiplyUnsafe(ne) : ae.multiply(ne), oe = H(this, ee).add(H(_, x));
        return oe.is0() ? void 0 : oe;
      }
      toAffine(_) {
        const { px: ee, py: x, pz: F } = this, H = this.is0();
        _ == null && (_ = H ? b.ONE : b.inv(F));
        const oe = b.mul(ee, _), ae = b.mul(x, _), ne = b.mul(F, _);
        if (H)
          return { x: b.ZERO, y: b.ZERO };
        if (!b.eql(ne, b.ONE))
          throw new Error("invZ was invalid");
        return { x: oe, y: ae };
      }
      isTorsionFree() {
        const { h: _, isTorsionFree: ee } = N;
        if (_ === p)
          return !0;
        if (ee)
          return ee(C, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: _, clearCofactor: ee } = N;
        return _ === p ? this : ee ? ee(C, this) : this.multiplyUnsafe(N.h);
      }
      toRawBytes(_ = !0) {
        return this.assertValidity(), k(C, this, _);
      }
      toHex(_ = !0) {
        return r.bytesToHex(this.toRawBytes(_));
      }
    }
    C.BASE = new C(N.Gx, N.Gy, b.ONE), C.ZERO = new C(b.ZERO, b.ONE, b.ZERO);
    const K = N.nBitLength, $ = (0, i.wNAF)(C, N.endo ? Math.ceil(K / 2) : K);
    return {
      CURVE: N,
      ProjectivePoint: C,
      normPrivateKeyToScalar: B,
      weierstrassEquation: R,
      isWithinCurveOrder: Q
    };
  }
  e.weierstrassPoints = S;
  function I(M) {
    const N = (0, i.validateBasic)(M);
    return r.validateObject(N, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...N });
  }
  function D(M) {
    const N = I(M), { Fp: b, n: k } = N, O = b.BYTES + 1, R = 2 * b.BYTES + 1;
    function Q(se) {
      return f < se && se < b.ORDER;
    }
    function G(se) {
      return t.mod(se, k);
    }
    function B(se) {
      return t.invert(se, k);
    }
    const { ProjectivePoint: E, normPrivateKeyToScalar: T, weierstrassEquation: C, isWithinCurveOrder: K } = S({
      ...N,
      toBytes(se, he, Oe) {
        const We = he.toAffine(), Fe = b.toBytes(We.x), Ge = r.concatBytes;
        return Oe ? Ge(Uint8Array.from([he.hasEvenY() ? 2 : 3]), Fe) : Ge(Uint8Array.from([4]), Fe, b.toBytes(We.y));
      },
      fromBytes(se) {
        const he = se.length, Oe = se[0], We = se.subarray(1);
        if (he === O && (Oe === 2 || Oe === 3)) {
          const Fe = r.bytesToNumberBE(We);
          if (!Q(Fe))
            throw new Error("Point is not on curve");
          const Ge = C(Fe);
          let Ke = b.sqrt(Ge);
          const rt = (Ke & p) === p;
          return (Oe & 1) === 1 !== rt && (Ke = b.neg(Ke)), { x: Fe, y: Ke };
        } else if (he === R && Oe === 4) {
          const Fe = b.fromBytes(We.subarray(0, b.BYTES)), Ge = b.fromBytes(We.subarray(b.BYTES, 2 * b.BYTES));
          return { x: Fe, y: Ge };
        } else
          throw new Error(`Point of length ${he} was invalid. Expected ${O} compressed bytes or ${R} uncompressed bytes`);
      }
    }), $ = (se) => r.bytesToHex(r.numberToBytesBE(se, N.nByteLength));
    function W(se) {
      const he = k >> p;
      return se > he;
    }
    function _(se) {
      return W(se) ? G(-se) : se;
    }
    const ee = (se, he, Oe) => r.bytesToNumberBE(se.slice(he, Oe));
    class x {
      constructor(he, Oe, We) {
        this.r = he, this.s = Oe, this.recovery = We, this.assertValidity();
      }
      static fromCompact(he) {
        const Oe = N.nByteLength;
        return he = (0, n.ensureBytes)("compactSignature", he, Oe * 2), new x(ee(he, 0, Oe), ee(he, Oe, 2 * Oe));
      }
      static fromDER(he) {
        const { r: Oe, s: We } = e.DER.toSig((0, n.ensureBytes)("DER", he));
        return new x(Oe, We);
      }
      assertValidity() {
        if (!K(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!K(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(he) {
        return new x(this.r, this.s, he);
      }
      recoverPublicKey(he) {
        const { r: Oe, s: We, recovery: Fe } = this, Ge = J((0, n.ensureBytes)("msgHash", he));
        if (Fe == null || ![0, 1, 2, 3].includes(Fe))
          throw new Error("recovery id invalid");
        const Ke = Fe === 2 || Fe === 3 ? Oe + N.n : Oe;
        if (Ke >= b.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const rt = (Fe & 1) === 0 ? "02" : "03", Nt = E.fromHex(rt + $(Ke)), vt = B(Ke), kt = G(-Ge * vt), _t = G(We * vt), Tt = E.BASE.multiplyAndAddUnsafe(Nt, kt, _t);
        if (!Tt)
          throw new Error("point at infinify");
        return Tt.assertValidity(), Tt;
      }
      hasHighS() {
        return W(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new x(this.r, G(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return r.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return r.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return $(this.r) + $(this.s);
      }
    }
    const F = {
      isValidPrivateKey(se) {
        try {
          return T(se), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: T,
      randomPrivateKey: () => {
        const se = N.randomBytes(b.BYTES + 8), he = t.hashToPrivateScalar(se, k);
        return r.numberToBytesBE(he, N.nByteLength);
      },
      precompute(se = 8, he = E.BASE) {
        return he._setWindowSize(se), he.multiply(BigInt(3)), he;
      }
    };
    function H(se, he = !0) {
      return E.fromPrivateKey(se).toRawBytes(he);
    }
    function oe(se) {
      const he = se instanceof Uint8Array, Oe = typeof se == "string", We = (he || Oe) && se.length;
      return he ? We === O || We === R : Oe ? We === 2 * O || We === 2 * R : se instanceof E;
    }
    function ae(se, he, Oe = !0) {
      if (oe(se))
        throw new Error("first arg must be private key");
      if (!oe(he))
        throw new Error("second arg must be public key");
      return E.fromHex(he).multiply(T(se)).toRawBytes(Oe);
    }
    const ne = N.bits2int || function(se) {
      const he = r.bytesToNumberBE(se), Oe = se.length * 8 - N.nBitLength;
      return Oe > 0 ? he >> BigInt(Oe) : he;
    }, J = N.bits2int_modN || function(se) {
      return G(ne(se));
    }, ce = r.bitMask(N.nBitLength);
    function _e(se) {
      if (typeof se != "bigint")
        throw new Error("bigint expected");
      if (!(f <= se && se < ce))
        throw new Error(`bigint expected < 2^${N.nBitLength}`);
      return r.numberToBytesBE(se, N.nByteLength);
    }
    function Ne(se, he, Oe = Ee) {
      if (["recovered", "canonical"].some((gt) => gt in Oe))
        throw new Error("sign() legacy options not supported");
      const { hash: We, randomBytes: Fe } = N;
      let { lowS: Ge, prehash: Ke, extraEntropy: rt } = Oe;
      Ge == null && (Ge = !0), se = (0, n.ensureBytes)("msgHash", se), Ke && (se = (0, n.ensureBytes)("prehashed msgHash", We(se)));
      const Nt = J(se), vt = T(he), kt = [_e(vt), _e(Nt)];
      if (rt != null) {
        const gt = rt === !0 ? Fe(b.BYTES) : rt;
        kt.push((0, n.ensureBytes)("extraEntropy", gt, b.BYTES));
      }
      const _t = r.concatBytes(...kt), Tt = Nt;
      function Zt(gt) {
        const Ft = ne(gt);
        if (!K(Ft))
          return;
        const xt = B(Ft), $t = E.BASE.multiply(Ft).toAffine(), zt = G($t.x);
        if (zt === f)
          return;
        const Xt = G(xt * G(Tt + zt * vt));
        if (Xt === f)
          return;
        let or = ($t.x === zt ? 0 : 2) | Number($t.y & p), Jt = Xt;
        return Ge && W(Xt) && (Jt = _(Xt), or ^= 1), new x(zt, Jt, or);
      }
      return { seed: _t, k2sig: Zt };
    }
    const Ee = { lowS: N.lowS, prehash: !1 }, qe = { lowS: N.lowS, prehash: !1 };
    function $e(se, he, Oe = Ee) {
      const { seed: We, k2sig: Fe } = Ne(se, he, Oe), Ge = N;
      return r.createHmacDrbg(Ge.hash.outputLen, Ge.nByteLength, Ge.hmac)(We, Fe);
    }
    E.BASE._setWindowSize(8);
    function et(se, he, Oe, We = qe) {
      const Fe = se;
      if (he = (0, n.ensureBytes)("msgHash", he), Oe = (0, n.ensureBytes)("publicKey", Oe), "strict" in We)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: Ge, prehash: Ke } = We;
      let rt, Nt;
      try {
        if (typeof Fe == "string" || Fe instanceof Uint8Array)
          try {
            rt = x.fromDER(Fe);
          } catch (xt) {
            if (!(xt instanceof e.DER.Err))
              throw xt;
            rt = x.fromCompact(Fe);
          }
        else if (typeof Fe == "object" && typeof Fe.r == "bigint" && typeof Fe.s == "bigint") {
          const { r: xt, s: $t } = Fe;
          rt = new x(xt, $t);
        } else
          throw new Error("PARSE");
        Nt = E.fromHex(Oe);
      } catch (xt) {
        if (xt.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (Ge && rt.hasHighS())
        return !1;
      Ke && (he = N.hash(he));
      const { r: vt, s: kt } = rt, _t = J(he), Tt = B(kt), Zt = G(_t * Tt), gt = G(vt * Tt), Ft = E.BASE.multiplyAndAddUnsafe(Nt, Zt, gt)?.toAffine();
      return Ft ? G(Ft.x) === vt : !1;
    }
    return {
      CURVE: N,
      getPublicKey: H,
      getSharedSecret: ae,
      sign: $e,
      verify: et,
      ProjectivePoint: E,
      Signature: x,
      utils: F
    };
  }
  e.weierstrass = D;
  function L(M, N) {
    const b = M.ORDER;
    let k = f;
    for (let W = b - p; W % g === f; W /= g)
      k += p;
    const O = k, R = g << O - p - p, Q = R * g, G = (b - p) / Q, B = (G - p) / g, E = Q - p, T = R, C = M.pow(N, G), K = M.pow(N, (G + p) / g);
    let $ = (W, _) => {
      let ee = C, x = M.pow(_, E), F = M.sqr(x);
      F = M.mul(F, _);
      let H = M.mul(W, F);
      H = M.pow(H, B), H = M.mul(H, x), x = M.mul(H, _), F = M.mul(H, W);
      let oe = M.mul(F, x);
      H = M.pow(oe, T);
      let ae = M.eql(H, M.ONE);
      x = M.mul(F, K), H = M.mul(oe, ee), F = M.cmov(x, F, ae), oe = M.cmov(H, oe, ae);
      for (let ne = O; ne > p; ne--) {
        let J = ne - g;
        J = g << J - p;
        let ce = M.pow(oe, J);
        const _e = M.eql(ce, M.ONE);
        x = M.mul(F, ee), ee = M.mul(ee, ee), ce = M.mul(oe, ee), F = M.cmov(x, F, _e), oe = M.cmov(ce, oe, _e);
      }
      return { isValid: ae, value: F };
    };
    if (M.ORDER % A === y) {
      const W = (M.ORDER - y) / A, _ = M.sqrt(M.neg(N));
      $ = (ee, x) => {
        let F = M.sqr(x);
        const H = M.mul(ee, x);
        F = M.mul(F, H);
        let oe = M.pow(F, W);
        oe = M.mul(oe, H);
        const ae = M.mul(oe, _), ne = M.mul(M.sqr(oe), x), J = M.eql(ne, ee);
        let ce = M.cmov(ae, oe, J);
        return { isValid: J, value: ce };
      };
    }
    return $;
  }
  e.SWUFpSqrtRatio = L;
  function Y(M, N) {
    if (t.validateField(M), !M.isValid(N.A) || !M.isValid(N.B) || !M.isValid(N.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const b = L(M, N.Z);
    if (!M.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (k) => {
      let O, R, Q, G, B, E, T, C;
      O = M.sqr(k), O = M.mul(O, N.Z), R = M.sqr(O), R = M.add(R, O), Q = M.add(R, M.ONE), Q = M.mul(Q, N.B), G = M.cmov(N.Z, M.neg(R), !M.eql(R, M.ZERO)), G = M.mul(G, N.A), R = M.sqr(Q), E = M.sqr(G), B = M.mul(E, N.A), R = M.add(R, B), R = M.mul(R, Q), E = M.mul(E, G), B = M.mul(E, N.B), R = M.add(R, B), T = M.mul(O, Q);
      const { isValid: K, value: $ } = b(R, E);
      C = M.mul(O, k), C = M.mul(C, $), T = M.cmov(T, Q, K), C = M.cmov(C, $, K);
      const W = M.isOdd(k) === M.isOdd(C);
      return C = M.cmov(M.neg(C), C, W), T = M.div(T, G), { x: T, y: C };
    };
  }
  e.mapToCurveSimpleSWU = Y;
})(Si);
var Ut = {};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.createHasher = Ut.isogenyMap = Ut.hash_to_field = Ut.expand_message_xof = Ut.expand_message_xmd = void 0;
const kp = Pe, Vt = Ce;
function _p(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, Vt.utf8ToBytes)(e);
  throw new Error("DST must be Uint8Array or string");
}
const Fp = Vt.bytesToNumberBE;
function Ar(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let n = t - 1; n >= 0; n--)
    r[n] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function zp(e, t) {
  const r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e[n] ^ t[n];
  return r;
}
function An(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function Jo(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function au(e, t, r, n) {
  An(e), An(t), Jo(r), t.length > 255 && (t = n((0, Vt.concatBytes)((0, Vt.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: i, blockLen: o } = n, a = Math.ceil(r / i);
  if (a > 255)
    throw new Error("Invalid xmd length");
  const u = (0, Vt.concatBytes)(t, Ar(t.length, 1)), f = Ar(0, o), p = Ar(r, 2), g = new Array(a), y = n((0, Vt.concatBytes)(f, e, p, Ar(0, 1), u));
  g[0] = n((0, Vt.concatBytes)(y, Ar(1, 1), u));
  for (let A = 1; A <= a; A++) {
    const S = [zp(y, g[A - 1]), Ar(A + 1, 1), u];
    g[A] = n((0, Vt.concatBytes)(...S));
  }
  return (0, Vt.concatBytes)(...g).slice(0, r);
}
Ut.expand_message_xmd = au;
function cu(e, t, r, n, i) {
  if (An(e), An(t), Jo(r), t.length > 255) {
    const o = Math.ceil(2 * n / 8);
    t = i.create({ dkLen: o }).update((0, Vt.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return i.create({ dkLen: r }).update(e).update(Ar(r, 2)).update(t).update(Ar(t.length, 1)).digest();
}
Ut.expand_message_xof = cu;
function po(e, t, r) {
  (0, Vt.validateObject)(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: n, k: i, m: o, hash: a, expand: u, DST: f } = r;
  An(e), Jo(t);
  const p = _p(f), g = n.toString(2).length, y = Math.ceil((g + i) / 8), A = t * o * y;
  let S;
  if (u === "xmd")
    S = au(e, p, A, a);
  else if (u === "xof")
    S = cu(e, p, A, i, a);
  else if (u === "_internal_pass")
    S = e;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const I = new Array(t);
  for (let D = 0; D < t; D++) {
    const L = new Array(o);
    for (let Y = 0; Y < o; Y++) {
      const M = y * (Y + D * o), N = S.subarray(M, M + y);
      L[Y] = (0, kp.mod)(Fp(N), n);
    }
    I[D] = L;
  }
  return I;
}
Ut.hash_to_field = po;
function Qp(e, t) {
  const r = t.map((n) => Array.from(n).reverse());
  return (n, i) => {
    const [o, a, u, f] = r.map((p) => p.reduce((g, y) => e.add(e.mul(g, n), y)));
    return n = e.div(o, a), i = e.mul(i, e.div(u, f)), { x: n, y: i };
  };
}
Ut.isogenyMap = Qp;
function Wp(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(n, i) {
      const o = po(n, 2, { ...r, DST: r.DST, ...i }), a = e.fromAffine(t(o[0])), u = e.fromAffine(t(o[1])), f = a.add(u).clearCofactor();
      return f.assertValidity(), f;
    },
    encodeToCurve(n, i) {
      const o = po(n, 1, { ...r, DST: r.encodeDST, ...i }), a = e.fromAffine(t(o[0])).clearCofactor();
      return a.assertValidity(), a;
    }
  };
}
Ut.createHasher = Wp;
var Ur = {};
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.createCurve = Ur.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yp = Qo, Ws = Pt, Hp = Si;
function uu(e) {
  return {
    hash: e,
    hmac: (t, ...r) => (0, Yp.hmac)(e, t, (0, Ws.concatBytes)(...r)),
    randomBytes: Ws.randomBytes
  };
}
Ur.getHash = uu;
function qp(e, t) {
  const r = (n) => (0, Hp.weierstrass)({ ...e, ...uu(n) });
  return Object.freeze({ ...r(t), create: r });
}
Ur.createCurve = qp;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = nr, r = Pt, n = Pe, i = Si, o = Ce, a = Ut, u = Ur, f = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), p = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), g = BigInt(1), y = BigInt(2), A = (x, F) => (x + F / y) / F;
  function S(x) {
    const F = f, H = BigInt(3), oe = BigInt(6), ae = BigInt(11), ne = BigInt(22), J = BigInt(23), ce = BigInt(44), _e = BigInt(88), Ne = x * x * x % F, Ee = Ne * Ne * x % F, qe = (0, n.pow2)(Ee, H, F) * Ee % F, $e = (0, n.pow2)(qe, H, F) * Ee % F, et = (0, n.pow2)($e, y, F) * Ne % F, se = (0, n.pow2)(et, ae, F) * et % F, he = (0, n.pow2)(se, ne, F) * se % F, Oe = (0, n.pow2)(he, ce, F) * he % F, We = (0, n.pow2)(Oe, _e, F) * Oe % F, Fe = (0, n.pow2)(We, ce, F) * he % F, Ge = (0, n.pow2)(Fe, H, F) * Ee % F, Ke = (0, n.pow2)(Ge, J, F) * se % F, rt = (0, n.pow2)(Ke, oe, F) * Ne % F, Nt = (0, n.pow2)(rt, y, F);
    if (!I.eql(I.sqr(Nt), x))
      throw new Error("Cannot find square root");
    return Nt;
  }
  const I = (0, n.Field)(f, void 0, void 0, { sqrt: S });
  e.secp256k1 = (0, u.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp: I,
    n: p,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (x) => {
        const F = p, H = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), oe = -g * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ae = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ne = H, J = BigInt("0x100000000000000000000000000000000"), ce = A(ne * x, F), _e = A(-oe * x, F);
        let Ne = (0, n.mod)(x - ce * H - _e * ae, F), Ee = (0, n.mod)(-ce * oe - _e * ne, F);
        const qe = Ne > J, $e = Ee > J;
        if (qe && (Ne = F - Ne), $e && (Ee = F - Ee), Ne > J || Ee > J)
          throw new Error("splitScalar: Endomorphism failed, k=" + x);
        return { k1neg: qe, k1: Ne, k2neg: $e, k2: Ee };
      }
    }
  }, t.sha256);
  const D = BigInt(0), L = (x) => typeof x == "bigint" && D < x && x < f, Y = (x) => typeof x == "bigint" && D < x && x < p, M = {};
  function N(x, ...F) {
    let H = M[x];
    if (H === void 0) {
      const oe = (0, t.sha256)(Uint8Array.from(x, (ae) => ae.charCodeAt(0)));
      H = (0, o.concatBytes)(oe, oe), M[x] = H;
    }
    return (0, t.sha256)((0, o.concatBytes)(H, ...F));
  }
  const b = (x) => x.toRawBytes(!0).slice(1), k = (x) => (0, o.numberToBytesBE)(x, 32), O = (x) => (0, n.mod)(x, f), R = (x) => (0, n.mod)(x, p), Q = e.secp256k1.ProjectivePoint, G = (x, F, H) => Q.BASE.multiplyAndAddUnsafe(x, F, H);
  function B(x) {
    let F = e.secp256k1.utils.normPrivateKeyToScalar(x), H = Q.fromPrivateKey(F);
    return { scalar: H.hasEvenY() ? F : R(-F), bytes: b(H) };
  }
  function E(x) {
    if (!L(x))
      throw new Error("bad x: need 0 < x < p");
    const F = O(x * x), H = O(F * x + BigInt(7));
    let oe = S(H);
    oe % y !== D && (oe = O(-oe));
    const ae = new Q(x, oe, g);
    return ae.assertValidity(), ae;
  }
  function T(...x) {
    return R((0, o.bytesToNumberBE)(N("BIP0340/challenge", ...x)));
  }
  function C(x) {
    return B(x).bytes;
  }
  function K(x, F, H = (0, r.randomBytes)(32)) {
    const oe = (0, o.ensureBytes)("message", x), { bytes: ae, scalar: ne } = B(F), J = (0, o.ensureBytes)("auxRand", H, 32), ce = k(ne ^ (0, o.bytesToNumberBE)(N("BIP0340/aux", J))), _e = N("BIP0340/nonce", ce, ae, oe), Ne = R((0, o.bytesToNumberBE)(_e));
    if (Ne === D)
      throw new Error("sign failed: k is zero");
    const { bytes: Ee, scalar: qe } = B(Ne), $e = T(Ee, ae, oe), et = new Uint8Array(64);
    if (et.set(Ee, 0), et.set(k(R(qe + $e * ne)), 32), !$(et, oe, ae))
      throw new Error("sign: Invalid signature produced");
    return et;
  }
  function $(x, F, H) {
    const oe = (0, o.ensureBytes)("signature", x, 64), ae = (0, o.ensureBytes)("message", F), ne = (0, o.ensureBytes)("publicKey", H, 32);
    try {
      const J = E((0, o.bytesToNumberBE)(ne)), ce = (0, o.bytesToNumberBE)(oe.subarray(0, 32));
      if (!L(ce))
        return !1;
      const _e = (0, o.bytesToNumberBE)(oe.subarray(32, 64));
      if (!Y(_e))
        return !1;
      const Ne = T(k(ce), b(J), ae), Ee = G(J, _e, R(-Ne));
      return !(!Ee || !Ee.hasEvenY() || Ee.toAffine().x !== ce);
    } catch {
      return !1;
    }
  }
  e.schnorr = (() => ({
    getPublicKey: C,
    sign: K,
    verify: $,
    utils: {
      randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
      lift_x: E,
      pointToBytes: b,
      numberToBytesBE: o.numberToBytesBE,
      bytesToNumberBE: o.bytesToNumberBE,
      taggedHash: N,
      mod: n.mod
    }
  }))();
  const W = /* @__PURE__ */ (() => (0, a.isogenyMap)(I, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((x) => x.map((F) => BigInt(F)))))(), _ = /* @__PURE__ */ (() => (0, i.mapToCurveSimpleSWU)(I, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: I.create(BigInt("-11"))
  }))(), ee = /* @__PURE__ */ (() => (0, a.createHasher)(e.secp256k1.ProjectivePoint, (x) => {
    const { x: F, y: H } = _(I.create(x[0]));
    return W(F, H);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: I.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: t.sha256
  }))();
  e.hashToCurve = (() => ee.hashToCurve)(), e.encodeToCurve = (() => ee.encodeToCurve)();
})($c);
var es = Object.defineProperty, Zp = Object.getOwnPropertyDescriptor, Kp = Object.getOwnPropertyNames, Vp = Object.prototype.hasOwnProperty, Gp = (e, t) => {
  for (var r in t)
    es(e, r, { get: t[r], enumerable: !0 });
}, $p = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Kp(t))
      !Vp.call(e, i) && i !== r && es(e, i, { get: () => t[i], enumerable: !(n = Zp(t, i)) || n.enumerable });
  return e;
}, Xp = (e) => $p(es({}, "__esModule", { value: !0 }), e), lu = {};
Gp(lu, {
  Secp256k1PublicKey: () => fu
});
var Jp = Xp(lu), eg = qt, Ys = Dn, Hs = rn, qs = $c, tg = nr;
const go = 33;
class fu extends Ys.PublicKey {
  constructor(t) {
    if (super(), typeof t == "string" ? this.data = (0, eg.fromB64)(t) : t instanceof Uint8Array ? this.data = t : this.data = Uint8Array.from(t), this.data.length !== go)
      throw new Error(
        `Invalid public key input. Expected ${go} bytes, got ${this.data.length}`
      );
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return Hs.SIGNATURE_SCHEME_TO_FLAG.Secp256k1;
  }
  async verify(t, r) {
    let n;
    if (typeof r == "string") {
      const i = (0, Hs.parseSerializedSignature)(r);
      if (i.signatureScheme !== "Secp256k1")
        throw new Error("Invalid signature scheme");
      if (!(0, Ys.bytesEqual)(this.toRawBytes(), i.publicKey))
        throw new Error("Signature does not match public key");
      n = i.signature;
    } else
      n = r;
    return qs.secp256k1.verify(
      qs.secp256k1.Signature.fromCompact(n),
      (0, tg.sha256)(t),
      this.toRawBytes()
    );
  }
}
fu.SIZE = go;
var du = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.secp256r1 = e.p256 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const t = Ur, r = nr, n = Pe, i = Si, o = Ut, a = (0, n.Field)(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")), u = a.create(BigInt("-3")), f = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
  e.p256 = (0, t.createCurve)({
    a: u,
    b: f,
    Fp: a,
    n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
    Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
    Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
    h: BigInt(1),
    lowS: !1
  }, r.sha256), e.secp256r1 = e.p256;
  const p = /* @__PURE__ */ (() => (0, i.mapToCurveSimpleSWU)(a, {
    A: u,
    B: f,
    Z: a.create(BigInt("-10"))
  }))(), g = /* @__PURE__ */ (() => (0, o.createHasher)(e.secp256r1.ProjectivePoint, (y) => p(y[0]), {
    DST: "P256_XMD:SHA-256_SSWU_RO_",
    encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
    p: a.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: r.sha256
  }))();
  e.hashToCurve = (() => g.hashToCurve)(), e.encodeToCurve = (() => g.encodeToCurve)();
})(du);
var ts = Object.defineProperty, rg = Object.getOwnPropertyDescriptor, ng = Object.getOwnPropertyNames, ig = Object.prototype.hasOwnProperty, og = (e, t) => {
  for (var r in t)
    ts(e, r, { get: t[r], enumerable: !0 });
}, sg = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of ng(t))
      !ig.call(e, i) && i !== r && ts(e, i, { get: () => t[i], enumerable: !(n = rg(t, i)) || n.enumerable });
  return e;
}, ag = (e) => sg(ts({}, "__esModule", { value: !0 }), e), hu = {};
og(hu, {
  Secp256r1PublicKey: () => pu
});
var cg = ag(hu), ug = qt, Zs = Dn, Ks = rn, lg = nr, Vs = du;
const yo = 33;
class pu extends Zs.PublicKey {
  constructor(t) {
    if (super(), typeof t == "string" ? this.data = (0, ug.fromB64)(t) : t instanceof Uint8Array ? this.data = t : this.data = Uint8Array.from(t), this.data.length !== yo)
      throw new Error(
        `Invalid public key input. Expected ${yo} bytes, got ${this.data.length}`
      );
  }
  equals(t) {
    return super.equals(t);
  }
  toRawBytes() {
    return this.data;
  }
  flag() {
    return Ks.SIGNATURE_SCHEME_TO_FLAG.Secp256r1;
  }
  async verify(t, r) {
    let n;
    if (typeof r == "string") {
      const i = (0, Ks.parseSerializedSignature)(r);
      if (i.signatureScheme !== "Secp256r1")
        throw new Error("Invalid signature scheme");
      if (!(0, Zs.bytesEqual)(this.toRawBytes(), i.publicKey))
        throw new Error("Signature does not match public key");
      n = i.signature;
    } else
      n = r;
    return Vs.secp256r1.verify(
      Vs.secp256r1.Signature.fromCompact(n),
      (0, lg.sha256)(t),
      this.toRawBytes()
    );
  }
}
pu.SIZE = yo;
var qi, Gs;
function fg() {
  if (Gs)
    return qi;
  Gs = 1;
  var e = Object.defineProperty, t = Object.getOwnPropertyDescriptor, r = Object.getOwnPropertyNames, n = Object.prototype.hasOwnProperty, i = (b, k) => {
    for (var O in k)
      e(b, O, { get: k[O], enumerable: !0 });
  }, o = (b, k, O, R) => {
    if (k && typeof k == "object" || typeof k == "function")
      for (let Q of r(k))
        !n.call(b, Q) && Q !== O && e(b, Q, { get: () => k[Q], enumerable: !(R = t(k, Q)) || R.enumerable });
    return b;
  }, a = (b) => o(e({}, "__esModule", { value: !0 }), b), u = {};
  i(u, {
    MAX_SIGNER_IN_MULTISIG: () => L,
    MultiSigPublicKey: () => Y,
    parsePartialSignatures: () => M
  }), qi = a(u);
  var f = qt, p = nn, g = Pt, y = Dn, A = rn, S = yi, I = lc, D = gu();
  const L = 10;
  class Y extends y.PublicKey {
    constructor(k) {
      if (super(), typeof k == "string" ? (this.rawBytes = (0, f.fromB64)(k), this.multisigPublicKey = I.builder.de("MultiSigPublicKey", this.rawBytes)) : k instanceof Uint8Array ? (this.rawBytes = k, this.multisigPublicKey = I.builder.de("MultiSigPublicKey", this.rawBytes)) : (this.multisigPublicKey = k, this.rawBytes = I.builder.ser("MultiSigPublicKey", k).toBytes()), this.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey: O, weight: R }) => {
        const [Q, G] = Object.entries(O)[0];
        return {
          publicKey: (0, D.publicKeyFromRawBytes)(Q, Uint8Array.from(G)),
          weight: R
        };
      }), this.publicKeys.length > L)
        throw new Error(`Max number of signers in a multisig is ${L}`);
    }
    static fromPublicKeys({
      threshold: k,
      publicKeys: O
    }) {
      return new Y({
        pk_map: O.map(({ publicKey: R, weight: Q }) => ({
          pubKey: { [A.SIGNATURE_FLAG_TO_SCHEME[R.flag()]]: Array.from(R.toRawBytes()) },
          weight: Q
        })),
        threshold: k
      });
    }
    equals(k) {
      return super.equals(k);
    }
    toRawBytes() {
      return this.rawBytes;
    }
    getPublicKeys() {
      return this.publicKeys;
    }
    toSuiAddress() {
      const k = 1 + 65 * L + 2, O = new Uint8Array(k);
      O.set([A.SIGNATURE_SCHEME_TO_FLAG.MultiSig]), O.set(I.builder.ser("u16", this.multisigPublicKey.threshold).toBytes(), 1);
      let R = 3;
      for (const { publicKey: Q, weight: G } of this.publicKeys) {
        const B = Q.toSuiBytes();
        O.set(B, R), R += B.length, O.set([G], R++);
      }
      return (0, S.normalizeSuiAddress)((0, g.bytesToHex)((0, p.blake2b)(O.slice(0, R), { dkLen: 32 })));
    }
    flag() {
      return A.SIGNATURE_SCHEME_TO_FLAG.MultiSig;
    }
    async verify(k, O) {
      if (typeof O != "string")
        throw new Error("Multisig verification only supports serialized signature");
      const { signatureScheme: R, multisig: Q } = (0, A.parseSerializedSignature)(O);
      if (R !== "MultiSig")
        throw new Error("Invalid signature scheme");
      let G = 0;
      if (!(0, y.bytesEqual)(
        I.builder.ser("MultiSigPublicKey", this.multisigPublicKey).toBytes(),
        I.builder.ser("MultiSigPublicKey", Q.multisig_pk).toBytes()
      ))
        return !1;
      for (const { publicKey: B, weight: E, signature: T } of M(Q)) {
        if (!await B.verify(k, T))
          return !1;
        G += E;
      }
      return G >= this.multisigPublicKey.threshold;
    }
    combinePartialSignatures(k) {
      let O = 0;
      const R = new Array(k.length);
      for (let E = 0; E < k.length; E++) {
        let T = (0, A.parseSerializedSignature)(k[E]);
        if (T.signatureScheme === "MultiSig")
          throw new Error("MultiSig is not supported inside MultiSig");
        let C = Array.from(T.signature.map(($) => Number($)));
        T.signatureScheme === "ED25519" ? R[E] = { ED25519: C } : T.signatureScheme === "Secp256k1" ? R[E] = { Secp256k1: C } : T.signatureScheme === "Secp256r1" && (R[E] = { Secp256r1: C });
        let K;
        for (let $ = 0; $ < this.publicKeys.length; $++)
          if ((0, y.bytesEqual)(T.publicKey, this.publicKeys[$].publicKey.toRawBytes())) {
            if (O & 1 << $)
              throw new Error("Received multiple signatures from the same public key");
            K = $;
            break;
          }
        if (K === void 0)
          throw new Error("Received signature from unknown public key");
        O |= 1 << K;
      }
      let Q = {
        sigs: R,
        bitmap: O,
        multisig_pk: this.multisigPublicKey
      };
      const G = I.builder.ser("MultiSig", Q).toBytes();
      let B = new Uint8Array(G.length + 1);
      return B.set([A.SIGNATURE_SCHEME_TO_FLAG.MultiSig]), B.set(G, 1), (0, f.toB64)(B);
    }
  }
  function M(b) {
    let k = new Array(b.sigs.length);
    for (let O = 0; O < b.sigs.length; O++) {
      const [R, Q] = Object.entries(b.sigs[O])[0], G = N(b.bitmap).at(O), B = b.multisig_pk.pk_map[G], E = Uint8Array.from(Object.values(B.pubKey)[0]);
      if (R === "MultiSig")
        throw new Error("MultiSig is not supported inside MultiSig");
      const T = (0, D.publicKeyFromRawBytes)(R, E);
      k[O] = {
        signatureScheme: R,
        signature: Uint8Array.from(Q),
        publicKey: T,
        weight: B.weight
      };
    }
    return k;
  }
  function N(b) {
    if (b < 0 || b > 1024)
      throw new Error("Invalid bitmap");
    let k = [];
    for (let O = 0; O < 10; O++)
      (b & 1 << O) !== 0 && k.push(O);
    return Uint8Array.from(k);
  }
  return qi;
}
var Zi, $s;
function gu() {
  if ($s)
    return Zi;
  $s = 1;
  var e = Object.defineProperty, t = Object.getOwnPropertyDescriptor, r = Object.getOwnPropertyNames, n = Object.prototype.hasOwnProperty, i = (M, N) => {
    for (var b in N)
      e(M, b, { get: N[b], enumerable: !0 });
  }, o = (M, N, b, k) => {
    if (N && typeof N == "object" || typeof N == "function")
      for (let O of r(N))
        !n.call(M, O) && O !== b && e(M, O, { get: () => N[O], enumerable: !(k = t(N, O)) || k.enumerable });
    return M;
  }, a = (M) => o(e({}, "__esModule", { value: !0 }), M), u = {};
  i(u, {
    publicKeyFromRawBytes: () => Y,
    verifyPersonalMessage: () => I,
    verifySignature: () => S,
    verifyTransactionBlock: () => D
  }), Zi = a(u);
  var f = qa.exports, p = ip, g = Jp, y = cg, A = fg();
  async function S(M, N) {
    const b = L(N);
    if (!await b.publicKey.verify(M, b.serializedSignature))
      throw new Error("Signature is not valid for the provided data");
    return b.publicKey;
  }
  async function I(M, N) {
    const b = L(N);
    if (!await b.publicKey.verifyPersonalMessage(
      M,
      b.serializedSignature
    ))
      throw new Error("Signature is not valid for the provided message");
    return b.publicKey;
  }
  async function D(M, N) {
    const b = L(N);
    if (!await b.publicKey.verifyTransactionBlock(
      M,
      b.serializedSignature
    ))
      throw new Error("Signature is not valid for the provided TransactionBlock");
    return b.publicKey;
  }
  function L(M) {
    const N = (0, f.parseSerializedSignature)(M);
    if (N.signatureScheme === "MultiSig")
      return {
        ...N,
        publicKey: new A.MultiSigPublicKey(N.multisig.multisig_pk)
      };
    const b = Y(
      N.signatureScheme,
      N.publicKey
    );
    return {
      ...N,
      publicKey: b
    };
  }
  function Y(M, N) {
    switch (M) {
      case "ED25519":
        return new p.Ed25519PublicKey(N);
      case "Secp256k1":
        return new g.Secp256k1PublicKey(N);
      case "Secp256r1":
        return new y.Secp256r1PublicKey(N);
      case "MultiSig":
        return new A.MultiSigPublicKey(N);
      default:
        throw new Error(`Unsupported signature scheme ${M}`);
    }
  }
  return Zi;
}
var dg = gu();
function yu(e) {
  return Uint8Array.from(atob(e), (t) => t.charCodeAt(0));
}
async function hg(e, t) {
  try {
    const r = await dg.verifyPersonalMessage(yu(e.messageBytes), e.signature);
    return Iu(r.toRawBytes(), t);
  } catch {
    return !1;
  }
}
function W1(e) {
  return new TextDecoder().decode(yu(e));
}
function pg(e) {
  const t = Sn();
  return e ? tr(() => t.chains.find((r) => r.id === e), [e, t.chains]) : t.chain;
}
function gg(e) {
  const t = Sn(), {
    address: r = t.address,
    typeArg: n = pa,
    chainId: i = t.chain?.id
  } = e || {}, o = pg(i), a = nd(Qa.COIN_BALANCE, {
    address: r,
    typeArg: n,
    chainId: i
  }), u = St(() => {
    if (!r || !o)
      return BigInt(0);
    const f = new cd(o.rpcUrl);
    return new ad(f, r).balance.get(n);
  }, [o, r]);
  return $f(a, u, {
    initialData: BigInt(0)
  });
}
function yg(e) {
  const {
    typeArg: t,
    chainId: r
  } = e || {}, n = gg({
    typeArg: t,
    chainId: r
  });
  return Object.assign(n, {
    balance: n.data,
    loading: n.isLoading
  });
}
function Y1(e) {
  return tr(() => new da(new ha({ fullnode: e })), [e]);
}
function rr(e) {
  return Array.isArray(e) && e.length > 0;
}
function Xs(e) {
  return "standard:connect" in e.features && "standard:events" in e.features && "sui:signAndExecuteTransactionBlock" in e.features;
}
const bg = (e) => {
  const {
    icon: t,
    alt: r = "icon"
  } = e;
  return /* @__PURE__ */ ge("div", {
    onClick: e.onClick,
    className: e.className,
    style: e.style,
    children: typeof t == "string" ? /* @__PURE__ */ ge("img", {
      src: t,
      alt: r,
      className: e.elClassName,
      style: e.elStyle
    }) : Ct.cloneElement(t)
  });
};
const vg = () => /* @__PURE__ */ ct("div", {
  className: "wkit-dialog__header",
  children: [/* @__PURE__ */ ge(wn, {
    className: "wkit-dialog__title",
    children: "Connect Wallet"
  }), /* @__PURE__ */ ge(hf, {
    style: {
      position: "absolute",
      right: "16px",
      top: "16px"
    },
    className: "wkit-dialog__close",
    children: /* @__PURE__ */ ge(gf, {})
  })]
}), mg = () => /* @__PURE__ */ ct("div", {
  className: "wkit-new-to-sui",
  children: [/* @__PURE__ */ ge("span", {
    className: "wkit-new-to-sui__text",
    children: "New to sui? "
  }), /* @__PURE__ */ ge("a", {
    className: "wkit-new-to-sui__link",
    href: "https://suiet.app/docs/getting-started",
    target: "_blank",
    children: "Learn More Here"
  })]
}), wg = (e) => {
  const {
    wallet: t
  } = e, [r, n] = Bt("");
  return pt(() => {
    !t.iconUrl || n(t.iconUrl);
  }, [t.iconUrl]), /* @__PURE__ */ ct("div", {
    className: "wkit-select-item",
    onClick: () => {
      e.onSelect?.(t);
    },
    children: [/* @__PURE__ */ ge(bg, {
      icon: r,
      className: "wkit-select-item__icon",
      elClassName: "wkit-select-item__icon"
    }), t.label ?? t.name]
  }, t.name);
}, Js = (e) => rr(e.wallets) ? /* @__PURE__ */ ct("div", {
  className: "wkit-select__container",
  children: [/* @__PURE__ */ ge("div", {
    className: "wkit-select__title",
    children: e.title
  }), rr(e.wallets) && e.wallets.map((t) => /* @__PURE__ */ ge(wg, {
    wallet: t,
    onSelect: e.onSelect
  }, t.name))]
}) : null, Eg = (e) => {
  const {
    wallet: t
  } = e;
  return /* @__PURE__ */ ct("section", {
    children: [/* @__PURE__ */ ct("div", {
      className: "wkit-dialog__header",
      children: [/* @__PURE__ */ ge(wn, {
        className: "wkit-dialog__title",
        style: {
          margin: "-8px 12px -6px -8px"
        },
        children: /* @__PURE__ */ ge("span", {
          className: "wkit-dialog__close",
          onClick: e.onNavBack,
          children: /* @__PURE__ */ ge(ja, {})
        })
      }), /* @__PURE__ */ ge(wn, {
        className: "wkit-dialog__title",
        children: "Install Wallet"
      })]
    }), /* @__PURE__ */ ct("div", {
      className: "wkit-install",
      children: [/* @__PURE__ */ ge("img", {
        className: "wkit-install__logo",
        src: t.iconUrl,
        alt: `${t.name} logo`
      }), /* @__PURE__ */ ge("h1", {
        className: "wkit-install__title",
        children: "You haven\u2019t install this wallet"
      }), /* @__PURE__ */ ge("p", {
        className: "wkit-install__description",
        children: "Install wallet via Chrome Extension Store"
      }), /* @__PURE__ */ ge("button", {
        className: "wkit-button wkit-install__button",
        onClick: () => {
          if (!t.downloadUrl?.browserExtension)
            throw new Ot(`no downloadUrl config on this wallet: ${t.name}`);
          window.open(t.downloadUrl.browserExtension, "_blank");
        },
        children: "Get Wallet"
      })]
    })]
  });
}, Ag = (e) => {
  const {
    wallet: t
  } = e;
  return /* @__PURE__ */ ct("section", {
    children: [/* @__PURE__ */ ct("div", {
      className: "wkit-dialog__header",
      children: [/* @__PURE__ */ ge(wn, {
        className: "wkit-dialog__title",
        style: {
          margin: "-6px 12px -6px -8px"
        },
        children: /* @__PURE__ */ ge("span", {
          className: "wkit-dialog__close",
          onClick: e.onNavBack,
          children: /* @__PURE__ */ ge(ja, {})
        })
      }), /* @__PURE__ */ ge(wn, {
        className: "wkit-dialog__title",
        children: "Connecting"
      })]
    }), /* @__PURE__ */ ct("div", {
      className: "wkit-connecting",
      children: [/* @__PURE__ */ ge("img", {
        className: "wkit-connecting__logo",
        src: t.iconUrl,
        alt: `logo of ${t.name}`
      }), /* @__PURE__ */ ct("h1", {
        className: "wkit-connecting__title",
        children: ["Opening ", t.name]
      }), /* @__PURE__ */ ge("p", {
        className: "wkit-connecting__description",
        children: "Confirm connection in the extension"
      })]
    })]
  });
}, Mg = (e) => {
  const {
    configuredWallets: t,
    detectedWallets: r,
    select: n,
    connecting: i
  } = Sn(), {
    onConnectSuccess: o = () => {
    },
    onConnectError: a = (y) => {
      throw y;
    }
  } = e, [u, f] = Bt(), p = St(async (y) => {
    if (f(y), y.installed) {
      try {
        await n(y.name);
      } catch (A) {
        a(A);
        return;
      }
      o(y.name);
    }
  }, [n]);
  function g() {
    if (u) {
      if (!u.installed)
        return /* @__PURE__ */ ge(Eg, {
          wallet: u,
          onNavBack: () => {
            f(void 0);
          }
        });
      if (i)
        return /* @__PURE__ */ ge(Ag, {
          wallet: u,
          onNavBack: () => {
            f(void 0);
          }
        });
    }
    return /* @__PURE__ */ ct("div", {
      children: [/* @__PURE__ */ ge(vg, {}), /* @__PURE__ */ ct("div", {
        className: "wkit-select__scroll",
        children: [/* @__PURE__ */ ge(Js, {
          title: "Popular",
          wallets: t,
          onSelect: p
        }), /* @__PURE__ */ ge(Js, {
          title: "Others",
          wallets: r,
          onSelect: p
        })]
      }), /* @__PURE__ */ ge("div", {
        style: {
          height: "41px",
          flexShrink: "0"
        }
      }), /* @__PURE__ */ ge(mg, {})]
    });
  }
  return /* @__PURE__ */ ge(pf, {
    open: e.open,
    onOpenChange: e.onOpenChange,
    trigger: e.children,
    contentProps: {
      onOpenAutoFocus: (y) => {
        y.preventDefault();
      }
    },
    children: g()
  });
};
function Sg(e) {
  const {
    disconnect: t,
    account: r,
    chain: n,
    connected: i,
    name: o
  } = Sn(), {
    balance: a
  } = yg(), [u, f] = Bt(!1), p = St(() => !n || n.id === Yn.id ? /* @__PURE__ */ ge(Gn, {
    children: "Unknown Chain"
  }) : /* @__PURE__ */ ct(Gn, {
    children: [ld(a ?? 0), " SUI"]
  }), [a, n]);
  return i ? /* @__PURE__ */ ct("div", {
    className: vn("wkit-connected-container", e.className),
    style: e.style,
    children: [/* @__PURE__ */ ct("button", {
      className: vn("wkit-connected-button"),
      onClick: () => {
        f(!u);
      },
      children: [/* @__PURE__ */ ge("span", {
        className: "wkit-connected-button__balance",
        children: p()
      }), /* @__PURE__ */ ge("div", {
        className: "wkit-connected-button__divider"
      }), /* @__PURE__ */ ct("div", {
        className: "wkit-address-select",
        children: [/* @__PURE__ */ ge("span", {
          className: "wkit-address-select__address",
          children: hd(r?.address)
        }), /* @__PURE__ */ ge("span", {
          className: "wkit-address-select__right-arrow",
          children: /* @__PURE__ */ ge(yf, {})
        })]
      })]
    }), u && /* @__PURE__ */ ge("div", {
      className: "wkit-disconnect-button__container",
      children: /* @__PURE__ */ ge("button", {
        className: "wkit-disconnect-button",
        onClick: async () => {
          f(!1);
          try {
            await t();
          } catch (g) {
            e?.onDisconnectError?.(g);
            return;
          }
          e?.onDisconnectSuccess?.(o);
        },
        children: "Disconnect"
      })
    })]
  }) : null;
}
const H1 = (e) => {
  const {
    label: t = "Connect Button"
  } = e, [r, n] = Bt(!1), {
    connected: i
  } = Sn();
  return pt(() => {
    i && n(!1);
  }, [i]), /* @__PURE__ */ ge(Mg, {
    open: r,
    onOpenChange: (o) => {
      i || n(o);
    },
    onConnectSuccess: e.onConnectSuccess,
    onConnectError: e.onConnectError,
    children: /* @__PURE__ */ ge("div", {
      children: i ? /* @__PURE__ */ ge(Sg, {
        className: vn(e.className),
        style: e.style,
        onDisconnectSuccess: (o) => {
          n(!1), e?.onDisconnectSuccess?.(o);
        },
        onDisconnectError: e.onDisconnectError
      }) : /* @__PURE__ */ ge("button", {
        className: vn("wkit-button", e.className),
        style: e.style,
        children: e.children || t
      })
    })
  });
};
function Rt(e) {
  return Object.freeze(e);
}
var wr = /* @__PURE__ */ ((e) => (e.SUI_WALLET = "Sui Wallet", e.SUIET_WALLET = "Suiet", e.ETHOS_WALLET = "Ethos Wallet", e.SURF_WALLET = "Surf Wallet", e.GLASS_WALLET = "GlassWallet", e.MORPHIS_WALLET = "Morphis Wallet", e.MARTIAN_WALLET = "Martian Sui Wallet", e.ONEKEY_WALLET = "OneKey Wallet", e.SPACECY_WALLET = "Spacecy Sui Wallet", e.SENSUI_WALLET = "Sensui Wallet", e.NIGHTLY_WALLET = "Nightly", e.ELLI_WALLET = "Elli", e.TOKENPOCKET_WALLET = "TokenPocket Wallet", e.FRONTIER_WALLET = "Frontier Wallet", e))(wr || {});
const Ng = Rt({
  name: "Suiet",
  label: "Suiet Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iMTYiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3KSIvPjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMTcwOF8yODI5NykiIGZpbGw9IiNmZmYiPjxwYXRoIGQ9Ik0yMi44IDIwYy0xLjQgMC0yLjctMS40LTMuMy0yLjMtLjcuOS0yIDIuMy0zLjQgMi4zcy0yLjctMS40LTMuNC0yLjNjLS42LjktMS45IDIuMy0zLjMgMi4zLS4zIDAtLjUtLjItLjUtLjVzLjItLjUuNS0uNWMxLjEgMCAyLjYtMS45IDIuOS0yLjVsLjUtLjJjLjIgMCAuMyAwIC40LjIuNC42IDEuOCAyLjUgMi45IDIuNSAxLjEgMCAyLjUtMS45IDIuOS0yLjVsLjQtLjJjLjIgMCAuNCAwIC41LjIuNC42IDEuOCAyLjUgMi45IDIuNS4yIDAgLjUuMi41LjVzLS4yLjUtLjUuNXoiLz48cGF0aCBkPSJNMjIuOCAyMy4zYy0xLjQgMC0yLjctMS4zLTMuMy0yLjMtLjcgMS0yIDIuMy0zLjQgMi4zUzEzLjQgMjIgMTIuNyAyMWMtLjYgMS0xLjkgMi4zLTMuMyAyLjMtLjMgMC0uNS0uMy0uNS0uNSAwLS4zLjItLjYuNS0uNiAxLjEgMCAyLjYtMS44IDIuOS0yLjRsLjUtLjIuNC4yYy40LjYgMS44IDIuNCAyLjkgMi40IDEuMSAwIDIuNS0xLjggMi45LTIuNGwuNC0uMi41LjJjLjQuNiAxLjggMi40IDIuOSAyLjQuMiAwIC41LjMuNS42IDAgLjItLjIuNS0uNS41ek05LjggMTYuN2MtLjMgMC0uNS0uMi0uNS0uNEw5LjEgMTVjMC0zLjkgMy4yLTcgNy03IDMuOSAwIDcgMy4xIDcgN2wtLjEgMS4yYzAgLjMtLjMuNS0uNi41LS40LS4xLS41LS4zLS40LS43di0xYzAtMy4zLTIuNi02LTUuOS02LTMuMiAwLTUuOSAyLjctNS45IDZsLjEgMWMuMS40LS4xLjctLjQuN2gtLjF6Ii8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF8xNzA4XzI4Mjk3IiB4PSI0LjkiIHk9IjYiIHdpZHRoPSIyMi40MzciIGhlaWdodD0iMjMuMzE5IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz48ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+PGZlT2Zmc2V0IGR5PSIyIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPjxmZUNvbG9yTWF0cml4IHZhbHVlcz0iMCAwIDAgMCAwLjE3NTY5NCAwIDAgMCAwIDAuNTc0MTQyIDAgMCAwIDAgMC45MTY2NjcgMCAwIDAgMSAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE3MDhfMjgyOTciLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTcwOF8yODI5NyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xNzA4XzI4Mjk3IiB5MT0iNCIgeDI9IjI4Ljg4OSIgeTI9IjMyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzNFQTJGOCIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzY3QzhGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/suiet/khpkpbbcccdmmclmpigdgddabeilkdpd"
  }
}), Tg = Rt({
  name: "Sui Wallet",
  label: "Sui Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAIVBMVEUAAAD////////9/f39/f3+/v7x+Pz///95wfGj1PXI5fgEMJeQAAAAB3RSTlMAECNgmNr40ET05wAAAOBJREFUeNplUksOgjAQbYw38LdloQdw5VZJDGuNiWtXdGvUFjlAtT2AVC4AekrLvKKYvoTMm5fpfGGswWCdit2cfTFNZYO49YfSYwW/t2+FS0TCTH6x/Q/wISPZwcYJSVc4uxdg1wI2Yn0QbmCXbAKin7AHtiCbq6wicvI5syK/+azowlZSoxNGc4l7IWswhqKlagtD4Kl9CAWBAmspbGHwhJK+HDMlkiaIcJ9BWWqMu64yhcbGVMU5nKoc/XC2fGs/HMbPra78+MGCwhUGSw7OEB4qOKU7Nrki/p2/8zt8ABpiv63tyiOHAAAAAElFTkSuQmCC",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil"
  }
}), Ig = Rt({
  name: "Ethos Wallet",
  label: "Ethos Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwMCIgaGVpZ2h0PSIxMjAwIiBmaWxsPSIjRjRFRkZGIi8+CjxwYXRoIGQ9Ik0zNzAuMjU3IDM0My4yMTlINzI1LjE5Qzc1NC4wMTkgMzQzLjIxOSA3NzcuMzg4IDM2Ni45MzYgNzc3LjM4OCAzOTYuMTkyVjgwNy43MTlDNzc3LjM4OCA4MzYuOTc2IDc1NC4wMTggODYwLjY5MiA3MjUuMTkgODYwLjY5MkgzNzAuMjU2QzM0MS40MjggODYwLjY5MiAzMTguMDU4IDgzNi45NzYgMzE4LjA1OCA4MDcuNzE5VjM5Ni4xOTJDMzE4LjA1OCAzNjYuOTM2IDM0MS40MjggMzQzLjIxOSAzNzAuMjU3IDM0My4yMTlaIiBmaWxsPSIjRDdCOEZGIi8+CjxwYXRoIGQ9Ik0zNzcuMzc2IDM0Ny4yMjVMNjI3LjY3NCA0NjUuNDIxQzY0Mi40IDQ3Mi4zNzUgNjUxLjgxNiA0ODcuMzYyIDY1MS44MTYgNTAzLjg0NFY5MzAuMjlDNjUxLjgxNiA5NjAuOTU1IDYyMC43MTYgOTgxLjQ2OSA1OTMuMTAyIDk2OS4wMThMMzQyLjgwNCA4NTYuMTU5QzMyNy43MjEgODQ5LjM1OSAzMTggODM0LjE4MSAzMTggODE3LjQzMVYzODUuNjQ4QzMxOCAzNTQuNjYzIDM0OS42OTUgMzM0LjE1MyAzNzcuMzc2IDM0Ny4yMjVaIiBmaWxsPSIjOUE0MkZGIi8+CjxwYXRoIGQ9Ik04NTQuOTE2IDE5Nkw4NjAuMTQzIDIxMC4xMjVDODcyLjQ1NSAyNDMuNCA4OTguNjkxIDI2OS42MzUgOTMxLjk2NiAyODEuOTQ4TDk0Ni4wOTEgMjg3LjE3NUw5MzEuOTY2IDI5Mi40MDFDODk4LjY5MSAzMDQuNzE0IDg3Mi40NTUgMzMwLjk1IDg2MC4xNDMgMzY0LjIyNUw4NTQuOTE2IDM3OC4zNDlMODQ5LjY4OSAzNjQuMjI1QzgzNy4zNzYgMzMwLjk1IDgxMS4xNDEgMzA0LjcxNCA3NzcuODY2IDI5Mi40MDFMNzYzLjc0MSAyODcuMTc1TDc3Ny44NjYgMjgxLjk0OEM4MTEuMTQxIDI2OS42MzUgODM3LjM3NiAyNDMuNCA4NDkuNjg5IDIxMC4xMjVMODU0LjkxNiAxOTZaIiBmaWxsPSIjOUE0MkZGIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli"
  }
}), Og = Rt({
  name: "Martian Sui Wallet",
  label: "Martian Sui Wallet",
  iconUrl: "https://cdn.martianwallet.xyz/assets/icon.png",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/martian-wallet-aptos-sui/efbglgofoippbgcjepnhiblaibcnclgk"
  }
}), Dg = Rt({
  name: "Surf Wallet",
  label: "Surf Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNDcwIDQwMGMtMTEgOC0yMyAxNC0zNSAxNS00NyA0LTEwNi00Mi0xNDQtNDdzLTYwIDIxLTY5IDM2Yy01IDktNiAyMi02IDMzIDAgNCAwIDkgMiAxNSAyIDExIDMwIDU1IDk0IDQ5IDY5LTYgMTA5LTQzIDE1MC05Mmw2LTYgMi0zeiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTQgMzI3YzExLTYgMjItMTEgMzMtMTEgNDIgMCA5MiA0NiAxMjUgNTMgMzQgNyA1Ni0xNSA2NC0yNyA3LTEyIDgtMjMgOC0zMWwtMS0xMmMtMi03LTIyLTUwLTc5LTUwLTYzIDAtMTAyIDMwLTE0MiA3MGwtNSA1LTMgM3oiIGZpbGw9IiM5REUyRkYiLz48cGF0aCBkPSJNMzMgMjk2djJjMCA1OCA0NyAxMDMgMTA0IDEwMyAyNCAwIDQ1LTcgNjMtMjFsMS0xIDEtMSAxLTF2LTFsMTEtMTAgNDAtMzkgMy0yIDUtNmM0MC00MCA3OS03MCAxNDEtNzAgNTggMCA3NyA0MyA4MCA1MS01LTk5LTc1LTE4MS0xNjgtMjA2bC0zLTFjLTEwLTItMzYtMTItMzYtMjdWMThzMi0xMy0xMi00Yy0zNiAyNC02NyA3Ni05NSA5MS02OSAzMC0xMjAgOTAtMTM0IDE2NmwtMiAxOXY2eiIgZmlsbD0iIzU4QzVGMyIvPjxwYXRoIGQ9Ik0yNTUgMjcxbC00MyAzNi00NCAzOGMtNiA2LTE1IDQtMTgtN3MzLTUyIDM0LTcyIDYyLTIwIDc0LTEzYzkgNyA2IDExIDQgMTNsLTcgNXoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/surf-sui-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen"
  }
}), Cg = Rt({
  name: "GlassWallet",
  label: "Glass Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa"
  }
}), jg = Rt({
  name: "Morphis Wallet",
  label: "Morphis Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iNSIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xOS45NCA3LjRsLS4wMS0uMDhWNy4zYy0uMDEtLjAyLS4wMS0uMDQtLjAzLS4wNSAwLS4wMy0uMDItLjA1LS4wMy0uMDdsLS4wMS0uMDEtLjA2LS4wNS0uMDQtLjAyLTUuMDUtMy4wNWgtLjAxbC0uMDMtLjAxLS4wNC0uMDEtLjAzLS4wMi0uMDQtLjAxaC0uMDdsLS4wNC4wMS0uMDQuMDItLjAzLjAxLS4wNC4wMWgtLjAxTDkuMjkgNy4xIDQuMiAxMC4xM2wtLjA2LjAzLS4wMS4wMi0uMDUuMDUtLjAzLjA1LS4wMS4wMS0uMDMuMDYtLjAxLjA3djYuMTJjMCAuMTYuMDcuMjkuMi4zNmw1LjA1IDMuMDVjLjA1LjA0LjEzLjA1LjIuMDUuMDggMCAuMTQtLjAxLjIxLS4wNS4xMi0uMDguMi0uMjEuMi0uMzd2LTUuMzdsNC40NiAyLjY5Yy4wNi4wMy4xMy4wNC4yLjA0LjA4IDAgLjEzLS4wMS4yMS0uMDQuMTItLjA4LjItLjIyLjItLjM3di01LjM3bDQuNDYgMi42OGMuMDYuMDMuMTMuMDUuMjEuMDUuMDYgMCAuMTItLjAyLjItLjA1LjEyLS4wOC4yLS4yMi4yLS4zN1Y3LjM4Yy0uMDYuMDUtLjA2LjAyLS4wNi4wMnptLTEwLjUgNS42NEw1LjIgMTAuNDhsNC4yNC0yLjU3IDQuMjYgMi41Ny00LjI2IDIuNTZ6TTE0LjUgMTBsLTQuMjUtMi41NyA0LjI1LTIuNTYgNC4yNSAyLjU2TDE0LjUgMTB6bS01LjQ2IDguOUw0LjggMTYuMzNWMTEuMmw0LjI0IDIuNTZ2NS4xNHptMS4yMS01LjM3bDMuODUtMi4zM3Y0LjY1bC0zLjg1LTIuMzJ6bTUuMDUtMy4wM2wzLjg1LTIuMzR2NC42NGwtMy44NS0yLjN6IiBmaWxsPSIjMDAwIi8+PC9zdmc+",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/morphis-wallet/heefohaffomkkkphnlpohglngmbcclhi"
  }
}), xg = Rt({
  name: "OneKey Wallet",
  label: "OneKey Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80NTkyMl84OCkiPgo8cGF0aCBkPSJNMTI3LjYxIDYzLjgwNDlDMTI3LjYxIDEwNy44NTMgMTA3Ljg1MyAxMjcuNjEgNjMuODA0OSAxMjcuNjFDMTkuNzU2OCAxMjcuNjEgMCAxMDcuODUzIDAgNjMuODA0OUMwIDE5Ljc1NjggMTkuNzU2OCAwIDYzLjgwNDkgMEMxMDcuODUzIDAgMTI3LjYxIDE5Ljc1NjggMTI3LjYxIDYzLjgwNDlaIiBmaWxsPSIjM0JEMjNEIi8+CjxwYXRoIGQ9Ik02OS41Njk5IDI3LjA1NTdMNTEuODE5NyAyNy4wNTU3TDQ4LjcwNTYgMzYuNDcxOUg1OC41NjQ1TDU4LjU2NDUgNTYuMzA2M0g2OS41Njk5VjI3LjA1NTdaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTg0LjA0ODYgODAuMzExMUM4NC4wNDg2IDkxLjQ5MTIgNzQuOTg1NCAxMDAuNTU0IDYzLjgwNTMgMTAwLjU1NEM1Mi42MjUzIDEwMC41NTQgNDMuNTYyMSA5MS40OTEyIDQzLjU2MjEgODAuMzExMUM0My41NjIxIDY5LjEzMTEgNTIuNjI1MyA2MC4wNjc4IDYzLjgwNTMgNjAuMDY3OEM3NC45ODU0IDYwLjA2NzggODQuMDQ4NiA2OS4xMzExIDg0LjA0ODYgODAuMzExMVpNNzQuODU4NCA4MC4zMTExQzc0Ljg1ODQgODYuNDE1NSA2OS45MDk3IDkxLjM2NDEgNjMuODA1MyA5MS4zNjQxQzU3LjcwMDggOTEuMzY0MSA1Mi43NTIyIDg2LjQxNTUgNTIuNzUyMiA4MC4zMTExQzUyLjc1MjIgNzQuMjA2NiA1Ny43MDA4IDY5LjI1OCA2My44MDUzIDY5LjI1OEM2OS45MDk3IDY5LjI1OCA3NC44NTg0IDc0LjIwNjYgNzQuODU4NCA4MC4zMTExWiIgZmlsbD0iYmxhY2siLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF80NTkyMl84OCI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/onekey/jnmbobjmhlngoefaiojfljckilhhlhcj"
  }
}), Lg = Rt({
  name: "Spacecy Sui Wallet",
  label: "Spacecy Sui Wallet",
  iconUrl: "https://spacecywallet.com/favicon.ico",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/spacecy-wallet/mkchoaaiifodcflmbaphdgeidocajadp?hl=en-US"
  }
}), Bg = Rt({
  name: "Sensui Wallet",
  label: "Sensui Wallet",
  iconUrl: "data:image/png;base64,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",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/sensui-wallet/ebaeifdbcjklcmoigppnpkcghndhpbbm"
  }
}), Rg = Rt({
  name: "Nightly",
  label: "Nightly",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAxIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMSAyMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wLjM5MDYyNSAxMDBDMC4zOTA2MjUgNDQuNzcxNSA0NS4xNjIyIDAgMTAwLjM5MSAwQzE1NS42MTkgMCAyMDAuMzkxIDQ0Ljc3MTUgMjAwLjM5MSAxMDBDMjAwLjM5MSAxNTUuMjI4IDE1NS42MTkgMjAwIDEwMC4zOTEgMjAwQzQ1LjE2MjIgMjAwIDAuMzkwNjI1IDE1NS4yMjggMC4zOTA2MjUgMTAwWiIgZmlsbD0iIzYwNjdGOSIvPgo8cGF0aCBkPSJNMTQ2LjgzOCA0MEMxMzguMDU0IDUyLjI2MDcgMTI3LjA2MSA2MC43NjM0IDExNC4wNzIgNjYuNDQ3NEMxMDkuNTYzIDY1LjIwMjYgMTA0LjkzNiA2NC41Njg0IDEwMC4zNzkgNjQuNjE1NEM5NS44MjIzIDY0LjU2ODQgOTEuMTk1MSA2NS4yMjYxIDg2LjY4NTUgNjYuNDQ3NEM3My42OTY2IDYwLjczOTkgNjIuNzA0MiA1Mi4yODQyIDUzLjkxOTggNDBDNTEuMjY1NiA0Ni42NzA2IDQxLjA0ODMgNjkuNjg4OCA1My4zMDkxIDEwMS44NjdDNTMuMzA5MSAxMDEuODY3IDQ5LjM4NjYgMTE4LjY2MSA1Ni41OTc0IDEzMy4wODNDNTYuNTk3NCAxMzMuMDgzIDY3LjAyNiAxMjguMzYyIDc1LjMxNzMgMTM1LjAwOUM4My45ODQzIDE0Mi4wMzIgODEuMjEyOCAxNDguNzk2IDg3LjMxOTYgMTU0LjYyMUM5Mi41ODA5IDE2MCAxMDAuNDAyIDE2MCAxMDAuNDAyIDE2MEMxMDAuNDAyIDE2MCAxMDguMjI0IDE2MCAxMTMuNDg1IDE1NC42NDVDMTE5LjU5MiAxNDguODQzIDExNi44NDQgMTQyLjA3OSAxMjUuNDg4IDEzNS4wMzJDMTMzLjc1NSAxMjguMzg1IDE0NC4yMDcgMTMzLjEwNiAxNDQuMjA3IDEzMy4xMDZDMTUxLjM5NSAxMTguNjg1IDE0Ny40OTYgMTAxLjg5MSAxNDcuNDk2IDEwMS44OTFDMTU5LjcxIDY5LjY4ODggMTQ5LjUxNiA0Ni42NzA2IDE0Ni44MzggNDBaTTU5LjgzODcgOTcuNDI4MUM1My4xNjgxIDgzLjczNDYgNTEuMzM2MSA2NC45NDQyIDU1LjU0MDQgNTAuMDk5OEM2MS4xMDcxIDY0LjE5MjYgNjguNjcwMiA3MC41MTA5IDc3LjY2NjEgNzcuMTgxNEM3My44NjEgODUuMDk2OSA2Ni42OTcyIDkyLjU2NjEgNTkuODM4NyA5Ny40MjgxWk03OS4wMjg0IDEyMS41NUM3My43NjcxIDExOS4yMjUgNzIuNjYzMSAxMTQuNjQ1IDcyLjY2MzEgMTE0LjY0NUM3OS44MjcgMTEwLjEzNSA5MC4zNzMxIDExMy41ODggOTAuNzAxOSAxMjQuMjUxQzg1LjE1ODcgMTIwLjg5MyA4My4zMDMyIDEyMy40MDYgNzkuMDI4NCAxMjEuNTVaTTEwMC4zNzkgMTU5LjQxM0M5Ni42MjA5IDE1OS40MTMgOTMuNTY3NCAxNTYuNzEyIDkzLjU2NzQgMTUzLjRDOTMuNTY3NCAxNTAuMDg4IDk2LjYyMDkgMTQ3LjM4NyAxMDAuMzc5IDE0Ny4zODdDMTA0LjEzNyAxNDcuMzg3IDEwNy4xOSAxNTAuMDg4IDEwNy4xOSAxNTMuNEMxMDcuMTkgMTU2LjczNSAxMDQuMTM3IDE1OS40MTMgMTAwLjM3OSAxNTkuNDEzWk0xMjEuNzUzIDEyMS41NUMxMTcuNDc4IDEyMy40MjkgMTE1LjY0NiAxMjAuODkzIDExMC4wNzkgMTI0LjI1MUMxMTAuNDMyIDExMy41ODggMTIwLjkzMSAxMTAuMTM1IDEyOC4xMTggMTE0LjY0NUMxMjguMTE4IDExNC42MjEgMTI2Ljk5MSAxMTkuMjI1IDEyMS43NTMgMTIxLjU1Wk0xNDAuOTE5IDk3LjQyODFDMTM0LjA4NCA5Mi41NjYxIDEyNi44OTcgODUuMTIwNCAxMjMuMDY4IDc3LjE4MTRDMTMyLjA2NCA3MC41MTA5IDEzOS42NTEgNjQuMTY5MSAxNDUuMTk0IDUwLjA5OThDMTQ5LjQ0NSA2NC45NDQyIDE0Ny42MTMgODMuNzU4MSAxNDAuOTE5IDk3LjQyODFaIiBmaWxsPSIjRjdGN0Y3Ii8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en&authuser=0"
  }
}), Ug = Rt({
  name: "Elli",
  label: "Elli Wallet",
  iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYySURBVHgBdVdLbBVlFD5nemtvuRLKGxMTaVlBUgIREzExQJCFCTG4cONC6ka3JkbjAhMxSCExutTEhXRhjIkJ0bjk0YWBghBLqZiItnFHa5Fi+m5njuf5z9xemKb33vnn/8/jO995DELlarvx9/GCsI+A9iBm64gI+eJb4g+75F7X7YYfESD/kd/KXqju8X28Lt+DvPsc7Ht6ID3Sz1/Hu2AFz7PwAy5AHpkQl6IK9DPj5SIMULvEhuq+dFUfqG2mkDUMQxsdgr3d05nKyeEy6zuox1Vmof+Ihd2jWFWYBbGWyWYWCgXaWpH2xb/LIpFFIdvO7YEczhsC1//sw7bsazWvFTL33KBl6QZZLIZHAaWfIwfXjwcaKEHR/XEQ6M0aZnSc2BzZHfEVkeiaUnTRDcFSoG5yjiQ7FAXxVf9cpVmoshDMD1RwjiPc/IPKKMUTcrUlAXFVfLFUXEXAOUEIq8+b9sDEmUvTNYuVyUFncBgsHpjlaMTDZIsbSWFMkBRLw4vwuQJaIJuM7qpBInKklseLoLrZlRcI4Sm5I0aQpCQAgsyNwCpokEKGHsQaKeNdVxyShaxMfScoJnKSm52FhZS8CjQTYtUaEuCHU/xdQ/VVMYYgm3NFD9WvXSWcmUFoAhMg37IVlnp3q/Mdo7egbXIi4AOvRJBv3Ya6J3D1whblQX7UglqYueFRfPijPnQVN5w6CasvajRg6vRZ0JCIwMYa7PrqS8DZ2Za9D955F+cPH5FTaIIZmcyzDaWs8YKEgSEDUNiMXO1/3cX1n3/6GOVnYHlHj9OwQP5NU/1n9Nnqax0bVhu7CxpqL1ZW5CyWmVQ7++cFqbL8sDZ5DzacPtXikSrv72fl3RBCtFqKET1iRH+LERnL2PjJKZY5AV5h0Z3WaGRGZ3mQ822uCVUfugJtExMt3sy9dBiWera7N+JBjlG25bc8W+ztbTkn/Fhz8YKdi1JtLEFFgDTjybMrh/kjh2mlp7tFUOeFi+zRjNV5NtaoK0I1FOIl1YeGWs4ts6yZY0dJUbbeApYlQFmUWzTrZBPkjTpOnfiAWbylBU72hNrHx2DNpUsqTHjV+OFHaB8fh46REVytXGT8y7Ko0YmWvI64hi7n3hQQat55HxActm6GqTMftxjRefUato+NSYjQCk1BtX8mGOZ7sPbb71qUq4xtm8nJZyFztEVfBgaLxpNSW+UYMSHZCLp/4v0mYj1x+zdYYeP+e/01kP1Cpodv9UkqslGTaZ8S9uxJlrEJTDGVmaCVq1DSZ6BCck1F9DLnfVz7/MqOZ+j+h+81Cc7mZixzytChkLZq6NTZj2hly0Z0eUo4DPK64Ywgy7n9c+FnMEYC7wEUJVdu60O/QMFeLu/YDt4zSe5FXDY3p04VTzY4RDc0lAvPP5dmhmjlROXYoAqsEnrXSp0KvblEWTUBoqxj5A6s/eZ7/X749hs4e+xl48WV69D12RewtHsXLOzfB0vd291rnyl9HmrqWNbhIKMUm2iveYLVRijjSLFtE80deZHr/04yMt6wEYz3iFFyLfbuhPn9z2Lx1KaScFp0CDEqIJg88pRHHB0sjP0Bi0MkJ4oYSqOhkeZKfegmN6hZXHhhnz7pYGMEoUX2vjqqgaMXk4zPCpB2aN8ZveTJ6cMIGRZYOVkOGclMrE4/WFIlzXvNUxakx9A0nxDWvAaENPRRyMOC6Vh6R0jjNUFpp53T9ayZvH4GnYHBA+/9PA+QppPPdz5++bwGPhb5+EKYFDq4BNXpmVxZxUdI051HEZWYptz08ExID3hxPWJsp8QDCrih+oJRplGMmNrZ4hsTmyucl3xnNhc5YjmX2hDGCNxCKCtgsDd1LmU6KIOp8gJCXsCkgprO1JRSqy2rrDjF+zKtFvHSIpkwyEvFgAmjNCR4u9RqF0okHVOltLZNmIUSa2JWHd1I0laNqcpa58QmRykfsCS789Nl/jqYalCFro/6hmZ8yysmR2parQ7YZQyJhmnX0b02CS4uv8qah6P4UBqZCkchOqZOQIQxB/ge6/E60vHPeCdMBQ6j/RJGXygGqXP5UKsjv5/v4/mFX5fggLP1Eflcca3ZeV/zVMFgs/cYhGkWyU7CAOx85Vyc+x+o7DqjAADBkAAAAABJRU5ErkJggg==",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/elli-sui-wallet/ocjdpmoallmgmjbbogfiiaofphbjgchh?utm_source=wallet-kit"
  }
}), Pg = Rt({
  name: "TokenPocket Wallet",
  label: "TokenPocket Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzQwOF8yMjUpIj4KPHBhdGggZD0iTTEwNDEuNTIgMEgtMjdWMTAyNEgxMDQxLjUyVjBaIiBmaWxsPSIjMjk4MEZFIi8+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF80MDhfMjI1KSI+CjxwYXRoIGQ9Ik00MDYuNzk2IDQzOC42NDNINDA2LjkyN0M0MDYuNzk2IDQzNy44NTcgNDA2Ljc5NiA0MzYuOTQgNDA2Ljc5NiA0MzYuMTU0VjQzOC42NDNaIiBmaWxsPSIjMjlBRUZGIi8+CjxwYXRoIGQ9Ik02NjcuNjAyIDQ2My41MzNINTIzLjI0OVY3MjQuMDc2QzUyMy4yNDkgNzM2LjM4OSA1MzMuMjA0IDc0Ni4zNDUgNTQ1LjUxNyA3NDYuMzQ1SDY0NS4zMzNDNjU3LjY0NyA3NDYuMzQ1IDY2Ny42MDIgNzM2LjM4OSA2NjcuNjAyIDcyNC4wNzZWNDYzLjUzM1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00NTMuNTYzIDI3N0g0NDguNzE2SDE5MC4yNjlDMTc3Ljk1NSAyNzcgMTY4IDI4Ni45NTUgMTY4IDI5OS4yNjlWMzg5LjY1M0MxNjggNDAxLjk2NyAxNzcuOTU1IDQxMS45MjIgMTkwLjI2OSA0MTEuOTIySDI1MC45MThIMjc1LjAyMVY0MzguNjQ0VjcyNC43MzFDMjc1LjAyMSA3MzcuMDQ1IDI4NC45NzYgNzQ3IDI5Ny4yODkgNzQ3SDM5Mi4xMjhDNDA0LjQ0MSA3NDcgNDE0LjM5NiA3MzcuMDQ1IDQxNC4zOTYgNzI0LjczMVY0MzguNjQ0VjQzNi4xNTZWNDExLjkyMkg0MzguNDk5SDQ0OC4zMjNINDUzLjE3QzQ5MC4zNzIgNDExLjkyMiA1MjAuNjMxIDM4MS42NjMgNTIwLjYzMSAzNDQuNDYxQzUyMS4wMjQgMzA3LjI1OSA0OTAuNzY1IDI3NyA0NTMuNTYzIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik02NjcuNzM1IDQ2My41MzNWNjQ1LjM1QzY3Mi43MTMgNjQ2LjUyOSA2NzcuODIxIDY0Ny40NDYgNjgzLjA2MSA2NDguMjMyQzY5MC4zOTcgNjQ5LjI4IDY5Ny45OTQgNjQ5LjkzNSA3MDUuNTkyIDY1MC4wNjZDNzA1Ljk4NSA2NTAuMDY2IDcwNi4zNzggNjUwLjA2NiA3MDYuOTAyIDY1MC4wNjZWNTA1LjQ1QzY4NS4wMjYgNTA0LjAwOSA2NjcuNzM1IDQ4NS44MDEgNjY3LjczNSA0NjMuNTMzWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzQwOF8yMjUpIi8+CjxwYXRoIGQ9Ik03MDkuNzgxIDI3N0M2MDYuODIyIDI3NyA1MjMuMjQ5IDM2MC41NzMgNTIzLjI0OSA0NjMuNTMzQzUyMy4yNDkgNTUyLjA4NCA1ODQuOTQ2IDYyNi4yMjUgNjY3LjczMyA2NDUuMzVWNDYzLjUzM0M2NjcuNzMzIDQ0MC4zNDcgNjg2LjU5NiA0MjEuNDg0IDcwOS43ODEgNDIxLjQ4NEM3MzIuOTY3IDQyMS40ODQgNzUxLjgzIDQ0MC4zNDcgNzUxLjgzIDQ2My41MzNDNzUxLjgzIDQ4My4wNTEgNzM4LjYgNDk5LjQyNSA3MjAuNTIzIDUwNC4xNEM3MTcuMTE3IDUwNS4wNTcgNzEzLjQ0OSA1MDUuNTgxIDcwOS43ODEgNTA1LjU4MVY2NTAuMDY2QzcxMy40NDkgNjUwLjA2NiA3MTYuOTg2IDY0OS45MzUgNzIwLjUyMyA2NDkuODA0QzgxOC41MDUgNjQ0LjE3MSA4OTYuMzE0IDU2Mi45NTYgODk2LjMxNCA0NjMuNTMzQzg5Ni40NDUgMzYwLjU3MyA4MTIuODcyIDI3NyA3MDkuNzgxIDI3N1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik03MDkuNzggNjUwLjA2NlY1MDUuNTgxQzcwOC43MzMgNTA1LjU4MSA3MDcuODE2IDUwNS41ODEgNzA2Ljc2OCA1MDUuNDVWNjUwLjA2NkM3MDcuODE2IDY1MC4wNjYgNzA4Ljg2NCA2NTAuMDY2IDcwOS43OCA2NTAuMDY2WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNDA4XzIyNSIgeDE9IjcwOS44NDQiIHkxPSI1NTYuODI3IiB4Mj0iNjY3Ljc1MyIgeTI9IjU1Ni44MjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0id2hpdGUiLz4KPHN0b3Agb2Zmc2V0PSIwLjk2NjciIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMzIzMyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAuMyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzQwOF8yMjUiPgo8cmVjdCB3aWR0aD0iNzI4LjQ0OCIgaGVpZ2h0PSI0NzAiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjggMjc3KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://tokenpocket.pro/"
  }
}), kg = Rt({
  name: "Frontier Wallet",
  label: "Frontier Wallet",
  iconUrl: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC45OTkwMjMiIHk9IjAuMTIxMDk0IiB3aWR0aD0iMzAuOTUyNCIgaGVpZ2h0PSIzMC45NTI0IiBmaWxsPSIjQ0M3MDNDIi8+CjxwYXRoIGQ9Ik0yMyA4TDIyLjkxNDQgOC4yMzQ2TDIyLjYzMjYgOC45ODUxOUwyMi40NDU1IDkuNDY5MTlDMjEuMDI1IDEzLjA5NjkgMTkuOTE5OCAxNC44MTg2IDE4Ljc0NTIgMTQuODE4NkMxOC4wNjgzIDE0LjgxODYgMTcuNjY3NyAxNC42MTcyIDE3LjE0OSAxNC4xNDQ1TDE2Ljk5OTIgMTQuMDA0MUMxNi42MjYgMTMuNjQ4OCAxNi40Njg5IDEzLjU2MTQgMTYuMTA5OSAxMy41NjE0QzE1LjkyMjggMTMuNTYxNCAxNS41ODggMTMuODA4OCAxNS4xNjQzIDE0LjM4NkMxNC43MjUgMTQuOTg0NiAxNC4yNDMyIDE1Ljg2ODggMTMuNzI1NCAxNy4wMzM2TDEzLjY3NzIgMTcuMTQyNkwxOC43MTY3IDE3LjE0MjlMMTguMDg5MiAxOC40ODU3SDEzLjM4MzNWMjRIMTJWOEgyM1pNMjEuMDM5MSA5LjM0MzMyTDEzLjM4MzIgOS4zNDI4NlYxNC42NzUyQzE0LjMwMDUgMTMuMDM0IDE1LjE3MjEgMTIuMjEgMTYuMTA5OSAxMi4yMUMxNi44MzkgMTIuMjEgMTcuMjY4NiAxMi40MjE4IDE3LjgxMDYgMTIuOTE0NkwxNy45NjUyIDEzLjA1OTRDMTguMzEzNiAxMy4zOTExIDE4LjQ0NzkgMTMuNDY3MiAxOC43NDUyIDEzLjQ2NzJDMTkuMDc0IDEzLjQ2NzIgMTkuOTQ0NyAxMi4wNDE4IDIxLjAzOTEgOS4zNDMzMloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",
  downloadUrl: {
    browserExtension: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
  }
}), _g = [
  Ng,
  Tg,
  ...[
    Ig,
    Og,
    Dg,
    jg,
    Cg,
    xg,
    Lg,
    Bg,
    Rg,
    Ug,
    Pg,
    kg
  ].sort((e, t) => e.name < t.name ? -1 : 1)
];
var Fg = typeof global == "object" && global && global.Object === Object && global;
const zg = Fg;
var Qg = typeof self == "object" && self && self.Object === Object && self, Wg = zg || Qg || Function("return this")();
const rs = Wg;
var Yg = rs.Symbol;
const en = Yg;
var bu = Object.prototype, Hg = bu.hasOwnProperty, qg = bu.toString, pn = en ? en.toStringTag : void 0;
function Zg(e) {
  var t = Hg.call(e, pn), r = e[pn];
  try {
    e[pn] = void 0;
    var n = !0;
  } catch {
  }
  var i = qg.call(e);
  return n && (t ? e[pn] = r : delete e[pn]), i;
}
var Kg = Object.prototype, Vg = Kg.toString;
function Gg(e) {
  return Vg.call(e);
}
var $g = "[object Null]", Xg = "[object Undefined]", ea = en ? en.toStringTag : void 0;
function ns(e) {
  return e == null ? e === void 0 ? Xg : $g : ea && ea in Object(e) ? Zg(e) : Gg(e);
}
function is(e) {
  return e != null && typeof e == "object";
}
var Jg = "[object Symbol]";
function os(e) {
  return typeof e == "symbol" || is(e) && ns(e) == Jg;
}
function ey(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
    i[r] = t(e[r], r, e);
  return i;
}
var ty = Array.isArray;
const Ni = ty;
var ry = 1 / 0, ta = en ? en.prototype : void 0, ra = ta ? ta.toString : void 0;
function vu(e) {
  if (typeof e == "string")
    return e;
  if (Ni(e))
    return ey(e, vu) + "";
  if (os(e))
    return ra ? ra.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -ry ? "-0" : t;
}
function mu(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var ny = "[object AsyncFunction]", iy = "[object Function]", oy = "[object GeneratorFunction]", sy = "[object Proxy]";
function ay(e) {
  if (!mu(e))
    return !1;
  var t = ns(e);
  return t == iy || t == oy || t == ny || t == sy;
}
var cy = rs["__core-js_shared__"];
const Ki = cy;
var na = function() {
  var e = /[^.]+$/.exec(Ki && Ki.keys && Ki.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function uy(e) {
  return !!na && na in e;
}
var ly = Function.prototype, fy = ly.toString;
function dy(e) {
  if (e != null) {
    try {
      return fy.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var hy = /[\\^$.*+?()[\]{}|]/g, py = /^\[object .+?Constructor\]$/, gy = Function.prototype, yy = Object.prototype, by = gy.toString, vy = yy.hasOwnProperty, my = RegExp(
  "^" + by.call(vy).replace(hy, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function wy(e) {
  if (!mu(e) || uy(e))
    return !1;
  var t = ay(e) ? my : py;
  return t.test(dy(e));
}
function Ey(e, t) {
  return e?.[t];
}
function wu(e, t) {
  var r = Ey(e, t);
  return wy(r) ? r : void 0;
}
var Ay = 9007199254740991, My = /^(?:0|[1-9]\d*)$/;
function Sy(e, t) {
  var r = typeof e;
  return t = t ?? Ay, !!t && (r == "number" || r != "symbol" && My.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function Ny(e, t) {
  return e === t || e !== e && t !== t;
}
var Ty = 9007199254740991;
function Iy(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Ty;
}
var Oy = "[object Arguments]";
function ia(e) {
  return is(e) && ns(e) == Oy;
}
var Eu = Object.prototype, Dy = Eu.hasOwnProperty, Cy = Eu.propertyIsEnumerable, jy = ia(function() {
  return arguments;
}()) ? ia : function(e) {
  return is(e) && Dy.call(e, "callee") && !Cy.call(e, "callee");
};
const xy = jy;
var Ly = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, By = /^\w*$/;
function Ry(e, t) {
  if (Ni(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || os(e) ? !0 : By.test(e) || !Ly.test(e) || t != null && e in Object(t);
}
var Uy = wu(Object, "create");
const Mn = Uy;
function Py() {
  this.__data__ = Mn ? Mn(null) : {}, this.size = 0;
}
function ky(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var _y = "__lodash_hash_undefined__", Fy = Object.prototype, zy = Fy.hasOwnProperty;
function Qy(e) {
  var t = this.__data__;
  if (Mn) {
    var r = t[e];
    return r === _y ? void 0 : r;
  }
  return zy.call(t, e) ? t[e] : void 0;
}
var Wy = Object.prototype, Yy = Wy.hasOwnProperty;
function Hy(e) {
  var t = this.__data__;
  return Mn ? t[e] !== void 0 : Yy.call(t, e);
}
var qy = "__lodash_hash_undefined__";
function Zy(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = Mn && t === void 0 ? qy : t, this;
}
function Pr(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
Pr.prototype.clear = Py;
Pr.prototype.delete = ky;
Pr.prototype.get = Qy;
Pr.prototype.has = Hy;
Pr.prototype.set = Zy;
function Ky() {
  this.__data__ = [], this.size = 0;
}
function Ti(e, t) {
  for (var r = e.length; r--; )
    if (Ny(e[r][0], t))
      return r;
  return -1;
}
var Vy = Array.prototype, Gy = Vy.splice;
function $y(e) {
  var t = this.__data__, r = Ti(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : Gy.call(t, r, 1), --this.size, !0;
}
function Xy(e) {
  var t = this.__data__, r = Ti(t, e);
  return r < 0 ? void 0 : t[r][1];
}
function Jy(e) {
  return Ti(this.__data__, e) > -1;
}
function e1(e, t) {
  var r = this.__data__, n = Ti(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
function on(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
on.prototype.clear = Ky;
on.prototype.delete = $y;
on.prototype.get = Xy;
on.prototype.has = Jy;
on.prototype.set = e1;
var t1 = wu(rs, "Map");
const r1 = t1;
function n1() {
  this.size = 0, this.__data__ = {
    hash: new Pr(),
    map: new (r1 || on)(),
    string: new Pr()
  };
}
function i1(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Ii(e, t) {
  var r = e.__data__;
  return i1(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
function o1(e) {
  var t = Ii(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function s1(e) {
  return Ii(this, e).get(e);
}
function a1(e) {
  return Ii(this, e).has(e);
}
function c1(e, t) {
  var r = Ii(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
function _r(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
_r.prototype.clear = n1;
_r.prototype.delete = o1;
_r.prototype.get = s1;
_r.prototype.has = a1;
_r.prototype.set = c1;
var u1 = "Expected a function";
function ss(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(u1);
  var r = function() {
    var n = arguments, i = t ? t.apply(this, n) : n[0], o = r.cache;
    if (o.has(i))
      return o.get(i);
    var a = e.apply(this, n);
    return r.cache = o.set(i, a) || o, a;
  };
  return r.cache = new (ss.Cache || _r)(), r;
}
ss.Cache = _r;
var l1 = 500;
function f1(e) {
  var t = ss(e, function(n) {
    return r.size === l1 && r.clear(), n;
  }), r = t.cache;
  return t;
}
var d1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, h1 = /\\(\\)?/g, p1 = f1(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(d1, function(r, n, i, o) {
    t.push(i ? o.replace(h1, "$1") : n || r);
  }), t;
});
const g1 = p1;
function y1(e) {
  return e == null ? "" : vu(e);
}
function b1(e, t) {
  return Ni(e) ? e : Ry(e, t) ? [e] : g1(y1(e));
}
var v1 = 1 / 0;
function m1(e) {
  if (typeof e == "string" || os(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -v1 ? "-0" : t;
}
function w1(e, t, r) {
  t = b1(t, e);
  for (var n = -1, i = t.length, o = !1; ++n < i; ) {
    var a = m1(t[n]);
    if (!(o = e != null && r(e, a)))
      break;
    e = e[a];
  }
  return o || ++n != i ? o : (i = e == null ? 0 : e.length, !!i && Iy(i) && Sy(a, i) && (Ni(e) || xy(e)));
}
var E1 = Object.prototype, A1 = E1.hasOwnProperty;
function M1(e, t) {
  return e != null && A1.call(e, t);
}
function oa(e, t) {
  return e != null && w1(e, t, M1);
}
function S1(e, t) {
  let r = Gt.WALLET__CONNECT_ERROR, n = e.message;
  switch (t) {
    case wr.SUI_WALLET:
    case wr.ETHOS_WALLET:
    case wr.GLASS_WALLET:
    case wr.MORPHIS_WALLET:
      n.includes("Permission rejected") && (r = Gt.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case wr.SUIET_WALLET:
      n.includes("User rejects approval") && (r = Gt.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
    case wr.SPACECY_WALLET:
      r = Gt.WALLET__CONNECT_ERROR__USER_REJECTED;
      break;
    case wr.SURF_WALLET:
      n.includes("The user rejected the request") && (r = Gt.WALLET__CONNECT_ERROR__USER_REJECTED);
      break;
  }
  return {
    code: r,
    message: n,
    details: {
      wallet: t
    }
  };
}
var N1 = Object.defineProperty, T1 = (e, t, r) => t in e ? N1(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, I1 = (e, t, r) => (T1(e, typeof t != "symbol" ? t + "" : t, r), r), Au = /* @__PURE__ */ ((e) => (e.STANDARD__CONNECT = "standard:connect", e.STANDARD__DISCONNECT = "standard:disconnect", e.STANDARD__EVENTS = "standard:events", e.SUI__SIGN_AND_EXECUTE_TRANSACTION_BLOCK = "sui:signAndExecuteTransactionBlock", e.SUI__SIGN_TRANSACTION_BLOCK = "sui:signTransactionBlock", e.SUI__SIGN_MESSAGE = "sui:signMessage", e))(Au || {});
class sa {
  constructor(t) {
    I1(this, "standardWalletAdapter"), this.standardWalletAdapter = t;
  }
  get name() {
    return this.standardWalletAdapter.name;
  }
  get icon() {
    return this.standardWalletAdapter.icon;
  }
  get version() {
    return this.standardWalletAdapter.version;
  }
  get accounts() {
    return this.standardWalletAdapter.accounts;
  }
  get chains() {
    return this.standardWalletAdapter.chains;
  }
  get features() {
    return this.standardWalletAdapter.features;
  }
  async connect(t) {
    const r = this.getFeature(
      "standard:connect"
    );
    try {
      return await r.connect(t);
    } catch (n) {
      const { code: i, message: o, details: a } = S1(n, this.name);
      throw new jr(o, i, a);
    }
  }
  async disconnect() {
    const t = this.getFeature(
      "standard:disconnect"
    );
    try {
      return await t.disconnect();
    } catch (r) {
      throw new jr(r.message, Gt.WALLET__DISCONNECT_ERROR);
    }
  }
  on(t, r) {
    const n = this.getFeature(
      "standard:events"
    );
    try {
      return n.on(t, r);
    } catch (i) {
      throw new jr(i.message, Gt.WALLET__LISTEN_TO_EVENT_ERROR);
    }
  }
  async signAndExecuteTransactionBlock(t) {
    const r = this.getFeature("sui:signAndExecuteTransactionBlock");
    try {
      return await r.signAndExecuteTransactionBlock(t);
    } catch (n) {
      throw new jr(n.message, Gt.WALLET__SIGN_TX_ERROR);
    }
  }
  signTransactionBlock(t) {
    const r = this.getFeature("sui:signTransactionBlock");
    try {
      return r.signTransactionBlock(t);
    } catch (n) {
      throw new jr(n.message, Gt.WALLET__SIGN_TX_ERROR);
    }
  }
  async signMessage(t) {
    const r = this.getFeature(
      "sui:signMessage"
    );
    try {
      return await r.signMessage(t);
    } catch (n) {
      throw new jr(n.message, Gt.WALLET__SIGN_MSG_ERROR);
    }
  }
  hasFeature(t) {
    const { features: r } = this.standardWalletAdapter;
    return oa(r, t);
  }
  getFeature(t) {
    const { features: r } = this.standardWalletAdapter;
    if (!oa(r, t))
      throw new mf(t);
    return r[t];
  }
}
var O1 = globalThis && globalThis.__classPrivateFieldSet || function(e, t, r, n, i) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(e, r) : i ? i.value = r : t.set(e, r), r;
}, D1 = globalThis && globalThis.__classPrivateFieldGet || function(e, t, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !n : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
}, Hn;
let gn;
const qn = /* @__PURE__ */ new Set(), Vr = {};
function C1() {
  if (gn || (gn = Object.freeze({ register: aa, get: j1, on: x1 }), typeof window > "u"))
    return gn;
  const e = Object.freeze({ register: aa });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: t }) => t(e));
  } catch (t) {
    console.error(`wallet-standard:register-wallet event listener could not be added
`, t);
  }
  try {
    window.dispatchEvent(new L1(e));
  } catch (t) {
    console.error(`wallet-standard:app-ready event could not be dispatched
`, t);
  }
  return gn;
}
function aa(...e) {
  return e = e.filter((t) => !qn.has(t)), e.length ? (e.forEach((t) => qn.add(t)), Vr.register?.forEach((t) => ca(() => t(...e))), function() {
    e.forEach((r) => qn.delete(r)), Vr.unregister?.forEach((r) => ca(() => r(...e)));
  }) : () => {
  };
}
function j1() {
  return [...qn];
}
function x1(e, t) {
  return Vr[e]?.push(t) || (Vr[e] = [t]), function() {
    Vr[e] = Vr[e]?.filter((n) => t !== n);
  };
}
function ca(e) {
  try {
    e();
  } catch (t) {
    console.error(t);
  }
}
class L1 extends Event {
  constructor(t) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1
    }), Hn.set(this, void 0), O1(this, Hn, t, "f");
  }
  get detail() {
    return D1(this, Hn, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
Hn = /* @__PURE__ */ new WeakMap();
function B1() {
  const e = ht(), [t, r] = Bt([]);
  function n() {
    return e.current ? e.current.get().filter(Xs) : [];
  }
  return pt(() => {
    e.current = C1();
    const i = n();
    rr(i) && r(
      i.map((a) => new sa(a))
    );
    const o = e.current.on("register", (...a) => {
      if (!e.current)
        return;
      const f = [...n()];
      a.filter(Xs).filter((p) => !f.find((g) => g.name === p.name)).forEach((p) => {
        f.push(p);
      }), r(f.map((p) => new sa(p)));
    });
    return () => {
      o();
    };
  }, []), {
    data: t
  };
}
const R1 = (e) => {
  const { data: t } = B1(), r = tr(() => rr(e) ? rr(t) ? e.map((o) => {
    const a = t.find((u) => o.name === u.name);
    return a ? {
      ...o,
      adapter: a,
      installed: !0
    } : {
      ...o,
      adapter: void 0,
      installed: !1
    };
  }) : e.map((o) => ({
    ...o,
    adapter: void 0,
    installed: !1
  })) : [], [e, t]), n = tr(() => rr(t) ? t.filter((o) => !e.find((a) => a.name === o.name)).map((o) => ({
    name: o.name,
    label: o.name,
    adapter: o,
    installed: !0,
    iconUrl: o.icon,
    downloadUrl: {
      browserExtension: ""
    }
  })) : [], [e, t]);
  return {
    allAvailableWallets: tr(() => [
      ...r,
      ...n
    ].filter((o) => o.installed), [r, n]),
    configuredWallets: r,
    detectedWallets: n
  };
};
class bo {
  constructor() {
    if (!window)
      throw new Error("window not found: storage should be used in browser env");
  }
  get length() {
    return window.localStorage.length;
  }
  setItem(t, r) {
    try {
      let n = JSON.stringify(r);
      return window.localStorage.setItem(t, n);
    } catch (n) {
      throw new Error("stringify data failed when setItem: " + n.message);
    }
  }
  getItem(t) {
    const r = window.localStorage.getItem(t);
    if (!r)
      return r;
    try {
      return JSON.parse(r);
    } catch (n) {
      throw new Error("parse data failed when getItem: " + n.message);
    }
  }
  removeItem(t) {
    return window.localStorage.removeItem(t);
  }
  clear() {
    return window.localStorage.clear();
  }
}
var si = /* @__PURE__ */ ((e) => (e.LAST_CONNECT_WALLET_NAME = "WK__LAST_CONNECT_WALLET_NAME", e))(si || {});
function U1(e, t, r, n) {
  const i = ht(!1);
  pt(() => {
    if (!n || i.current || !rr(r) || t !== Kt.DISCONNECTED)
      return;
    const a = new bo().getItem(si.LAST_CONNECT_WALLET_NAME);
    !a || r.find((u) => u.name == a) && e(a).then(() => {
      i.current = !0;
    }).catch((u) => {
    });
  }, [r]);
}
function P1(e) {
  return e?.accounts?.[0]?.chains?.[0] ? e.accounts[0].chains[0] : "sui:unknown";
}
const q1 = (e) => {
  const {
    defaultWallets: t = _g,
    chains: r = rd,
    autoConnect: n = !0,
    children: i
  } = e, {
    allAvailableWallets: o,
    configuredWallets: a,
    detectedWallets: u
  } = R1(t), [f, p] = Bt(), [g, y] = Bt(Kt.DISCONNECTED), [A, S] = Bt(() => rr(r) ? r[0] : Yn), I = ht([]), D = (B, E) => B && E === Kt.CONNECTED, L = tr(() => {
    if (!!D(f, g))
      return f.accounts[0];
  }, [f, g]), Y = (B, E) => {
    if (!D(B, E))
      throw new Ot("Failed to call function, wallet not connected");
  }, M = St(async (B, E) => {
    if (!B)
      throw new Ot("param adapter is missing");
    y(Kt.CONNECTING);
    try {
      const T = await B.connect(E);
      if (rr(T?.accounts)) {
        const K = P1(T), $ = r.find((W) => W.id === K);
        S($ ?? Yn);
      }
      return p(B), y(Kt.CONNECTED), new bo().setItem(si.LAST_CONNECT_WALLET_NAME, B.name), T;
    } catch (T) {
      throw p(void 0), y(Kt.DISCONNECTED), T;
    }
  }, []), N = St(async () => {
    Y(f, g);
    const B = f;
    rr(I.current) && (I.current.forEach((T) => {
      try {
        T();
      } catch (C) {
        console.error("error when clearing wallet listener", C.message);
      }
    }), I.current = []), new bo().removeItem(si.LAST_CONNECT_WALLET_NAME);
    try {
      B.hasFeature(Au.STANDARD__DISCONNECT) && await B.disconnect();
    } finally {
      p(void 0), y(Kt.DISCONNECTED), S(r?.[0] ?? Yn);
    }
  }, [f, g]), b = St(async (B) => {
    if (D(f, g)) {
      if (B === f.name)
        return;
      await N();
    }
    const E = o.find((T) => T.name === B);
    if (!E) {
      const T = o.map((C) => C.name);
      throw new Ot(`select failed: wallet ${B} is not available, all wallets are listed here: [${T.join(", ")}]`);
    }
    await M(E.adapter);
  }, [f, g, o]), k = St((B, E) => {
    Y(f, g);
    const C = f.on("change", (K) => {
      if (B === "change") {
        E(K);
        return;
      }
      if (K.accounts && B === "accountChange") {
        E({
          account: K.accounts?.[0]
        });
        return;
      }
      if (K.features && B === "featureChange") {
        E({
          features: K.features
        });
        return;
      }
    });
    return I.current.push(C), C;
  }, [f, g]), O = St(() => (Y(f, g), f.accounts), [f, g]), R = St(async (B) => {
    if (Y(f, g), !L)
      throw new Ot("no active account");
    return await f.signAndExecuteTransactionBlock({
      account: L,
      chain: A.id,
      ...B
    });
  }, [f, g, A, L]), Q = St(async (B) => {
    if (Y(f, g), !L)
      throw new Ot("no active account");
    return await f.signTransactionBlock({
      account: L,
      chain: A.id,
      ...B
    });
  }, [f, g, A, L]), G = St(async (B) => {
    if (Y(f, g), !L)
      throw new Ot("no active account");
    return await f.signMessage({
      account: L,
      message: B.message
    });
  }, [f, L, g]);
  return U1(b, g, o, n), /* @__PURE__ */ ge(La.Provider, {
    value: {
      name: f?.name,
      chains: r,
      chain: A,
      allAvailableWallets: o,
      configuredWallets: a,
      detectedWallets: u,
      adapter: f,
      status: g,
      connecting: g === Kt.CONNECTING,
      connected: g === Kt.CONNECTED,
      select: b,
      disconnect: N,
      on: k,
      getAccounts: O,
      account: L,
      signAndExecuteTransactionBlock: R,
      signMessage: G,
      signTransactionBlock: Q,
      verifySignedMessage: hg,
      address: L?.address
    },
    children: /* @__PURE__ */ ge(Hf, {
      client: new _f(),
      children: i
    })
  });
};
function Mu(e) {
  if (typeof e == "string") {
    console.warn(`[DEPRECATED] ${e}`);
    return;
  }
  const { name: t, message: r, migrationDoc: n } = e;
  console.warn(`[DEPRECATED] ${t} is no longer supported. ` + r + (n ? ` | Check migration doc: ${n}` : ""));
}
function Z1() {
  return Mu({
    name: "getDefaultWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
function K1() {
  return Mu({
    name: "getAllWallets",
    message: "If you want to customize wallet list, use defaultWallets instead",
    migrationDoc: "https://kit.suiet.app/docs/migration/upgradeTo0.1.0"
  }), [];
}
export {
  ad as Account,
  _g as AllDefaultWallets,
  xa as BaseError,
  H1 as ConnectButton,
  Mg as ConnectModal,
  Kt as ConnectionStatus,
  rd as DefaultChains,
  Ug as ElliWallet,
  Gt as ErrorCode,
  Ig as EthosWallet,
  kg as FrontierWallet,
  Cg as GlassWallet,
  Ot as KitError,
  Og as MartianWallet,
  jg as MorphisWallet,
  Rg as NightlyWallet,
  xg as OneKeyWallet,
  wr as PresetWallet,
  cd as Provider,
  Q1 as SUI_SYSTEM_STATE_OBJECT_ID,
  Bg as SensuiWallet,
  Lg as SpacecyWallet,
  Xf as SuiChainId,
  Jf as SuiDevnetChain,
  td as SuiMainnetChain,
  ed as SuiTestnetChain,
  Tg as SuiWallet,
  Ng as SuietWallet,
  Dg as SurfWallet,
  Pg as TokenPocketWallet,
  Yn as UnknownChain,
  La as WalletContext,
  jr as WalletError,
  mf as WalletNotImplementError,
  q1 as WalletProvider,
  hd as addressEllipsis,
  Rt as defineWallet,
  Wa as formatCurrency,
  ld as formatSUI,
  K1 as getAllWallets,
  Z1 as getDefaultWallets,
  W1 as stringBytesToString,
  yu as stringBytesToUint8Array,
  yg as useAccountBalance,
  pg as useChain,
  gg as useCoinBalance,
  Y1 as useSuiProvider,
  Sn as useWallet,
  hg as verifySignedMessage
};
